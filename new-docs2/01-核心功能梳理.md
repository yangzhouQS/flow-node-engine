# Flowable 核心功能梳理 - Node.js + NestJS 实现方案

## 文档说明

本文档基于 Flowable 7.0.0 源码的深入分析，梳理出完整的流程引擎核心功能，并提供 Node.js + NestJS + MySQL 技术栈的实现思路。

---

## 一、核心功能清单

### 1.1 流程定义管理（BPMN 2.0 规范支持）

#### 功能描述
- **BPMN 2.0 XML 解析**：解析 BPMN 2.0 格式的流程定义文件
- **流程定义部署**：将流程定义部署到引擎中
- **版本管理**：支持同一流程定义的多个版本
- **流程定义查询**：按条件查询流程定义
- **流程定义激活/暂停**：控制流程定义是否可用
- **流程定义删除**：删除不再使用的流程定义
- **流程图生成**：生成流程定义的可视化图片

#### Flowable 源码分析

**核心类**：
- `RepositoryService`：流程定义管理服务接口
- `BpmnModel`：BPMN 模型对象
- `ProcessDefinition`：流程定义实体

**关键方法**：
```java
// 部署流程定义
DeploymentBuilder createDeployment();
void deleteDeployment(String deploymentId);

// 流程定义查询
ProcessDefinitionQuery createProcessDefinitionQuery();
ProcessDefinition getProcessDefinition(String processDefinitionId);
BpmnModel getBpmnModel(String processDefinitionId);

// 流程定义状态管理
void suspendProcessDefinitionById(String processDefinitionId);
void activateProcessDefinitionById(String processDefinitionId);
```

#### Node.js + NestJS 实现思路

**技术选型**：
- **BPMN 解析**：`bpmn-moddle` 库解析 BPMN XML
- **流程图生成**：`bpmn-to-image` 或 `bpmn-js` 生成流程图

**核心服务设计**：
```typescript
// process-definition.service.ts
@Injectable()
export class ProcessDefinitionService {
  constructor(
    private readonly bpmnParserService: BpmnParserService,
    private readonly processDefinitionRepository: ProcessDefinitionRepository,
  ) {}

  // 部署流程定义
  async deploy(dto: DeployProcessDefinitionDto): Promise<Deployment> {
    // 1. 解析 BPMN XML
    const bpmnModel = await this.bpmnParserService.parse(dto.bpmnXml);
    
    // 2. 验证 BPMN 模型
    this.validateBpmnModel(bpmnModel);
    
    // 3. 生成流程定义 ID 和版本号
    const processDefinition = await this.createProcessDefinition(bpmnModel);
    
    // 4. 保存流程定义到数据库
    await this.processDefinitionRepository.save(processDefinition);
    
    // 5. 生成流程图（可选）
    if (dto.generateDiagram) {
      await this.generateProcessDiagram(processDefinition);
    }
    
    return processDefinition;
  }

  // 查询流程定义
  async findById(id: string): Promise<ProcessDefinition> {
    return this.processDefinitionRepository.findOne({ where: { id } });
  }

  async findByKey(key: string): Promise<ProcessDefinition[]> {
    return this.processDefinitionRepository.find({ 
      where: { key },
      order: { version: 'DESC' }
    });
  }

  async findLatestByKey(key: string): Promise<ProcessDefinition> {
    return this.processDefinitionRepository.findOne({ 
      where: { key },
      order: { version: 'DESC' }
    });
  }

  // 激活/暂停流程定义
  async suspend(id: string): Promise<void> {
    await this.processDefinitionRepository.update(id, { 
      suspended: true,
      suspensionState: SuspensionState.SUSPENDED
    });
  }

  async activate(id: string): Promise<void> {
    await this.processDefinitionRepository.update(id, { 
      suspended: false,
      suspensionState: SuspensionState.ACTIVE
    });
  }

  // 删除流程定义
  async delete(id: string, cascade: boolean = false): Promise<void> {
    if (cascade) {
      // 级联删除流程实例、任务等
      await this.deleteCascade(id);
    } else {
      // 检查是否有运行中的流程实例
      const hasRunningInstances = await this.hasRunningInstances(id);
      if (hasRunningInstances) {
        throw new BusinessException('流程定义有运行中的实例，无法删除');
      }
      await this.processDefinitionRepository.delete(id);
    }
  }
}
```

**BPMN 解析服务**：
```typescript
// bpmn-parser.service.ts
@Injectable()
export class BpmnParserService {
  async parse(bpmnXml: string): Promise<BpmnModel> {
    const moddle = createModdle();
    const definitions = await moddle.fromXML(bpmnXml);
    
    return {
      id: definitions.id,
      targetNamespace: definitions.targetNamespace,
      processes: definitions.rootElements?.filter(el => el.$type === 'bpmn:Process'),
      messages: definitions.rootElements?.filter(el => el.$type === 'bpmn:Message'),
      signals: definitions.rootElements?.filter(el => el.$type === 'bpmn:Signal'),
    };
  }

  validate(bpmnModel: BpmnModel): ValidationError[] {
    const errors: ValidationError[] = [];
    
    // 验证流程定义
    bpmnModel.processes?.forEach(process => {
      if (!process.id) {
        errors.push({
          level: 'ERROR',
          message: '流程缺少 ID',
          element: process,
        });
      }
      
      // 验证流程节点
      this.validateProcessNodes(process, errors);
    });
    
    return errors;
  }
}
```

---

### 1.2 流程实例管理

#### 功能描述
- **流程实例启动**：根据流程定义启动新的流程实例
- **流程实例查询**：按条件查询流程实例
- **流程变量管理**：设置、获取、删除流程变量
- **流程实例挂起/恢复**：暂停或恢复流程实例的执行
- **流程实例终止**：终止正在运行的流程实例
- **流程实例删除**：删除流程实例（运行时）

#### Flowable 源码分析

**核心类**：
- `RuntimeService`：流程实例运行时服务接口
- `ProcessInstance`：流程实例实体
- `Execution`：执行实例实体

**关键方法**：
```java
// 流程实例启动
ProcessInstance startProcessInstanceById(String processDefinitionId);
ProcessInstance startProcessInstanceByKey(String processDefinitionKey);
ProcessInstanceBuilder createProcessInstanceBuilder();

// 流程实例管理
void deleteProcessInstance(String processInstanceId, String deleteReason);
void suspendProcessInstanceById(String processInstanceId);
void activateProcessInstanceById(String processInstanceId);

// 变量管理
Map<String, Object> getVariables(String executionId);
void setVariable(String executionId, String variableName, Object value);
void setVariables(String executionId, Map<String, ? extends Object> variables);
```

#### Node.js + NestJS 实现思路

**核心服务设计**：
```typescript
// process-instance.service.ts
@Injectable()
export class ProcessInstanceService {
  constructor(
    private readonly processInstanceRepository: ProcessInstanceRepository,
    private readonly processDefinitionService: ProcessDefinitionService,
    private readonly executionService: ExecutionService,
    private readonly taskService: TaskService,
    private readonly eventBus: EventBusService,
  ) {}

  // 启动流程实例
  async start(dto: StartProcessInstanceDto): Promise<ProcessInstance> {
    // 1. 获取流程定义
    const processDefinition = await this.getProcessDefinition(dto);
    
    // 2. 验证流程定义状态
    if (processDefinition.suspended) {
      throw new BusinessException('流程定义已暂停，无法启动实例');
    }
    
    // 3. 创建流程实例
    const processInstance = this.createProcessInstance(processDefinition, dto);
    
    // 4. 保存流程实例
    await this.processInstanceRepository.save(processInstance);
    
    // 5. 初始化流程变量
    await this.initializeVariables(processInstance, dto.variables);
    
    // 6. 执行流程（从开始事件开始）
    await this.executeProcess(processInstance);
    
    // 7. 发布流程启动事件
    this.eventBus.emit('process.started', {
      processInstanceId: processInstance.id,
      processDefinitionId: processDefinition.id,
      businessKey: dto.businessKey,
    });
    
    return processInstance;
  }

  // 执行流程
  private async executeProcess(processInstance: ProcessInstance): Promise<void> {
    // 1. 获取流程定义的 BPMN 模型
    const bpmnModel = await this.processDefinitionService.getBpmnModel(
      processInstance.processDefinitionId
    );
    
    // 2. 查找开始事件
    const startEvent = this.findStartEvent(bpmnModel);
    
    // 3. 创建执行实例
    const execution = await this.executionService.create({
      processInstanceId: processInstance.id,
      activityId: startEvent.id,
      activityType: 'startEvent',
      isActive: true,
    });
    
    // 4. 执行开始事件
    await this.executeActivity(execution, startEvent);
    
    // 5. 查找并执行下一个活动
    await this.executeNextActivities(execution);
  }

  // 执行活动
  private async executeActivity(execution: Execution, activity: BpmnActivity): Promise<void> {
    switch (activity.$type) {
      case 'bpmn:StartEvent':
        await this.executeStartEvent(execution, activity);
        break;
      case 'bpmn:UserTask':
        await this.executeUserTask(execution, activity);
        break;
      case 'bpmn:ServiceTask':
        await this.executeServiceTask(execution, activity);
        break;
      case 'bpmn:ExclusiveGateway':
        await this.executeExclusiveGateway(execution, activity);
        break;
      case 'bpmn:ParallelGateway':
        await this.executeParallelGateway(execution, activity);
        break;
      case 'bpmn:EndEvent':
        await this.executeEndEvent(execution, activity);
        break;
      default:
        throw new BusinessException(`不支持的活动类型: ${activity.$type}`);
    }
  }

  // 执行用户任务
  private async executeUserTask(execution: Execution, activity: BpmnActivity): Promise<void> {
    // 1. 创建任务
    const task = await this.taskService.create({
      processInstanceId: execution.processInstanceId,
      processDefinitionId: execution.processDefinitionId,
      taskDefinitionKey: activity.id,
      name: activity.name || activity.id,
      type: TaskType.USER,
      status: TaskStatus.CREATED,
      assignee: activity.assignee,
      candidateUsers: activity.candidateUsers,
      candidateGroups: activity.candidateGroups,
    });
    
    // 2. 更新执行实例
    await this.executionService.update(execution.id, {
      activityId: activity.id,
      isActive: false,
    });
    
    // 3. 发布任务创建事件
    this.eventBus.emit('task.created', {
      taskId: task.id,
      processInstanceId: execution.processInstanceId,
    });
  }

  // 执行排他网关
  private async executeExclusiveGateway(execution: Execution, activity: BpmnActivity): Promise<void> {
    // 1. 获取流程变量
    const variables = await this.getVariables(execution.processInstanceId);
    
    // 2. 评估所有出线
    const outgoingFlows = activity.outgoing || [];
    let selectedFlow: BpmnSequenceFlow = null;
    
    for (const flow of outgoingFlows) {
      // 评估条件表达式
      if (this.evaluateCondition(flow.conditionExpression, variables)) {
        selectedFlow = flow;
        break;
      }
    }
    
    // 3. 如果没有匹配的条件，使用默认流
    if (!selectedFlow && outgoingFlows.length > 0) {
      selectedFlow = outgoingFlows.find(f => !f.conditionExpression);
    }
    
    // 4. 执行选中的流
    if (selectedFlow) {
      await this.executeSequenceFlow(execution, selectedFlow);
    } else {
      throw new BusinessException('排他网关没有匹配的出线');
    }
  }

  // 执行并行网关
  private async executeParallelGateway(execution: Execution, activity: BpmnActivity): Promise<void> {
    // 1. 获取所有出线
    const outgoingFlows = activity.outgoing || [];
    
    // 2. 为每条出线创建并发执行
    const executions = await Promise.all(
      outgoingFlows.map(flow => 
        this.executionService.create({
          processInstanceId: execution.processInstanceId,
          parentId: execution.id,
          activityId: flow.targetRef,
          isActive: true,
        })
      )
    );
    
    // 3. 更新原执行实例
    await this.executionService.update(execution.id, { isActive: false });
    
    // 4. 执行所有并发执行
    await Promise.all(
      executions.map(ex => this.executeNextActivities(ex))
    );
  }

  // 执行结束事件
  private async executeEndEvent(execution: Execution, activity: BpmnActivity): Promise<void> {
    // 1. 更新流程实例状态
    await this.processInstanceRepository.update(execution.processInstanceId, {
      status: ProcessInstanceStatus.COMPLETED,
      endTime: new Date(),
    });
    
    // 2. 删除执行实例
    await this.executionService.delete(execution.id);
    
    // 3. 发布流程完成事件
    this.eventBus.emit('process.completed', {
      processInstanceId: execution.processInstanceId,
    });
  }

  // 变量管理
  async setVariables(processInstanceId: string, variables: Record<string, any>): Promise<void> {
    await this.variableService.setVariables(processInstanceId, variables);
  }

  async getVariables(processInstanceId: string): Promise<Record<string, any>> {
    return this.variableService.getVariables(processInstanceId);
  }

  // 挂起流程实例
  async suspend(id: string): Promise<void> {
    await this.processInstanceRepository.update(id, {
      suspensionState: SuspensionState.SUSPENDED,
    });
    
    // 挂起所有活动任务
    await this.taskService.suspendByProcessInstanceId(id);
  }

  // 恢复流程实例
  async activate(id: string): Promise<void> {
    await this.processInstanceRepository.update(id, {
      suspensionState: SuspensionState.ACTIVE,
    });
    
    // 恢复所有活动任务
    await this.taskService.activateByProcessInstanceId(id);
  }

  // 终止流程实例
  async terminate(id: string, reason: string): Promise<void> {
    // 1. 更新流程实例状态
    await this.processInstanceRepository.update(id, {
      status: ProcessInstanceStatus.TERMINATED,
      endTime: new Date(),
      deleteReason: reason,
    });
    
    // 2. 删除所有活动任务
    await this.taskService.deleteByProcessInstanceId(id);
    
    // 3. 删除所有执行实例
    await this.executionService.deleteByProcessInstanceId(id);
    
    // 4. 发布流程终止事件
    this.eventBus.emit('process.terminated', {
      processInstanceId: id,
      reason,
    });
  }
}
```

---

### 1.3 任务管理

#### 功能描述
- **任务创建**：根据流程定义创建任务
- **任务分配**：将任务分配给用户或组
- **任务认领**：用户认领候选任务
- **任务完成**：完成任务并推动流程继续
- **任务退回/驳回**：将任务退回到指定节点或驳回到发起人
- **任务委托**：将任务委托给其他用户
- **任务抄送**：将流程信息抄送给相关人员
- **任务查询**：按条件查询任务
- **任务历史**：记录任务操作历史
- **退回策略配置**：配置节点级别的退回策略
- **多人任务退回**：处理会签/或签场景下的退回操作

#### Flowable 源码分析

**核心类**：
- `TaskService`：任务管理服务接口
- `Task`：任务实体
- `TaskListener`：任务监听器接口

**关键方法**：
```java
// 任务创建
Task newTask();

// 任务分配
void setAssignee(String taskId, String userId);
void addCandidateUser(String taskId, String userId);
void addCandidateGroup(String taskId, String groupId);

// 任务认领
void claim(String taskId, String userId);

// 任务完成
void complete(String taskId);
void complete(String taskId, Map<String, Object> variables);

// 任务查询
TaskQuery createTaskQuery();
```

#### Node.js + NestJS 实现思路

**核心服务设计**：
```typescript
// task.service.ts
@Injectable()
export class TaskService {
  constructor(
    private readonly taskRepository: TaskRepository,
    private readonly identityService: IdentityService,
    private readonly eventBus: EventBusService,
  ) {}

  // 创建任务
  async create(dto: CreateTaskDto): Promise<Task> {
    const task = this.taskRepository.create({
      ...dto,
      id: generateUuid(),
      status: TaskStatus.CREATED,
      createTime: new Date(),
    });
    
    // 设置候选用户
    if (dto.candidateUsers?.length > 0) {
      await this.addCandidateUsers(task.id, dto.candidateUsers);
    }
    
    // 设置候选组
    if (dto.candidateGroups?.length > 0) {
      await this.addCandidateGroups(task.id, dto.candidateGroups);
    }
    
    return this.taskRepository.save(task);
  }

  // 认领任务
  async claim(taskId: string, userId: string): Promise<Task> {
    const task = await this.taskRepository.findOne({ where: { id: taskId } });
    
    if (!task) {
      throw new NotFoundException('任务不存在');
    }
    
    if (task.status !== TaskStatus.CREATED) {
      throw new BusinessException('任务已被认领或完成');
    }
    
    // 检查用户是否是候选用户
    const isCandidate = await this.isCandidateUser(taskId, userId);
    if (!isCandidate && !task.assignee) {
      throw new BusinessException('用户无权认领此任务');
    }
    
    // 更新任务状态
    task.assignee = userId;
    task.status = TaskStatus.CLAIMED;
    task.claimTime = new Date();
    
    const updatedTask = await this.taskRepository.save(task);
    
    // 发布任务认领事件
    this.eventBus.emit('task.claimed', {
      taskId,
      userId,
    });
    
    return updatedTask;
  }

  // 完成任务
  async complete(taskId: string, dto: CompleteTaskDto): Promise<void> {
    const task = await this.taskRepository.findOne({ where: { id: taskId } });
    
    if (!task) {
      throw new NotFoundException('任务不存在');
    }
    
    if (task.status !== TaskStatus.CLAIMED && task.status !== TaskStatus.ASSIGNED) {
      throw new BusinessException('任务未分配，无法完成');
    }
    
    // 检查用户是否有权限完成任务
    if (task.assignee !== dto.userId) {
      throw new BusinessException('用户无权完成此任务');
    }
    
    // 更新任务状态
    task.status = TaskStatus.COMPLETED;
    task.completeTime = new Date();
    task.completeBy = dto.userId;
    task.variables = dto.variables;
    
    await this.taskRepository.save(task);
    
    // 发布任务完成事件
    this.eventBus.emit('task.completed', {
      taskId,
      processInstanceId: task.processInstanceId,
      userId: dto.userId,
      variables: dto.variables,
    });
    
    // 推动流程继续
    await this.continueProcess(task.processInstanceId, dto.variables);
  }

  // 退回任务
  async rollback(taskId: string, targetActivityId: string, reason: string): Promise<void> {
    const task = await this.taskRepository.findOne({ where: { id: taskId } });
    
    if (!task) {
      throw new NotFoundException('任务不存在');
    }
    
    // 1. 删除当前任务
    await this.taskRepository.delete(taskId);
    
    // 2. 在目标活动创建新任务
    const newTask = await this.create({
      processInstanceId: task.processInstanceId,
      processDefinitionId: task.processDefinitionId,
      taskDefinitionKey: targetActivityId,
      name: task.name,
      type: task.type,
      assignee: task.assignee,
      candidateUsers: task.candidateUsers,
      candidateGroups: task.candidateGroups,
    });
    
    // 3. 更新执行实例
    await this.executionService.updateByProcessInstanceId(
      task.processInstanceId,
      { activityId: targetActivityId }
    );
    
    // 4. 发布任务退回事件
    this.eventBus.emit('task.rolledback', {
      taskId,
      targetActivityId,
      reason,
    });
  }

  // 委托任务
  async delegate(taskId: string, fromUserId: string, toUserId: string): Promise<void> {
    const task = await this.taskRepository.findOne({ where: { id: taskId } });
    
    if (!task) {
      throw new NotFoundException('任务不存在');
    }
    
    if (task.assignee !== fromUserId) {
      throw new BusinessException('用户无权委托此任务');
    }
    
    // 1. 创建委托任务
    await this.create({
      processInstanceId: task.processInstanceId,
      processDefinitionId: task.processDefinitionId,
      taskDefinitionKey: task.taskDefinitionKey,
      name: task.name,
      type: TaskType.DELEGATE,
      assignee: toUserId,
      delegateTaskId: task.id,
    });
    
    // 2. 更新原任务状态
    task.status = TaskStatus.DELEGATED;
    task.delegateTo = toUserId;
    task.delegateTime = new Date();
    
    await this.taskRepository.save(task);
    
    // 3. 发布任务委托事件
    this.eventBus.emit('task.delegated', {
      taskId,
      fromUserId,
      toUserId,
    });
  }

  // 查询用户的待办任务
  async findTodoTasks(userId: string, query: TaskQueryDto): Promise<Task[]> {
    const queryBuilder = this.taskRepository.createQueryBuilder('task');
    
    // 查询分配给用户的任务
    queryBuilder.orWhere('task.assignee = :userId', { userId });
    
    // 查询用户是候选人的任务
    queryBuilder.orWhere(
      'task.id IN (SELECT taskId FROM task_candidate_user WHERE userId = :userId)',
      { userId }
    );
    
    // 查询用户所属组的候选任务
    const groupIds = await this.identityService.getUserGroupIds(userId);
    if (groupIds.length > 0) {
      queryBuilder.orWhere(
        'task.id IN (SELECT taskId FROM task_candidate_group WHERE groupId IN (:...groupIds))',
        { groupIds }
      );
    }
    
    // 添加其他查询条件
    if (query.processInstanceId) {
      queryBuilder.andWhere('task.processInstanceId = :processInstanceId', { 
        processInstanceId: query.processInstanceId 
      });
    }
    
    if (query.processDefinitionKey) {
      queryBuilder.andWhere('task.processDefinitionKey = :processDefinitionKey', { 
        processDefinitionKey: query.processDefinitionKey 
      });
    }
    
    // 分页
    queryBuilder.skip((query.page - 1) * query.pageSize);
    queryBuilder.take(query.pageSize);
    
    return queryBuilder.getMany();
  }

  // 查询用户的已办任务
  async findDoneTasks(userId: string, query: TaskQueryDto): Promise<Task[]> {
    return this.taskRepository.find({
      where: {
        completeBy: userId,
        status: TaskStatus.COMPLETED,
      },
      relations: ['processInstance'],
      skip: (query.page - 1) * query.pageSize,
      take: query.pageSize,
    });
  }
}
```

#### 驳回/退回操作设计

**操作类型定义**：
| 操作类型 | 定义 | 使用场景 | 目标节点 |
|---------|------|---------|---------|
| **退回 (Rollback)** | 将流程退回到指定的历史节点 | 审批不通过，需要重新审批 | 任意已执行过的节点 |
| **驳回 (Reject)** | 将流程直接驳回到流程发起人 | 申请不符合要求，需要重新填写 | 流程发起节点 |
| **拒绝 (Deny)** | 直接终止流程实例 | 申请被完全拒绝 | 流程结束（终止状态） |

**退回策略类型**：
| 策略类型 | 描述 | 使用场景 |
|---------|------|---------|
| **TO_PREVIOUS** | 退回到上一节点 | 简单的审批不通过场景 |
| **TO_STARTER** | 驳回到发起人 | 需要重新填写申请 |
| **TO_SPECIFIC** | 退回到指定节点 | 固定退回点 |
| **TO_ANY_HISTORY** | 可退回到任意历史节点 | 灵活的退回需求 |
| **NOT_ALLOWED** | 不允许退回 | 关键节点不允许退回 |

**驳回服务设计**：
```typescript
// task-reject.service.ts
@Injectable()
export class TaskRejectService {
  // 驳回任务
  async rejectTask(dto: RejectTaskDto): Promise<Task> {
    const { taskId, userId, rejectType, targetActivityId, reason } = dto;
    
    // 1. 获取当前任务和配置
    const currentTask = await this.taskRepository.findOne({ where: { id: taskId } });
    const rejectConfig = await this.getRejectConfig(currentTask);
    
    // 2. 确定驳回目标
    const target = await this.determineRejectTarget(dto, rejectConfig, currentTask);
    
    // 3. 根据类型执行驳回
    switch (rejectType) {
      case RejectType.ROLLBACK:
        return this.executeRollback(currentTask, target, dto);
      case RejectType.REJECT:
        return this.executeReject(currentTask, dto);
      case RejectType.DENY:
        await this.executeDeny(currentTask, dto);
        return null;
    }
  }
}
```

#### 抄送操作设计

**抄送概念**：在流程流转过程中，将流程信息同步发送给非流程参与者，抄送对象无需对流程进行审批，仅作信息通知。

**抄送类型**：
| 类型 | 描述 | 触发方式 |
|------|------|---------|
| **MANUAL** | 手动抄送 | 用户主动发起 |
| **AUTO_TASK** | 任务节点自动抄送 | 任务创建/完成时 |
| **AUTO_PROCESS** | 流程启动自动抄送 | 流程启动时 |

**抄送服务设计**：
```typescript
// cc.service.ts
@Injectable()
export class CcService {
  // 创建抄送记录
  async createCc(dto: CreateCcDto): Promise<CcRecord[]> {
    const { processInstanceId, taskId, ccType, ccTarget, senderId, message } = dto;
    
    // 解析抄送目标为用户列表
    const userIds = await this.resolveCcTargets(ccType, ccTarget);
    
    // 为每个用户创建抄送记录
    const ccRecords: CcRecord[] = [];
    for (const userId of userIds) {
      const record = this.ccRecordRepository.create({
        processInstanceId,
        taskId,
        ccUserId: userId,
        ccType,
        ccSource: CcSource.MANUAL,
        senderId,
        message,
        status: CcStatus.UNREAD,
      });
      ccRecords.push(await this.ccRecordRepository.save(record));
    }
    
    return ccRecords;
  }
  
  // 处理自动抄送
  async processAutoCc(processInstanceId: string, triggerEvent: CcTriggerEvent): Promise<void> {
    const configs = await this.ccConfigRepository.find({
      where: { triggerEvent, isActive: true },
    });
    
    for (const config of configs) {
      await this.createCc({
        processInstanceId,
        ccType: config.ccType,
        ccTarget: JSON.parse(config.ccTarget),
        senderId: 'SYSTEM',
        ccSource: CcSource.AUTO_TASK,
      });
    }
  }
}
```

#### 多人任务退回策略设计

**多人任务类型**：
| 任务类型 | 描述 | 完成条件 |
|---------|------|---------|
| **单人任务** | 只有一个处理人 | 一人完成即流转 |
| **会签任务 (Parallel)** | 多人并行处理 | 按比例或全部完成 |
| **或签任务 (Sequential)** | 多人顺序处理 | 一人完成即流转 |

**多人退回策略**：
| 策略类型 | 描述 | 使用场景 |
|---------|------|---------|
| **ALL_BACK** | 所有人任务都退回 | 需要所有人重新审批 |
| **ONLY_CURRENT** | 仅退回当前操作人的任务 | 只影响当前操作人 |
| **MAJORITY_BACK** | 多数人退回则全部退回 | 民主决策场景 |
| **KEEP_COMPLETED** | 保留已完成状态 | 已审批的不需要重新审批 |
| **RESET_ALL** | 重置所有任务 | 需要所有人重新审批 |
| **WAIT_COMPLETION** | 等待其他人完成后再退回 | 需要收集所有人意见 |
| **IMMEDIATE** | 立即退回，取消其他人的任务 | 紧急情况 |

**多人退回服务设计**：
```typescript
// multi-instance-reject.service.ts
@Injectable()
export class MultiInstanceRejectService {
  async rejectMultiInstanceTask(dto: MultiInstanceRejectDto): Promise<void> {
    const { taskId, userId, targetActivityId, reason } = dto;
    
    // 1. 获取多人任务配置
    const miConfig = await this.getMiConfig(taskId);
    
    if (!miConfig || !miConfig.isMultiInstance) {
      // 非多人任务，走普通退回逻辑
      return this.taskRejectService.rejectTask(dto);
    }
    
    // 2. 获取同一节点的所有任务
    const siblingTasks = await this.getSiblingTasks(taskId);
    
    // 3. 根据策略执行退回
    switch (miConfig.rejectStrategy) {
      case MultiInstanceRejectStrategy.ALL_BACK:
        await this.executeAllBack(siblingTasks, dto);
        break;
      case MultiInstanceRejectStrategy.ONLY_CURRENT:
        await this.executeOnlyCurrent(taskId, siblingTasks, dto);
        break;
      case MultiInstanceRejectStrategy.MAJORITY_BACK:
        await this.executeMajorityBack(taskId, siblingTasks, dto);
        break;
      // ... 其他策略
    }
  }
}
```

---

### 1.4 历史数据管理

#### 功能描述
- **历史流程实例**：记录已完成的流程实例
- **历史任务**：记录已完成任务
- **历史变量**：记录流程变量变更历史
- **历史操作日志**：记录流程操作日志
- **历史数据查询**：按条件查询历史数据
- **历史数据清理**：定期清理过期历史数据

#### Flowable 源码分析

**核心类**：
- `HistoryService`：历史数据服务接口
- `HistoricProcessInstance`：历史流程实例
- `HistoricTaskInstance`：历史任务
- `HistoricVariableInstance`：历史变量

**关键方法**：
```java
// 历史流程实例查询
HistoricProcessInstanceQuery createHistoricProcessInstanceQuery();

// 历史任务查询
HistoricTaskInstanceQuery createHistoricTaskInstanceQuery();

// 历史变量查询
HistoricVariableInstanceQuery createHistoricVariableInstanceQuery();

// 历史数据清理
void cleanUpHistoryAsync(boolean cleanProcessInstances, boolean cleanTasks);
```

#### Node.js + NestJS 实现思路

**核心服务设计**：
```typescript
// history.service.ts
@Injectable()
export class HistoryService {
  constructor(
    private readonly historicProcessInstanceRepository: HistoricProcessInstanceRepository,
    private readonly historicTaskRepository: HistoricTaskRepository,
    private readonly historicVariableRepository: HistoricVariableRepository,
    private readonly eventBus: EventBusService,
  ) {
    // 监听流程事件，自动记录历史数据
    this.setupEventListeners();
  }

  private setupEventListeners(): void {
    // 监听流程启动事件
    this.eventBus.on('process.started', async (event) => {
      await this.recordProcessStart(event);
    });

    // 监听流程完成事件
    this.eventBus.on('process.completed', async (event) => {
      await this.recordProcessComplete(event);
    });

    // 监听任务创建事件
    this.eventBus.on('task.created', async (event) => {
      await this.recordTaskCreate(event);
    });

    // 监听任务完成事件
    this.eventBus.on('task.completed', async (event) => {
      await this.recordTaskComplete(event);
    });
  }

  // 记录流程启动
  private async recordProcessStart(event: ProcessStartedEvent): Promise<void> {
    const historic = this.historicProcessInstanceRepository.create({
      processInstanceId: event.processInstanceId,
      processDefinitionId: event.processDefinitionId,
      businessKey: event.businessKey,
      startTime: new Date(),
      status: ProcessInstanceStatus.RUNNING,
    });
    
    await this.historicProcessInstanceRepository.save(historic);
  }

  // 记录流程完成
  private async recordProcessComplete(event: ProcessCompletedEvent): Promise<void> {
    const historic = await this.historicProcessInstanceRepository.findOne({
      where: { processInstanceId: event.processInstanceId }
    });
    
    if (historic) {
      historic.status = ProcessInstanceStatus.COMPLETED;
      historic.endTime = new Date();
      historic.duration = Date.now() - historic.startTime.getTime();
      
      await this.historicProcessInstanceRepository.save(historic);
    }
  }

  // 记录任务创建
  private async recordTaskCreate(event: TaskCreatedEvent): Promise<void> {
    const historic = this.historicTaskRepository.create({
      taskId: event.taskId,
      processInstanceId: event.processInstanceId,
      startTime: new Date(),
      status: TaskStatus.CREATED,
    });
    
    await this.historicTaskRepository.save(historic);
  }

  // 记录任务完成
  private async recordTaskComplete(event: TaskCompletedEvent): Promise<void> {
    const historic = await this.historicTaskRepository.findOne({
      where: { taskId: event.taskId }
    });
    
    if (historic) {
      historic.status = TaskStatus.COMPLETED;
      historic.endTime = new Date();
      historic.completeBy = event.userId;
      historic.duration = Date.now() - historic.startTime.getTime();
      historic.variables = event.variables;
      
      await this.historicTaskRepository.save(historic);
    }
  }

  // 查询历史流程实例
  async findHistoricProcessInstances(query: HistoricProcessInstanceQueryDto): Promise<HistoricProcessInstance[]> {
    const queryBuilder = this.historicProcessInstanceRepository.createQueryBuilder('hpi');
    
    if (query.processDefinitionId) {
      queryBuilder.andWhere('hpi.processDefinitionId = :processDefinitionId', { 
        processDefinitionId: query.processDefinitionId 
      });
    }
    
    if (query.businessKey) {
      queryBuilder.andWhere('hpi.businessKey = :businessKey', { 
        businessKey: query.businessKey 
      });
    }
    
    if (query.status) {
      queryBuilder.andWhere('hpi.status = :status', { status: query.status });
    }
    
    if (query.startTime) {
      queryBuilder.andWhere('hpi.startTime >= :startTime', { 
        startTime: query.startTime 
      });
    }
    
    if (query.endTime) {
      queryBuilder.andWhere('hpi.endTime <= :endTime', { 
        endTime: query.endTime 
      });
    }
    
    // 分页
    queryBuilder.skip((query.page - 1) * query.pageSize);
    queryBuilder.take(query.pageSize);
    
    // 排序
    queryBuilder.orderBy('hpi.startTime', 'DESC');
    
    return queryBuilder.getMany();
  }

  // 查询历史任务
  async findHistoricTasks(query: HistoricTaskQueryDto): Promise<HistoricTask[]> {
    const queryBuilder = this.historicTaskRepository.createQueryBuilder('ht');
    
    if (query.processInstanceId) {
      queryBuilder.andWhere('ht.processInstanceId = :processInstanceId', { 
        processInstanceId: query.processInstanceId 
      });
    }
    
    if (query.assignee) {
      queryBuilder.andWhere('ht.assignee = :assignee', { assignee: query.assignee });
    }
    
    if (query.completeBy) {
      queryBuilder.andWhere('ht.completeBy = :completeBy', { 
        completeBy: query.completeBy 
      });
    }
    
    // 分页
    queryBuilder.skip((query.page - 1) * query.pageSize);
    queryBuilder.take(query.pageSize);
    
    // 排序
    queryBuilder.orderBy('ht.startTime', 'DESC');
    
    return queryBuilder.getMany();
  }

  // 清理历史数据
  async cleanUpHistory(config: HistoryCleanupConfig): Promise<void> {
    const endTime = new Date();
    endTime.setDate(endTime.getDate() - config.daysToKeep);
    
    // 清理历史流程实例
    if (config.cleanProcessInstances) {
      await this.historicProcessInstanceRepository
        .createQueryBuilder()
        .delete()
        .where('endTime < :endTime', { endTime })
        .execute();
    }
    
    // 清理历史任务
    if (config.cleanTasks) {
      await this.historicTaskRepository
        .createQueryBuilder()
        .delete()
        .where('endTime < :endTime', { endTime })
        .execute();
    }
    
    // 清理历史变量
    if (config.cleanVariables) {
      await this.historicVariableRepository
        .createQueryBuilder()
        .delete()
        .where('createTime < :endTime', { endTime })
        .execute();
    }
  }
}
```

---

### 1.5 身份管理

#### 功能描述
- **用户管理**：用户 CRUD 操作
- **角色管理**：角色 CRUD 操作
- **组管理**：组 CRUD 操作
- **用户-角色关联**：用户角色管理
- **用户-组关联**：用户组管理
- **权限管理**：权限定义和授权

#### Flowable 源码分析

**核心类**：
- `IdentityService`：身份管理服务接口
- `User`：用户实体
- `Group`：组实体
- `IdentityLink`：身份链接

**关键方法**：
```java
// 用户管理
User newUser(String userId);
void saveUser(User user);
User createUser();
User findUserById(String userId);
List<User> findUsersByGroup(String groupId);

// 组管理
Group newGroup(String groupId);
void saveGroup(Group group);
Group createGroup();
Group findGroupById(String groupId);
```

#### Node.js + NestJS 实现思路

**核心服务设计**：
```typescript
// identity.service.ts
@Injectable()
export class IdentityService {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly roleRepository: RoleRepository,
    private readonly groupRepository: GroupRepository,
    private readonly userRepository: UserRepository,
  ) {}

  // 用户管理
  async createUser(dto: CreateUserDto): Promise<User> {
    const user = this.userRepository.create({
      id: generateUuid(),
      username: dto.username,
      password: await this.hashPassword(dto.password),
      realName: dto.realName,
      email: dto.email,
      isActive: true,
      createTime: new Date(),
    });
    
    return this.userRepository.save(user);
  }

  async findUserById(id: string): Promise<User> {
    return this.userRepository.findOne({ where: { id } });
  }

  async findUserByUsername(username: string): Promise<User> {
    return this.userRepository.findOne({ where: { username } });
  }

  async updateUser(id: string, dto: UpdateUserDto): Promise<User> {
    const user = await this.findUserById(id);
    
    if (!user) {
      throw new NotFoundException('用户不存在');
    }
    
    if (dto.password) {
      dto.password = await this.hashPassword(dto.password);
    }
    
    Object.assign(user, dto);
    
    return this.userRepository.save(user);
  }

  async deleteUser(id: string): Promise<void> {
    await this.userRepository.delete(id);
  }

  // 角色管理
  async createRole(dto: CreateRoleDto): Promise<Role> {
    const role = this.roleRepository.create({
      id: generateUuid(),
      name: dto.name,
      description: dto.description,
      createTime: new Date(),
    });
    
    return this.roleRepository.save(role);
  }

  async assignRoleToUser(userId: string, roleId: string): Promise<void> {
    const user = await this.findUserById(userId);
    const role = await this.roleRepository.findOne({ where: { id: roleId } });
    
    if (!user || !role) {
      throw new NotFoundException('用户或角色不存在');
    }
    
    user.roles = user.roles || [];
    if (!user.roles.find(r => r.id === roleId)) {
      user.roles.push(role);
      await this.userRepository.save(user);
    }
  }

  async removeRoleFromUser(userId: string, roleId: string): Promise<void> {
    const user = await this.findUserById(userId);
    
    if (!user) {
      throw new NotFoundException('用户不存在');
    }
    
    user.roles = user.roles?.filter(r => r.id !== roleId) || [];
    await this.userRepository.save(user);
  }

  // 组管理
  async createGroup(dto: CreateGroupDto): Promise<Group> {
    const group = this.groupRepository.create({
      id: generateUuid(),
      name: dto.name,
      description: dto.description,
      createTime: new Date(),
    });
    
    return this.groupRepository.save(group);
  }

  async addUserToGroup(userId: string, groupId: string): Promise<void> {
    const user = await this.findUserById(userId);
    const group = await this.groupRepository.findOne({ where: { id: groupId } });
    
    if (!user || !group) {
      throw new NotFoundException('用户或组不存在');
    }
    
    user.groups = user.groups || [];
    if (!user.groups.find(g => g.id === groupId)) {
      user.groups.push(group);
      await this.userRepository.save(user);
    }
  }

  async removeUserFromGroup(userId: string, groupId: string): Promise<void> {
    const user = await this.findUserById(userId);
    
    if (!user) {
      throw new NotFoundException('用户不存在');
    }
    
    user.groups = user.groups?.filter(g => g.id !== groupId) || [];
    await this.userRepository.save(user);
  }

  // 查询用户所属的组 ID
  async getUserGroupIds(userId: string): Promise<string[]> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['groups'],
    });
    
    return user?.groups?.map(g => g.id) || [];
  }

  // 查询用户拥有的角色
  async getUserRoles(userId: string): Promise<Role[]> {
    const user = await this.userRepository.findOne({
      where: { id: userId },
      relations: ['roles'],
    });
    
    return user?.roles || [];
  }

  // 密码加密
  private async hashPassword(password: string): Promise<string> {
    const salt = await bcrypt.genSalt(10);
    return bcrypt.hash(password, salt);
  }

  // 密码验证
  async verifyPassword(password: string, hash: string): Promise<boolean> {
    return bcrypt.compare(password, hash);
  }
}
```

---

### 1.6 表单管理

#### 功能描述
- **表单定义**：定义流程节点关联的表单
- **表单数据存储**：存储表单提交的数据
- **表单数据查询**：查询流程实例的表单数据
- **表单验证**：验证表单数据的合法性

#### Node.js + NestJS 实现思路

**核心服务设计**：
```typescript
// form.service.ts
@Injectable()
export class FormService {
  constructor(
    private readonly formRepository: FormRepository,
    private readonly formDataRepository: FormDataRepository,
  ) {}

  // 创建表单定义
  async createForm(dto: CreateFormDto): Promise<Form> {
    const form = this.formRepository.create({
      id: generateUuid(),
      name: dto.name,
      schema: dto.schema, // JSON Schema
      isActive: true,
      createTime: new Date(),
    });
    
    return this.formRepository.save(form);
  }

  // 提交表单数据
  async submitFormData(dto: SubmitFormDataDto): Promise<FormData> {
    // 1. 获取表单定义
    const form = await this.formRepository.findOne({ where: { id: dto.formId } });
    
    if (!form) {
      throw new NotFoundException('表单不存在');
    }
    
    // 2. 验证表单数据
    this.validateFormData(form.schema, dto.data);
    
    // 3. 保存表单数据
    const formData = this.formDataRepository.create({
      id: generateUuid(),
      formId: dto.formId,
      processInstanceId: dto.processInstanceId,
      taskId: dto.taskId,
      data: dto.data,
      submitTime: new Date(),
      submitBy: dto.userId,
    });
    
    return this.formDataRepository.save(formData);
  }

  // 查询表单数据
  async findFormData(processInstanceId: string): Promise<FormData[]> {
    return this.formDataRepository.find({
      where: { processInstanceId },
      order: { submitTime: 'ASC' },
    });
  }

  // 验证表单数据
  private validateFormData(schema: any, data: any): void {
    const ajv = new Ajv();
    const validate = ajv.compile(schema);
    const valid = validate(data);
    
    if (!valid) {
      throw new BusinessException('表单数据验证失败: ' + JSON.stringify(validate.errors));
    }
  }
}
```

---

### 1.7 监听器和事件处理机制

#### 功能描述
- **事件发布**：流程引擎发布各种事件
- **事件监听**：监听流程引擎事件
- **任务监听器**：监听任务生命周期事件
- **执行监听器**：监听执行生命周期事件
- **自定义监听器**：支持自定义监听器实现

#### Flowable 源码分析

**核心类**：
- `FlowableEventListener`：事件监听器接口
- `TaskListener`：任务监听器接口
- `ExecutionListener`：执行监听器接口
- `EventDispatcher`：事件分发器

**事件类型**：
```java
ENTITY_CREATED, ENTITY_INITIALIZED, ENTITY_UPDATED, ENTITY_DELETED,
TASK_CREATED, TASK_ASSIGNED, TASK_COMPLETED,
PROCESS_STARTED, PROCESS_COMPLETED, PROCESS_CANCELLED,
...
```

#### Node.js + NestJS 实现思路

**事件总线服务**：
```typescript
// event-bus.service.ts
@Injectable()
export class EventBusService {
  private eventEmitter: EventEmitter;

  constructor() {
    this.eventEmitter = new EventEmitter();
  }

  // 发布事件
  emit(eventType: string, data: any): void {
    this.eventEmitter.emit(eventType, data);
  }

  // 监听事件
  on(eventType: string, listener: (data: any) => void): void {
    this.eventEmitter.on(eventType, listener);
  }

  // 移除监听器
  off(eventType: string, listener: (data: any) => void): void {
    this.eventEmitter.off(eventType, listener);
  }
}
```

**监听器装饰器**：
```typescript
// event-listener.decorator.ts
export const EventListener = (eventType: string) => {
  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
    const originalMethod = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const result = await originalMethod.apply(this, args);
      return result;
    };
    
    // 标记为事件监听器
    Reflect.defineMetadata('eventListener', {
      eventType,
      method: propertyKey,
    }, target);
  };
};
```

**监听器管理器**：
```typescript
// listener-manager.service.ts
@Injectable()
export class ListenerManagerService {
  constructor(
    private readonly eventBus: EventBusService,
    private readonly moduleRef: ModuleRef,
  ) {}

  onModuleInit(): void {
    this.registerListeners();
  }

  private registerListeners(): void {
    // 扫描所有服务，查找带有 @EventListener 装饰器的方法
    const providers = this.moduleRef.get<any[]>({ strict: false });
    
    for (const provider of providers) {
      const prototype = Object.getPrototypeOf(provider);
      const methodNames = Object.getOwnPropertyNames(prototype);
      
      for (const methodName of methodNames) {
        const metadata = Reflect.getMetadata('eventListener', prototype[methodName]);
        
        if (metadata) {
          this.eventBus.on(metadata.eventType, provider[methodName].bind(provider));
        }
      }
    }
  }
}
```

---

### 1.8 网关控制逻辑

#### 功能描述
- **排他网关（Exclusive Gateway）**：根据条件选择唯一的分支
- **并行网关（Parallel Gateway）**：同时执行多个分支
- **包容网关（Inclusive Gateway）**：根据条件选择一个或多个分支
- **事件网关（Event Gateway）**：基于事件触发分支

#### Node.js + NestJS 实现思路

**网关执行器**：
```typescript
// gateway-executor.service.ts
@Injectable()
export class GatewayExecutorService {
  constructor(
    private readonly expressionEvaluator: ExpressionEvaluatorService,
  ) {}

  // 执行排他网关
  async executeExclusiveGateway(execution: Execution, gateway: BpmnGateway): Promise<void> {
    const variables = await this.getVariables(execution.processInstanceId);
    const outgoingFlows = gateway.outgoing || [];
    
    // 评估所有出线
    for (const flow of outgoingFlows) {
      if (this.evaluateCondition(flow.conditionExpression, variables)) {
        await this.executeSequenceFlow(execution, flow);
        return;
      }
    }
    
    // 如果没有匹配的条件，使用默认流
    const defaultFlow = outgoingFlows.find(f => !f.conditionExpression);
    if (defaultFlow) {
      await this.executeSequenceFlow(execution, defaultFlow);
    } else {
      throw new BusinessException('排他网关没有匹配的出线');
    }
  }

  // 执行并行网关
  async executeParallelGateway(execution: Execution, gateway: BpmnGateway): Promise<void> {
    const outgoingFlows = gateway.outgoing || [];
    
    // 为每条出线创建并发执行
    const executions = await Promise.all(
      outgoingFlows.map(flow => 
        this.executionService.create({
          processInstanceId: execution.processInstanceId,
          parentId: execution.id,
          activityId: flow.targetRef,
          isActive: true,
        })
      )
    );
    
    // 更新原执行实例
    await this.executionService.update(execution.id, { isActive: false });
    
    // 执行所有并发执行
    await Promise.all(
      executions.map(ex => this.executeNextActivities(ex))
    );
  }

  // 执行包容网关
  async executeInclusiveGateway(execution: Execution, gateway: BpmnGateway): Promise<void> {
    const variables = await this.getVariables(execution.processInstanceId);
    const outgoingFlows = gateway.outgoing || [];
    
    // 评估所有出线，选择满足条件的
    const selectedFlows = outgoingFlows.filter(flow => 
      this.evaluateCondition(flow.conditionExpression, variables)
    );
    
    if (selectedFlows.length === 0) {
      throw new BusinessException('包容网关没有匹配的出线');
    }
    
    // 执行所有选中的流
    await Promise.all(
      selectedFlows.map(flow => this.executeSequenceFlow(execution, flow))
    );
  }

  // 评估条件表达式
  private evaluateCondition(expression: string, variables: Record<string, any>): boolean {
    if (!expression) {
      return true;
    }
    
    return this.expressionEvaluator.evaluate(expression, variables);
  }
}
```

---

### 1.9 子流程和调用活动

#### 功能描述
- **内嵌子流程**：在主流程中定义子流程
- **调用活动（Call Activity）**：调用外部流程定义
- **子流程变量传递**：主流程和子流程之间的变量传递

#### Node.js + NestJS 实现思路

**子流程执行器**：
```typescript
// sub-process-executor.service.ts
@Injectable()
export class SubProcessExecutorService {
  constructor(
    private readonly processInstanceService: ProcessInstanceService,
    private readonly processDefinitionService: ProcessDefinitionService,
  ) {}

  // 执行调用活动
  async executeCallActivity(execution: Execution, callActivity: BpmnCallActivity): Promise<void> {
    // 1. 获取被调用的流程定义
    const calledProcessDefinition = await this.processDefinitionService.findByKey(
      callActivity.calledElement
    );
    
    if (!calledProcessDefinition) {
      throw new BusinessException('被调用的流程定义不存在');
    }
    
    // 2. 准备子流程变量
    const variables = await this.prepareVariables(execution, callActivity);
    
    // 3. 启动子流程实例
    const subProcessInstance = await this.processInstanceService.start({
      processDefinitionId: calledProcessDefinition.id,
      businessKey: `${execution.processInstanceId}_sub`,
      variables,
      superProcessInstanceId: execution.processInstanceId,
      callActivityId: callActivity.id,
    });
    
    // 4. 更新执行实例
    await this.executionService.update(execution.id, {
      subProcessInstanceId: subProcessInstance.id,
      isActive: false,
    });
  }

  // 准备子流程变量
  private async prepareVariables(
    execution: Execution,
    callActivity: BpmnCallActivity
  ): Promise<Record<string, any>> {
    const variables = await this.getVariables(execution.processInstanceId);
    const result: Record<string, any> = {};
    
    // 处理输入参数映射
    if (callActivity.in) {
      for (const mapping of callActivity.in) {
        result[mapping.target] = this.evaluateExpression(mapping.source, variables);
      }
    } else {
      // 没有映射时，传递所有变量
      Object.assign(result, variables);
    }
    
    return result;
  }

  // 子流程完成后，处理输出参数
  async handleSubProcessCompletion(subProcessInstanceId: string): Promise<void> {
    const subProcessInstance = await this.processInstanceService.findById(subProcessInstanceId);
    const execution = await this.executionService.findBySubProcessInstanceId(subProcessInstanceId);
    
    if (!execution) {
      return;
    }
    
    // 获取调用活动定义
    const callActivity = await this.getCallActivityDefinition(
      execution.processDefinitionId,
      execution.activityId
    );
    
    // 处理输出参数映射
    if (callActivity.out) {
      const subVariables = await this.getVariables(subProcessInstanceId);
      const parentVariables: Record<string, any> = {};
      
      for (const mapping of callActivity.out) {
        parentVariables[mapping.target] = this.evaluateExpression(
          mapping.source,
          subVariables
        );
      }
      
      // 更新父流程变量
      await this.setVariables(execution.processInstanceId, parentVariables);
    }
    
    // 继续执行父流程
    await this.executionService.update(execution.id, {
      subProcessInstanceId: null,
      isActive: true,
    });
    
    await this.executeNextActivities(execution);
  }
}
```

---

### 1.10 定时器事件和异步执行

#### 功能描述
- **定时器启动事件**：定时启动流程实例
- **边界定时器事件**：定时触发边界事件
- **中间定时器事件**：在流程中定时触发事件
- **异步任务**：异步执行服务任务
- **异步历史**：异步记录历史数据

#### Node.js + NestJS 实现思路

**定时器服务**：
```typescript
// timer.service.ts
@Injectable()
export class TimerService implements OnModuleInit {
  private scheduler: Scheduler;

  constructor(
    private readonly processInstanceService: ProcessInstanceService,
    private readonly eventBus: EventBusService,
  ) {}

  onModuleInit(): void {
    this.scheduler = schedule.scheduleJob('*/5 * * * * *', async () => {
      await this.checkAndExecuteTimers();
    });
  }

  // 检查并执行定时器
  private async checkAndExecuteTimers(): Promise<void> {
    // 1. 查询所有待执行的定时器
    const timers = await this.findDueTimers();
    
    // 2. 执行每个定时器
    for (const timer of timers) {
      await this.executeTimer(timer);
    }
  }

  // 查询到期的定时器
  private async findDueTimers(): Promise<Timer[]> {
    const now = new Date();
    
    return this.timerRepository.find({
      where: {
        dueDate: LessThanOrEqual(now),
        retries: LessThan(3),
        status: TimerStatus.ACTIVE,
      },
    });
  }

  // 执行定时器
  private async executeTimer(timer: Timer): Promise<void> {
    try {
      switch (timer.type) {
        case TimerType.START_EVENT:
          await this.executeStartEventTimer(timer);
          break;
        case TimerType.BOUNDARY_EVENT:
          await this.executeBoundaryEventTimer(timer);
          break;
        case TimerType.INTERMEDIATE_EVENT:
          await this.executeIntermediateEventTimer(timer);
          break;
        default:
          throw new BusinessException(`不支持的定时器类型: ${timer.type}`);
      }
      
      // 标记定时器为已完成
      await this.timerRepository.update(timer.id, {
        status: TimerStatus.COMPLETED,
        executeTime: new Date(),
      });
    } catch (error) {
      // 标记定时器为失败，增加重试次数
      await this.timerRepository.update(timer.id, {
        retries: timer.retries + 1,
        status: TimerStatus.FAILED,
      });
    }
  }

  // 执行启动事件定时器
  private async executeStartEventTimer(timer: Timer): Promise<void> {
    await this.processInstanceService.start({
      processDefinitionId: timer.processDefinitionId,
      businessKey: `timer_${timer.id}`,
      variables: timer.variables,
    });
  }

  // 执行边界事件定时器
  private async executeBoundaryEventTimer(timer: Timer): Promise<void> {
    // 1. 中断当前任务
    await this.taskService.interrupt(timer.taskId);
    
    // 2. 执行边界事件
    await this.eventBus.emit('boundary.timer.triggered', {
      taskId: timer.taskId,
      executionId: timer.executionId,
    });
    
    // 3. 继续流程执行
    await this.continueProcess(timer.executionId);
  }

  // 执行中间定时器事件
  private async executeIntermediateEventTimer(timer: Timer): Promise<void> {
    await this.eventBus.emit('intermediate.timer.triggered', {
      executionId: timer.executionId,
    });
    
    await this.continueProcess(timer.executionId);
  }
}
```

**异步执行器**：
```typescript
// async-executor.service.ts
@Injectable()
export class AsyncExecutorService implements OnModuleInit {
  private jobQueue: Queue;

  constructor(
    private readonly configService: ConfigService,
  ) {
    // 使用 Bull 队列处理异步任务
    this.jobQueue = new Queue('async-jobs', {
      redis: this.configService.get('REDIS_URL'),
    });
  }

  onModuleInit(): void {
    // 处理队列中的任务
    this.jobQueue.process(async (job) => {
      await this.executeAsyncJob(job.data);
    });
  }

  // 添加异步任务
  async addAsyncJob(job: AsyncJob): Promise<void> {
    await this.jobQueue.add(job, {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000,
      },
    });
  }

  // 执行异步任务
  private async executeAsyncJob(job: AsyncJob): Promise<void> {
    switch (job.type) {
      case AsyncJobType.SERVICE_TASK:
        await this.executeServiceTask(job);
        break;
      case AsyncJobType.HISTORY:
        await this.recordHistory(job);
        break;
      default:
        throw new BusinessException(`不支持的异步任务类型: ${job.type}`);
    }
  }

  // 执行服务任务
  private async executeServiceTask(job: AsyncJob): Promise<void> {
    const { serviceTaskId, processInstanceId, variables } = job;
    
    // 执行服务任务逻辑
    await this.serviceTaskExecutor.execute(serviceTaskId, variables);
    
    // 继续流程
    await this.continueProcess(processInstanceId, variables);
  }

  // 记录历史数据
  private async recordHistory(job: AsyncJob): Promise<void> {
    const { historyData } = job;
    await this.historyService.record(historyData);
  }
}
```

---

## 二、Flowable 核心组件分析

### 2.1 ProcessEngine（流程引擎）

**职责**：
- 作为流程引擎的入口点，提供所有服务的访问
- 管理引擎的生命周期（初始化、启动、关闭）
- 协调各服务之间的交互

**核心服务**：
- `RepositoryService`：流程定义管理
- `RuntimeService`：流程实例运行时管理
- `TaskService`：任务管理
- `HistoryService`：历史数据管理
- `IdentityService`：身份管理
- `ManagementService`：管理操作
- `FormService`：表单管理
- `DynamicBpmnService`：动态 BPMN 管理

**NestJS 对应实现**：
```typescript
// process-engine.service.ts
@Injectable()
export class ProcessEngineService {
  constructor(
    public readonly repositoryService: RepositoryService,
    public readonly runtimeService: RuntimeService,
    public readonly taskService: TaskService,
    public readonly historyService: HistoryService,
    public readonly identityService: IdentityService,
    public readonly managementService: ManagementService,
    public readonly formService: FormService,
    public readonly dynamicBpmnService: DynamicBpmnService,
  ) {}

  async onModuleInit(): Promise<void> {
    // 初始化引擎
    await this.initialize();
  }

  async onModuleDestroy(): Promise<void> {
    // 关闭引擎
    await this.shutdown();
  }

  private async initialize(): Promise<void> {
    // 1. 初始化数据库连接
    // 2. 创建必要的表结构
    // 3. 启动异步执行器
    // 4. 启动定时器
    // 5. 注册事件监听器
  }

  private async shutdown(): Promise<void> {
    // 1. 停止异步执行器
    // 2. 停止定时器
    // 3. 关闭数据库连接
  }
}
```

---

### 2.2 RepositoryService（流程定义仓库服务）

**职责**：
- 管理流程定义的部署
- 提供流程定义的查询接口
- 管理流程定义的生命周期（激活、暂停、删除）
- 管理流程定义的候选启动人

**NestJS 对应实现**：见 1.1 节

---

### 2.3 RuntimeService（运行时服务）

**职责**：
- 启动流程实例
- 管理流程实例的生命周期
- 管理流程变量
- 触发流程事件（信号、消息）
- 管理执行实例

**NestJS 对应实现**：见 1.2 节

---

### 2.4 TaskService（任务服务）

**职责**：
- 创建任务
- 分配任务
- 认领任务
- 完成任务
- 管理任务生命周期

**NestJS 对应实现**：见 1.3 节

---

### 2.5 HistoryService（历史服务）

**职责**：
- 记录流程实例历史
- 记录任务历史
- 记录变量历史
- 提供历史数据查询接口
- 清理过期历史数据

**NestJS 对应实现**：见 1.4 节

---

### 2.6 IdentityService（身份服务）

**职责**：
- 管理用户
- 管理组
- 管理角色
- 管理用户-组关联
- 管理用户-角色关联

**NestJS 对应实现**：见 1.5 节

---

### 2.7 ManagementService（管理服务）

**职责**：
- 执行管理操作
- 查询引擎配置
- 管理作业
- 清理历史数据

**NestJS 对应实现**：
```typescript
// management.service.ts
@Injectable()
export class ManagementService {
  constructor(
    private readonly jobService: JobService,
    private readonly historyService: HistoryService,
  ) {}

  // 获取引擎配置
  async getEngineConfig(): Promise<EngineConfig> {
    return {
      version: process.env.APP_VERSION,
      databaseType: 'mysql',
      asyncExecutorEnabled: true,
      historyLevel: 'AUDIT',
    };
  }

  // 执行数据库表操作
  async executeDatabaseOperation(operation: DatabaseOperation): Promise<void> {
    switch (operation.type) {
      case 'CREATE_TABLE':
        await this.createTable(operation);
        break;
      case 'DROP_TABLE':
        await this.dropTable(operation);
        break;
      case 'ALTER_TABLE':
        await this.alterTable(operation);
        break;
    }
  }

  // 清理历史数据
  async cleanUpHistory(config: HistoryCleanupConfig): Promise<void> {
    await this.historyService.cleanUpHistory(config);
  }

  // 查询作业
  async findJobs(query: JobQuery): Promise<Job[]> {
    return this.jobService.find(query);
  }

  // 执行作业
  async executeJob(jobId: string): Promise<void> {
    await this.jobService.execute(jobId);
  }
}
```

---

### 1.11 作业服务（Job Service）

#### 功能描述
- **定时器作业**：处理定时器触发事件
- **消息作业**：处理消息订阅事件
- **外部工作者作业**：支持外部系统处理任务
- **作业重试机制**：失败作业自动重试
- **作业异常处理**：记录作业异常堆栈
- **作业暂停/恢复**：控制作业执行状态

#### Flowable 源码分析

**核心接口**：
- [`JobInfo`](modules/flowable-job-service-api/src/main/java/org/flowable/job/api/JobInfo.java) - 作业基础信息接口
- [`Job`](modules/flowable-job-service-api/src/main/java/org/flowable/job/api/Job.java) - 运行时作业接口
- [`TimerJob`](modules/flowable-job-service-api/src/main/java/org/flowable/job/api/TimerJob.java) - 定时器作业接口
- [`SuspendedJob`](modules/flowable-job-service-api/src/main/java/org/flowable/job/api/SuspendedJob.java) - 暂停的作业接口
- [`DeadLetterJob`](modules/flowable-job-service-api/src/main/java/org/flowable/job/api/DeadLetterJob.java) - 死信作业接口

**JobInfo 接口关键属性**：
```java
public interface JobInfo {
    String getId();                     // 作业唯一标识
    String getJobType();                // 作业类型：timer、message、externalWorker
    String getJobHandlerType();         // 作业处理器类型
    String getProcessInstanceId();      // 流程实例ID
    String getProcessDefinitionId();    // 流程定义ID
    String getExecutionId();            // 执行ID
    String getElementId();              // BPMN元素ID
    String getElementName();            // BPMN元素名称
    String getTenantId();               // 租户ID
    int getRetries();                   // 重试次数
    Date getDuedate();                  // 到期时间
    String getExceptionMessage();       // 异常消息
    byte[] getExceptionStacktrace();    // 异常堆栈
}
```

**作业类型**：
| 类型 | 说明 | 触发条件 |
|------|------|----------|
| timer | 定时器作业 | 时间表达式到期 |
| message | 消息作业 | 消息事件触发 |
| externalWorker | 外部工作者作业 | 外部系统领取处理 |

**作业状态流转**：
```
创建 → 活跃(Job) → 执行成功 → 删除
              ↓
          执行失败 → 重试(retries--)
              ↓
          重试耗尽 → 死信(DeadLetterJob)
              ↓
          流程暂停 → 暂停作业(SuspendedJob)
```

#### Node.js + NestJS 实现思路

**作业实体设计**：
```typescript
// job.entity.ts
@Entity('act_ru_job')
export class JobEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 255 })
  job_type_: string;  // timer, message, externalWorker

  @Column({ length: 255 })
  job_handler_type_: string;

  @Column({ length: 64, nullable: true })
  process_inst_id_: string;

  @Column({ length: 64, nullable: true })
  process_def_id_: string;

  @Column({ length: 64, nullable: true })
  execution_id_: string;

  @Column({ length: 255, nullable: true })
  element_id_: string;

  @Column({ length: 255, nullable: true })
  element_name_: string;

  @Column({ type: 'int', default: 3 })
  retries_: number;

  @Column({ type: 'datetime', nullable: true })
  duedate_: Date;

  @Column({ type: 'text', nullable: true })
  exception_msg_: string;

  @Column({ type: 'longtext', nullable: true })
  exception_stack_: string;

  @Column({ type: 'longblob', nullable: true })
  job_handler_cfg_: Buffer;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;

  @Column({ type: 'datetime' })
  create_time_: Date;
}
```

**作业服务设计**：
```typescript
// job.service.ts
@Injectable()
export class JobService {
  constructor(
    @InjectRepository(JobEntity)
    private readonly jobRepository: Repository<JobEntity>,
    private readonly asyncExecutorService: AsyncExecutorService,
    private readonly eventBus: EventBusService,
  ) {}

  // 创建定时器作业
  async createTimerJob(dto: CreateTimerJobDto): Promise<JobEntity> {
    const job = this.jobRepository.create({
      id_: generateUuid(),
      job_type_: JobType.TIMER,
      job_handler_type_: dto.handlerType,
      process_inst_id_: dto.processInstanceId,
      execution_id_: dto.executionId,
      element_id_: dto.elementId,
      duedate_: dto.duedate,
      retries_: 3,
      job_handler_cfg_: Buffer.from(JSON.stringify(dto.config || {})),
      create_time_: new Date(),
    });

    return this.jobRepository.save(job);
  }

  // 创建消息作业
  async createMessageJob(dto: CreateMessageJobDto): Promise<JobEntity> {
    const job = this.jobRepository.create({
      id_: generateUuid(),
      job_type_: JobType.MESSAGE,
      job_handler_type_: 'message-event',
      process_inst_id_: dto.processInstanceId,
      execution_id_: dto.executionId,
      element_id_: dto.elementId,
      retries_: 3,
      job_handler_cfg_: Buffer.from(JSON.stringify({
        messageName: dto.messageName,
        correlationKeys: dto.correlationKeys,
      })),
      create_time_: new Date(),
    });

    return this.jobRepository.save(job);
  }

  // 查询到期作业
  async findDueJobs(limit: number = 100): Promise<JobEntity[]> {
    const now = new Date();
    return this.jobRepository
      .createQueryBuilder('job')
      .where('job.duedate_ <= :now', { now })
      .andWhere('job.retries_ > 0')
      .orderBy('job.duedate_', 'ASC')
      .take(limit)
      .getMany();
  }

  // 执行作业
  async executeJob(jobId: string): Promise<void> {
    const job = await this.jobRepository.findOne({ where: { id_: jobId } });
    if (!job) {
      throw new NotFoundException('作业不存在');
    }

    try {
      // 根据作业类型执行
      switch (job.job_type_) {
        case JobType.TIMER:
          await this.executeTimerJob(job);
          break;
        case JobType.MESSAGE:
          await this.executeMessageJob(job);
          break;
        case JobType.EXTERNAL_WORKER:
          await this.executeExternalWorkerJob(job);
          break;
        default:
          throw new BusinessException(`不支持的作业类型: ${job.job_type_}`);
      }

      // 执行成功，删除作业
      await this.jobRepository.delete(jobId);
      
      this.eventBus.emit('job.completed', { jobId, jobType: job.job_type_ });
    } catch (error) {
      await this.handleJobFailure(job, error);
    }
  }

  // 处理作业失败
  private async handleJobFailure(job: JobEntity, error: Error): Promise<void> {
    const retries = job.retries_ - 1;
    
    if (retries <= 0) {
      // 移动到死信队列
      await this.moveToDeadLetterJob(job, error);
    } else {
      // 更新重试次数和异常信息
      await this.jobRepository.update(job.id_, {
        retries_: retries,
        exception_msg_: error.message,
        exception_stack_: error.stack,
        duedate_: this.calculateBackoffDate(retries),
      });
    }

    this.eventBus.emit('job.failed', {
      jobId: job.id_,
      retries,
      error: error.message
    });
  }

  // 移动到死信队列
  private async moveToDeadLetterJob(job: JobEntity, error: Error): Promise<void> {
    const deadLetterJob = this.deadLetterJobRepository.create({
      id_: generateUuid(),
      job_type_: job.job_type_,
      job_handler_type_: job.job_handler_type_,
      process_inst_id_: job.process_inst_id_,
      execution_id_: job.execution_id_,
      element_id_: job.element_id_,
      exception_msg_: error.message,
      exception_stack_: error.stack,
      job_handler_cfg_: job.job_handler_cfg_,
      create_time_: new Date(),
    });

    await this.deadLetterJobRepository.save(deadLetterJob);
    await this.jobRepository.delete(job.id_);
  }

  // 计算退避时间
  private calculateBackoffDate(retries: number): Date {
    const delay = Math.pow(2, 4 - retries) * 1000; // 指数退避
    return new Date(Date.now() + delay);
  }
}
```

**外部工作者作业处理**：
```typescript
// external-worker.service.ts
@Injectable()
export class ExternalWorkerService {
  constructor(
    private readonly jobService: JobService,
    private readonly jobRepository: Repository<JobEntity>,
  ) {}

  // 领取作业
  async acquireJobs(workerId: string, topic: string, maxTasks: number = 10): Promise<JobEntity[]> {
    const jobs = await this.jobRepository
      .createQueryBuilder('job')
      .where('job.job_type_ = :type', { type: JobType.EXTERNAL_WORKER })
      .andWhere('job.job_handler_type_ = :topic', { topic })
      .andWhere('job.duedate_ <= :now', { now: new Date() })
      .andWhere('job.retries_ > 0')
      .orderBy('job.duedate_', 'ASC')
      .take(maxTasks)
      .getMany();

    // 标记作业已被领取
    for (const job of jobs) {
      await this.jobRepository.update(job.id_, {
        job_handler_cfg_: this.updateJobConfig(job.job_handler_cfg_, { workerId, lockTime: new Date() }),
      });
    }

    return jobs;
  }

  // 完成作业
  async completeJob(jobId: string, variables: Record<string, any>): Promise<void> {
    const job = await this.jobRepository.findOne({ where: { id_: jobId } });
    if (!job) {
      throw new NotFoundException('作业不存在');
    }

    // 设置流程变量
    if (Object.keys(variables).length > 0) {
      await this.variableService.setVariables(job.process_inst_id_, variables);
    }

    // 删除作业并继续流程
    await this.jobRepository.delete(jobId);
    await this.continueProcess(job.execution_id_);
  }

  // 作业失败
  async failJob(jobId: string, errorMessage: string, retries?: number): Promise<void> {
    const job = await this.jobRepository.findOne({ where: { id_: jobId } });
    if (!job) {
      throw new NotFoundException('作业不存在');
    }

    if (retries !== undefined && retries > 0) {
      // 更新重试次数
      await this.jobRepository.update(jobId, {
        retries_: retries,
        exception_msg_: errorMessage,
      });
    } else {
      // 标记为失败
      await this.jobService.handleJobFailure(job, new Error(errorMessage));
    }
  }
}
```

---

### 1.12 身份链接服务（IdentityLink Service）

#### 功能描述
- **任务候选人**：管理任务的候选用户和候选组
- **流程实例参与者**：记录流程实例的参与者
- **历史身份链接**：记录历史身份关联信息
- **身份类型管理**：支持多种身份关联类型

#### Flowable 源码分析

**核心接口**：
- [`IdentityLink`](modules/flowable-identitylink-service-api/src/main/java/org/flowable/identitylink/api/IdentityLink.java) - 身份链接接口
- [`IdentityLinkType`](modules/flowable-identitylink-service-api/src/main/java/org/flowable/identitylink/api/IdentityLinkType.java) - 身份链接类型常量

**IdentityLink 接口**：
```java
public interface IdentityLink {
    String getId();                   // 唯一标识
    String getType();                 // 类型
    String getUserId();               // 用户ID
    String getGroupId();              // 组ID
    String getTaskId();               // 任务ID
    String getProcessInstanceId();    // 流程实例ID
    String getProcessDefinitionId();  // 流程定义ID（用于候选启动者）
}
```

**IdentityLinkType 类型常量**：
```java
public interface IdentityLinkType {
    String ASSIGNEE = "assignee";           // 任务分配人
    String CANDIDATE = "candidate";         // 候选人/候选组
    String OWNER = "owner";                 // 任务所有者
    String STARTER = "starter";             // 流程启动者
    String PARTICIPANT = "participant";     // 流程参与者
    String REACTIVATOR = "reactivator";     // 流程重新激活者
}
```

**身份链接使用场景**：
| 类型 | 适用场景 | 关联实体 |
|------|----------|----------|
| assignee | 任务分配给指定用户 | Task |
| candidate | 任务的候选用户/组 | Task |
| owner | 任务的所有者（委托场景） | Task |
| starter | 流程启动者 | ProcessInstance |
| participant | 流程参与者 | ProcessInstance |
| reactivator | 重新激活流程的用户 | ProcessInstance |

#### Node.js + NestJS 实现思路

**身份链接实体设计**：
```typescript
// identity-link.entity.ts
@Entity('act_ru_identitylink')
export class IdentityLinkEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 64 })
  type_: string;  // assignee, candidate, owner, starter, participant, reactivator

  @Column({ length: 255, nullable: true })
  user_id_: string;

  @Column({ length: 255, nullable: true })
  group_id_: string;

  @Column({ length: 64, nullable: true })
  task_id_: string;

  @Column({ length: 64, nullable: true })
  proc_inst_id_: string;

  @Column({ length: 64, nullable: true })
  proc_def_id_: string;

  @Column({ type: 'datetime', nullable: true })
  create_time_: Date;
}
```

**身份链接类型常量**：
```typescript
// identity-link-type.ts
export class IdentityLinkType {
  static readonly ASSIGNEE = 'assignee';
  static readonly CANDIDATE = 'candidate';
  static readonly OWNER = 'owner';
  static readonly STARTER = 'starter';
  static readonly PARTICIPANT = 'participant';
  static readonly REACTIVATOR = 'reactivator';
}
```

**身份链接服务设计**：
```typescript
// identity-link.service.ts
@Injectable()
export class IdentityLinkService {
  constructor(
    @InjectRepository(IdentityLinkEntity)
    private readonly identityLinkRepository: Repository<IdentityLinkEntity>,
  ) {}

  // 添加任务候选人（用户）
  async addCandidateUser(taskId: string, userId: string): Promise<IdentityLinkEntity> {
    const link = this.identityLinkRepository.create({
      id_: generateUuid(),
      type_: IdentityLinkType.CANDIDATE,
      user_id_: userId,
      task_id_: taskId,
      create_time_: new Date(),
    });
    return this.identityLinkRepository.save(link);
  }

  // 添加任务候选组
  async addCandidateGroup(taskId: string, groupId: string): Promise<IdentityLinkEntity> {
    const link = this.identityLinkRepository.create({
      id_: generateUuid(),
      type_: IdentityLinkType.CANDIDATE,
      group_id_: groupId,
      task_id_: taskId,
      create_time_: new Date(),
    });
    return this.identityLinkRepository.save(link);
  }

  // 设置任务分配人
  async setAssignee(taskId: string, userId: string): Promise<IdentityLinkEntity> {
    // 先删除旧的分配人
    await this.identityLinkRepository.delete({
      task_id_: taskId,
      type_: IdentityLinkType.ASSIGNEE,
    });

    const link = this.identityLinkRepository.create({
      id_: generateUuid(),
      type_: IdentityLinkType.ASSIGNEE,
      user_id_: userId,
      task_id_: taskId,
      create_time_: new Date(),
    });
    return this.identityLinkRepository.save(link);
  }

  // 设置任务所有者
  async setOwner(taskId: string, userId: string): Promise<IdentityLinkEntity> {
    await this.identityLinkRepository.delete({
      task_id_: taskId,
      type_: IdentityLinkType.OWNER,
    });

    const link = this.identityLinkRepository.create({
      id_: generateUuid(),
      type_: IdentityLinkType.OWNER,
      user_id_: userId,
      task_id_: taskId,
      create_time_: new Date(),
    });
    return this.identityLinkRepository.save(link);
  }

  // 添加流程参与者
  async addParticipant(processInstanceId: string, userId: string): Promise<IdentityLinkEntity> {
    // 检查是否已存在
    const existing = await this.identityLinkRepository.findOne({
      where: {
        type_: IdentityLinkType.PARTICIPANT,
        user_id_: userId,
        proc_inst_id_: processInstanceId,
      },
    });

    if (existing) {
      return existing;
    }

    const link = this.identityLinkRepository.create({
      id_: generateUuid(),
      type_: IdentityLinkType.PARTICIPANT,
      user_id_: userId,
      proc_inst_id_: processInstanceId,
      create_time_: new Date(),
    });
    return this.identityLinkRepository.save(link);
  }

  // 设置流程启动者
  async setStarter(processInstanceId: string, userId: string): Promise<IdentityLinkEntity> {
    const link = this.identityLinkRepository.create({
      id_: generateUuid(),
      type_: IdentityLinkType.STARTER,
      user_id_: userId,
      proc_inst_id_: processInstanceId,
      create_time_: new Date(),
    });
    return this.identityLinkRepository.save(link);
  }

  // 查询任务的候选用户
  async findCandidateUsers(taskId: string): Promise<string[]> {
    const links = await this.identityLinkRepository.find({
      where: { task_id_: taskId, type_: IdentityLinkType.CANDIDATE },
    });
    return links.filter(l => l.user_id_).map(l => l.user_id_);
  }

  // 查询任务的候选组
  async findCandidateGroups(taskId: string): Promise<string[]> {
    const links = await this.identityLinkRepository.find({
      where: { task_id_: taskId, type_: IdentityLinkType.CANDIDATE },
    });
    return links.filter(l => l.group_id_).map(l => l.group_id_);
  }

  // 查询用户可认领的任务
  async findTasksForUser(userId: string, groupIds: string[]): Promise<string[]> {
    const queryBuilder = this.identityLinkRepository
      .createQueryBuilder('link')
      .select('link.task_id_')
      .where('link.type_ = :type', { type: IdentityLinkType.CANDIDATE })
      .andWhere('(link.user_id_ = :userId OR link.group_id_ IN (:...groupIds))', {
        userId,
        groupIds: groupIds.length > 0 ? groupIds : [''],
      });

    const results = await queryBuilder.getRawMany();
    return results.map(r => r.link_task_id_);
  }

  // 查询流程实例的参与者
  async findParticipants(processInstanceId: string): Promise<string[]> {
    const links = await this.identityLinkRepository.find({
      where: { proc_inst_id_: processInstanceId },
    });
    return [...new Set(links.filter(l => l.user_id_).map(l => l.user_id_))];
  }

  // 删除任务的候选用户
  async deleteCandidateUser(taskId: string, userId: string): Promise<void> {
    await this.identityLinkRepository.delete({
      task_id_: taskId,
      type_: IdentityLinkType.CANDIDATE,
      user_id_: userId,
    });
  }

  // 删除任务的候选组
  async deleteCandidateGroup(taskId: string, groupId: string): Promise<void> {
    await this.identityLinkRepository.delete({
      task_id_: taskId,
      type_: IdentityLinkType.CANDIDATE,
      group_id_: groupId,
    });
  }
}
```

---

### 1.13 表单实例管理（Form Instance）

#### 功能描述
- **表单定义管理**：创建和管理表单定义
- **表单实例创建**：提交表单时创建表单实例
- **表单数据存储**：存储表单提交的数据
- **表单历史查询**：查询流程的表单提交历史
- **表单与任务/流程关联**：关联表单实例与任务、流程实例

#### Flowable 源码分析

**核心接口**：
- [`FormDefinition`](modules/flowable-form-api/src/main/java/org/flowable/form/api/FormDefinition.java) - 表单定义接口
- [`FormInstance`](modules/flowable-form-api/src/main/java/org/flowable/form/api/FormInstance.java) - 表单实例接口

**FormDefinition 接口**：
```java
public interface FormDefinition {
    String getId();                   // 唯一标识
    String getCategory();             // 分类
    String getName();                 // 显示名称
    String getKey();                  // 唯一标识键
    String getDescription();          // 描述
    int getVersion();                 // 版本号
    String getResourceName();         // 资源名称
    String getDeploymentId();         // 部署ID
    String getTenantId();             // 租户ID
}
```

**FormInstance 接口**：
```java
public interface FormInstance {
    String getId();                     // 唯一标识
    String getFormDefinitionId();       // 表单定义ID
    String getTaskId();                 // 任务ID
    String getProcessInstanceId();      // 流程实例ID
    String getProcessDefinitionId();    // 流程定义ID
    String getScopeId();                // 作用域ID
    String getScopeType();              // 作用域类型
    String getScopeDefinitionId();      // 作用域定义ID
    Date getSubmittedDate();            // 提交日期
    String getSubmittedBy();            // 提交人
    String getFormValuesId();           // 表单值文档ID
    String getTenantId();               // 租户ID
    byte[] getFormValueBytes();         // 表单值字节数组
}
```

#### Node.js + NestJS 实现思路

**表单定义实体设计**：
```typescript
// form-definition.entity.ts
@Entity('fl_form_definition')
export class FormDefinitionEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 255, nullable: true })
  category_: string;

  @Column({ length: 255, nullable: true })
  name_: string;

  @Column({ length: 255 })
  key_: string;

  @Column({ type: 'text', nullable: true })
  description_: string;

  @Column({ type: 'int' })
  version_: number;

  @Column({ length: 255, nullable: true })
  resource_name_: string;

  @Column({ length: 64, nullable: true })
  deployment_id_: string;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;

  @Column({ type: 'datetime' })
  create_time_: Date;
}
```

**表单实例实体设计**：
```typescript
// form-instance.entity.ts
@Entity('fl_form_instance')
export class FormInstanceEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 64 })
  form_definition_id_: string;

  @Column({ length: 64, nullable: true })
  task_id_: string;

  @Column({ length: 64, nullable: true })
  process_instance_id_: string;

  @Column({ length: 64, nullable: true })
  process_definition_id_: string;

  @Column({ length: 64, nullable: true })
  scope_id_: string;

  @Column({ length: 64, nullable: true })
  scope_type_: string;

  @Column({ length: 64, nullable: true })
  scope_definition_id_: string;

  @Column({ type: 'datetime' })
  submitted_date_: Date;

  @Column({ length: 64, nullable: true })
  submitted_by_: string;

  @Column({ length: 64, nullable: true })
  form_values_id_: string;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;

  @Column({ type: 'longblob', nullable: true })
  form_value_bytes_: Buffer;
}
```

**表单服务设计**：
```typescript
// form.service.ts
@Injectable()
export class FormService {
  constructor(
    @InjectRepository(FormDefinitionEntity)
    private readonly formDefRepository: Repository<FormDefinitionEntity>,
    @InjectRepository(FormInstanceEntity)
    private readonly formInstanceRepository: Repository<FormInstanceEntity>,
  ) {}

  // 创建表单定义
  async createFormDefinition(dto: CreateFormDefinitionDto): Promise<FormDefinitionEntity> {
    // 查询当前版本
    const latestForm = await this.formDefRepository.findOne({
      where: { key_: dto.key },
      order: { version_: 'DESC' },
    });

    const version = latestForm ? latestForm.version_ + 1 : 1;

    const formDef = this.formDefRepository.create({
      id_: generateUuid(),
      category_: dto.category,
      name_: dto.name,
      key_: dto.key,
      description_: dto.description,
      version_: version,
      resource_name_: dto.resourceName,
      deployment_id_: dto.deploymentId,
      tenant_id_: dto.tenantId,
      create_time_: new Date(),
    });

    return this.formDefRepository.save(formDef);
  }

  // 提交表单实例
  async submitFormInstance(dto: SubmitFormInstanceDto): Promise<FormInstanceEntity> {
    const formInstance = this.formInstanceRepository.create({
      id_: generateUuid(),
      form_definition_id_: dto.formDefinitionId,
      task_id_: dto.taskId,
      process_instance_id_: dto.processInstanceId,
      process_definition_id_: dto.processDefinitionId,
      scope_id_: dto.scopeId,
      scope_type_: dto.scopeType,
      scope_definition_id_: dto.scopeDefinitionId,
      submitted_date_: new Date(),
      submitted_by_: dto.submittedBy,
      tenant_id_: dto.tenantId,
      form_value_bytes_: Buffer.from(JSON.stringify(dto.formValues)),
    });

    return this.formInstanceRepository.save(formInstance);
  }

  // 查询任务的表单实例
  async findFormInstanceByTask(taskId: string): Promise<FormInstanceEntity | null> {
    return this.formInstanceRepository.findOne({
      where: { task_id_: taskId },
    });
  }

  // 查询流程实例的表单实例列表
  async findFormInstancesByProcess(processInstanceId: string): Promise<FormInstanceEntity[]> {
    return this.formInstanceRepository.find({
      where: { process_instance_id_: processInstanceId },
      order: { submitted_date_: 'ASC' },
    });
  }

  // 获取表单值
  async getFormValues(formInstanceId: string): Promise<Record<string, any>> {
    const instance = await this.formInstanceRepository.findOne({
      where: { id_: formInstanceId },
    });

    if (!instance || !instance.form_value_bytes_) {
      return {};
    }

    return JSON.parse(instance.form_value_bytes_.toString());
  }
}
```

---

### 1.14 事件订阅服务（Event Subscription）

#### 功能描述
- **信号订阅**：订阅信号事件
- **消息订阅**：订阅消息事件
- **条件订阅**：订阅条件事件
- **事件触发**：触发信号/消息事件
- **订阅查询**：查询事件订阅信息

#### Flowable 源码分析

**核心接口**：
- [`EventSubscription`](modules/flowable-eventsubscription-service-api/src/main/java/org/flowable/eventsubscription/api/EventSubscription.java) - 事件订阅接口
- [`EventSubscriptionQuery`](modules/flowable-eventsubscription-service-api/src/main/java/org/flowable/eventsubscription/api/EventSubscriptionQuery.java) - 事件订阅查询接口
- [`EventSubscriptionBuilder`](modules/flowable-eventsubscription-service-api/src/main/java/org/flowable/eventsubscription/api/EventSubscriptionBuilder.java) - 事件订阅构建器

**EventSubscription 接口关键属性**：
```java
public interface EventSubscription {
    String getId();                     // 唯一标识
    String getEventType();              // 事件类型：signal, message, conditional
    String getEventName();              // 事件名称
    String getExecutionId();            // 执行ID
    String getProcessInstanceId();      // 流程实例ID
    String getActivityId();             // 活动ID
    String getProcessDefinitionId();    // 流程定义ID
    String getTenantId();               // 租户ID
    Date getCreated();                  // 创建时间
}
```

#### Node.js + NestJS 实现思路

**事件订阅实体设计**：
```typescript
// event-subscription.entity.ts
@Entity('act_ru_event_subscr')
export class EventSubscriptionEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 255 })
  event_type_: string;  // signal, message, conditional

  @Column({ length: 255, nullable: true })
  event_name_: string;

  @Column({ length: 64, nullable: true })
  execution_id_: string;

  @Column({ length: 64, nullable: true })
  proc_inst_id_: string;

  @Column({ length: 255, nullable: true })
  activity_id_: string;

  @Column({ length: 64, nullable: true })
  proc_def_id_: string;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;

  @Column({ type: 'datetime' })
  created_: Date;
}
```

**事件订阅服务设计**：
```typescript
// event-subscription.service.ts
@Injectable()
export class EventSubscriptionService {
  constructor(
    @InjectRepository(EventSubscriptionEntity)
    private readonly subscriptionRepository: Repository<EventSubscriptionEntity>,
    private readonly eventBus: EventBusService,
  ) {}

  // 创建信号订阅
  async createSignalSubscription(dto: CreateEventSubscriptionDto): Promise<EventSubscriptionEntity> {
    const subscription = this.subscriptionRepository.create({
      id_: generateUuid(),
      event_type_: EventType.SIGNAL,
      event_name_: dto.eventName,
      execution_id_: dto.executionId,
      proc_inst_id_: dto.processInstanceId,
      activity_id_: dto.activityId,
      proc_def_id_: dto.processDefinitionId,
      tenant_id_: dto.tenantId,
      created_: new Date(),
    });
    return this.subscriptionRepository.save(subscription);
  }

  // 创建消息订阅
  async createMessageSubscription(dto: CreateEventSubscriptionDto): Promise<EventSubscriptionEntity> {
    const subscription = this.subscriptionRepository.create({
      id_: generateUuid(),
      event_type_: EventType.MESSAGE,
      event_name_: dto.eventName,
      execution_id_: dto.executionId,
      proc_inst_id_: dto.processInstanceId,
      activity_id_: dto.activityId,
      proc_def_id_: dto.processDefinitionId,
      tenant_id_: dto.tenantId,
      created_: new Date(),
    });
    return this.subscriptionRepository.save(subscription);
  }

  // 触发信号事件
  async signalEventReceived(signalName: string, payload?: Record<string, any>): Promise<void> {
    const subscriptions = await this.subscriptionRepository.find({
      where: { event_type_: EventType.SIGNAL, event_name_: signalName },
    });

    for (const subscription of subscriptions) {
      await this.triggerSubscription(subscription, payload);
    }
  }

  // 触发消息事件
  async messageEventReceived(messageName: string, executionId?: string, payload?: Record<string, any>): Promise<void> {
    const where: FindConditions<EventSubscriptionEntity> = {
      event_type_: EventType.MESSAGE,
      event_name_: messageName,
    };

    if (executionId) {
      where.execution_id_ = executionId;
    }

    const subscriptions = await this.subscriptionRepository.find({ where });

    for (const subscription of subscriptions) {
      await this.triggerSubscription(subscription, payload);
    }
  }

  // 触发订阅
  private async triggerSubscription(subscription: EventSubscriptionEntity, payload?: Record<string, any>): Promise<void> {
    // 发布事件
    this.eventBus.emit('event.subscription.triggered', {
      subscriptionId: subscription.id_,
      eventType: subscription.event_type_,
      eventName: subscription.event_name_,
      executionId: subscription.execution_id_,
      payload,
    });

    // 删除订阅
    await this.subscriptionRepository.delete(subscription.id_);
  }

  // 查询事件订阅
  async findSubscriptions(query: EventSubscriptionQueryDto): Promise<EventSubscriptionEntity[]> {
    const queryBuilder = this.subscriptionRepository.createQueryBuilder('sub');

    if (query.eventType) {
      queryBuilder.andWhere('sub.event_type_ = :eventType', { eventType: query.eventType });
    }

    if (query.eventName) {
      queryBuilder.andWhere('sub.event_name_ = :eventName', { eventName: query.eventName });
    }

    if (query.processInstanceId) {
      queryBuilder.andWhere('sub.proc_inst_id_ = :procInstId', { procInstId: query.processInstanceId });
    }

    if (query.executionId) {
      queryBuilder.andWhere('sub.execution_id_ = :executionId', { executionId: query.executionId });
    }

    return queryBuilder.getMany();
  }
}
```

---

### 1.15 批处理服务（Batch Service）

#### 功能描述
- **批量操作**：批量执行流程操作
- **批量迁移**：批量迁移流程实例
- **批量删除**：批量删除流程实例
- **批处理状态查询**：查询批处理执行状态
- **批处理结果**：获取批处理执行结果

#### Flowable 源码分析

**核心接口**：
- `Batch` - 批处理实体
- `BatchPart` - 批处理部分实体
- `BatchService` - 批处理服务接口

**批处理使用场景**：
| 场景 | 说明 |
|------|------|
| 流程实例迁移 | 将多个流程实例迁移到新版本 |
| 流程实例删除 | 批量删除流程实例 |
| DMN决策评估 | 批量评估决策表 |
| 外部工作者任务 | 批量处理外部任务 |

#### Node.js + NestJS 实现思路

**批处理实体设计**：
```typescript
// batch.entity.ts
@Entity('fl_batch')
export class BatchEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 255 })
  type_: string;  // migration, deletion, dmn, etc.

  @Column({ type: 'int' })
  total_batches_: number;

  @Column({ type: 'int', default: 0 })
  completed_batches_: number;

  @Column({ type: 'int', default: 0 })
  failed_batches_: number;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;

  @Column({ type: 'datetime' })
  create_time_: Date;

  @Column({ type: 'datetime', nullable: true })
  end_time_: Date;

  @Column({ length: 64, nullable: true })
  created_by_: string;

  @Column({ type: 'text', nullable: true })
  search_key_: string;
}
```

**批处理部分实体设计**：
```typescript
// batch-part.entity.ts
@Entity('fl_batch_part')
export class BatchPartEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 64 })
  batch_id_: string;

  @Column({ length: 255 })
  type_: string;

  @Column({ length: 255 })
  status_: string;  // pending, completed, failed

  @Column({ type: 'text', nullable: true })
  data_: string;  // JSON格式的处理数据

  @Column({ type: 'datetime' })
  create_time_: Date;

  @Column({ type: 'datetime', nullable: true })
  end_time_: Date;

  @Column({ type: 'text', nullable: true })
  error_message_: string;
}
```

**批处理服务设计**：
```typescript
// batch.service.ts
@Injectable()
export class BatchService {
  constructor(
    @InjectRepository(BatchEntity)
    private readonly batchRepository: Repository<BatchEntity>,
    @InjectRepository(BatchPartEntity)
    private readonly batchPartRepository: Repository<BatchPartEntity>,
    private readonly asyncExecutorService: AsyncExecutorService,
  ) {}

  // 创建批处理
  async createBatch(type: string, items: any[], createdBy?: string): Promise<BatchEntity> {
    // 创建批处理记录
    const batch = this.batchRepository.create({
      id_: generateUuid(),
      type_: type,
      total_batches_: items.length,
      completed_batches_: 0,
      failed_batches_: 0,
      created_by_: createdBy,
      create_time_: new Date(),
    });
    await this.batchRepository.save(batch);

    // 创建批处理部分
    for (const item of items) {
      const part = this.batchPartRepository.create({
        id_: generateUuid(),
        batch_id_: batch.id_,
        type_: type,
        status_: BatchPartStatus.PENDING,
        data_: JSON.stringify(item),
        create_time_: new Date(),
      });
      await this.batchPartRepository.save(part);

      // 添加到异步队列
      await this.asyncExecutorService.addJob({
        type: 'batch-part',
        batchId: batch.id_,
        partId: part.id_,
        data: item,
      });
    }

    return batch;
  }

  // 执行批处理部分
  async executeBatchPart(partId: string): Promise<void> {
    const part = await this.batchPartRepository.findOne({ where: { id_: partId } });
    if (!part) {
      throw new NotFoundException('批处理部分不存在');
    }

    try {
      const data = JSON.parse(part.data_);

      switch (part.type_) {
        case BatchType.MIGRATION:
          await this.executeMigration(data);
          break;
        case BatchType.DELETION:
          await this.executeDeletion(data);
          break;
        default:
          throw new BusinessException(`不支持的批处理类型: ${part.type_}`);
      }

      // 更新部分状态
      await this.batchPartRepository.update(partId, {
        status_: BatchPartStatus.COMPLETED,
        end_time_: new Date(),
      });

      // 更新批处理计数
      await this.updateBatchProgress(part.batch_id_, true);
    } catch (error) {
      // 更新部分状态为失败
      await this.batchPartRepository.update(partId, {
        status_: BatchPartStatus.FAILED,
        end_time_: new Date(),
        error_message_: error.message,
      });

      // 更新批处理计数
      await this.updateBatchProgress(part.batch_id_, false);
    }
  }

  // 更新批处理进度
  private async updateBatchProgress(batchId: string, success: boolean): Promise<void> {
    const batch = await this.batchRepository.findOne({ where: { id_: batchId } });
    if (!batch) return;

    if (success) {
      batch.completed_batches_ += 1;
    } else {
      batch.failed_batches_ += 1;
    }

    // 检查是否完成
    if (batch.completed_batches_ + batch.failed_batches_ >= batch.total_batches_) {
      batch.end_time_ = new Date();
    }

    await this.batchRepository.save(batch);
  }

  // 查询批处理状态
  async getBatchStatus(batchId: string): Promise<BatchStatusDto> {
    const batch = await this.batchRepository.findOne({ where: { id_: batchId } });
    if (!batch) {
      throw new NotFoundException('批处理不存在');
    }

    return {
      id: batch.id_,
      type: batch.type_,
      total: batch.total_batches_,
      completed: batch.completed_batches_,
      failed: batch.failed_batches_,
      status: this.calculateStatus(batch),
      createTime: batch.create_time_,
      endTime: batch.end_time_,
    };
  }

  // 计算批处理状态
  private calculateStatus(batch: BatchEntity): string {
    const processed = batch.completed_batches_ + batch.failed_batches_;
    if (processed >= batch.total_batches_) {
      return batch.failed_batches_ > 0 ? BatchStatus.COMPLETED_WITH_ERRORS : BatchStatus.COMPLETED;
    }
    return BatchStatus.RUNNING;
  }
}
```

---

### 1.16 内容服务（Content Service）

#### 功能描述
- **附件管理**：上传和管理流程附件
- **内容存储**：存储二进制内容
- **内容元数据**：管理内容的元数据信息
- **内容检索**：按条件检索内容

#### Flowable 源码分析

**核心接口**：
- `ContentItem` - 内容项接口
- `ContentService` - 内容服务接口

**ContentItem 关键属性**：
```java
public interface ContentItem {
    String getId();                     // 唯一标识
    String getName();                   // 名称
    String getDescription();            // 描述
    String getType();                   // 类型
    Long getContentSize();              // 内容大小
    String getProcessInstanceId();      // 流程实例ID
    String getTaskId();                 // 任务ID
    String getCreatedBy();              // 创建人
    Date getCreated();                  // 创建时间
    String getLastModifiedBy();         // 最后修改人
    Date getLastModified();             // 最后修改时间
}
```

#### Node.js + NestJS 实现思路

**内容项实体设计**：
```typescript
// content-item.entity.ts
@Entity('fl_content_item')
export class ContentItemEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 255 })
  name_: string;

  @Column({ type: 'text', nullable: true })
  description_: string;

  @Column({ length: 255, nullable: true })
  type_: string;  // MIME类型

  @Column({ type: 'bigint', nullable: true })
  content_size_: number;

  @Column({ length: 64, nullable: true })
  process_instance_id_: string;

  @Column({ length: 64, nullable: true })
  task_id_: string;

  @Column({ length: 64, nullable: true })
  scope_id_: string;

  @Column({ length: 64, nullable: true })
  scope_type_: string;

  @Column({ length: 64, nullable: true })
  created_by_: string;

  @Column({ type: 'datetime' })
  created_: Date;

  @Column({ length: 64, nullable: true })
  last_modified_by_: string;

  @Column({ type: 'datetime', nullable: true })
  last_modified_: Date;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;

  @Column({ type: 'text', nullable: true })
  content_store_id_: string;  // 内容存储引用
}
```

**内容服务设计**：
```typescript
// content.service.ts
@Injectable()
export class ContentService {
  constructor(
    @InjectRepository(ContentItemEntity)
    private readonly contentRepository: Repository<ContentItemEntity>,
    private readonly storageService: StorageService,
  ) {}

  // 创建内容项
  async createContentItem(dto: CreateContentItemDto, file: Express.Multer.File): Promise<ContentItemEntity> {
    // 存储文件
    const storageId = await this.storageService.store(file);

    const contentItem = this.contentRepository.create({
      id_: generateUuid(),
      name_: dto.name || file.originalname,
      description_: dto.description,
      type_: file.mimetype,
      content_size_: file.size,
      process_instance_id_: dto.processInstanceId,
      task_id_: dto.taskId,
      scope_id_: dto.scopeId,
      scope_type_: dto.scopeType,
      created_by_: dto.userId,
      created_: new Date(),
      content_store_id_: storageId,
      tenant_id_: dto.tenantId,
    });

    return this.contentRepository.save(contentItem);
  }

  // 获取内容
  async getContent(contentItemId: string): Promise<{ item: ContentItemEntity; stream: Readable }> {
    const item = await this.contentRepository.findOne({ where: { id_: contentItemId } });
    if (!item) {
      throw new NotFoundException('内容项不存在');
    }

    const stream = await this.storageService.retrieve(item.content_store_id_);
    return { item, stream };
  }

  // 查询任务附件
  async findContentItemsByTask(taskId: string): Promise<ContentItemEntity[]> {
    return this.contentRepository.find({
      where: { task_id_: taskId },
      order: { created_: 'DESC' },
    });
  }

  // 查询流程实例附件
  async findContentItemsByProcess(processInstanceId: string): Promise<ContentItemEntity[]> {
    return this.contentRepository.find({
      where: { process_instance_id_: processInstanceId },
      order: { created_: 'DESC' },
    });
  }

  // 删除内容项
  async deleteContentItem(contentItemId: string): Promise<void> {
    const item = await this.contentRepository.findOne({ where: { id_: contentItemId } });
    if (!item) {
      throw new NotFoundException('内容项不存在');
    }

    // 删除存储内容
    await this.storageService.delete(item.content_store_id_);

    // 删除元数据
    await this.contentRepository.delete(contentItemId);
  }
}
```

---

### 1.17 评论服务（Comment Service）

#### 功能描述
- **添加评论**：为流程实例或任务添加评论
- **查询评论**：查询流程实例或任务的评论列表
- **删除评论**：删除评论
- **评论类型**：支持不同类型的评论

#### Node.js + NestJS 实现思路

**评论实体设计**：
```typescript
// comment.entity.ts
@Entity('fl_comment')
export class CommentEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 64, nullable: true })
  user_id_: string;

  @Column({ length: 64, nullable: true })
  task_id_: string;

  @Column({ length: 64, nullable: true })
  process_instance_id_: string;

  @Column({ length: 255, nullable: true })
  type_: string;

  @Column({ type: 'text' })
  message_: string;

  @Column({ type: 'datetime' })
  time_: Date;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;
}
```

**评论服务设计**：
```typescript
// comment.service.ts
@Injectable()
export class CommentService {
  constructor(
    @InjectRepository(CommentEntity)
    private readonly commentRepository: Repository<CommentEntity>,
  ) {}

  // 添加评论
  async addComment(dto: AddCommentDto): Promise<CommentEntity> {
    const comment = this.commentRepository.create({
      id_: generateUuid(),
      user_id_: dto.userId,
      task_id_: dto.taskId,
      process_instance_id_: dto.processInstanceId,
      type_: dto.type || 'comment',
      message_: dto.message,
      time_: new Date(),
      tenant_id_: dto.tenantId,
    });
    return this.commentRepository.save(comment);
  }

  // 查询流程实例评论
  async findCommentsByProcess(processInstanceId: string): Promise<CommentEntity[]> {
    return this.commentRepository.find({
      where: { process_instance_id_: processInstanceId },
      order: { time_: 'ASC' },
    });
  }

  // 查询任务评论
  async findCommentsByTask(taskId: string): Promise<CommentEntity[]> {
    return this.commentRepository.find({
      where: { task_id_: taskId },
      order: { time_: 'ASC' },
    });
  }

  // 删除评论
  async deleteComment(commentId: string): Promise<void> {
    await this.commentRepository.delete(commentId);
  }
}
```

---

## 三、总结

本文档基于 Flowable 7.0.0 源码的深入分析，梳理了流程引擎的核心功能，并提供了 Node.js + NestJS + MySQL 技术栈的实现思路。

### 核心要点

1. **模块化设计**：将引擎划分为多个独立的服务模块，每个模块负责特定的业务领域
2. **事件驱动**：使用事件总线实现组件间的松耦合通信
3. **异步执行**：支持异步任务和异步历史记录，提高性能
4. **可扩展性**：通过监听器和装饰器实现灵活的扩展点
5. **BPMN 2.0 支持**：完整支持 BPMN 2.0 规范，包括各种网关、事件、子流程等

### 技术栈

- **后端框架**：NestJS
- **数据库**：MySQL
- **ORM**：TypeORM
- **BPMN 解析**：bpmn-moddle
- **流程图生成**：bpmn-js
- **异步任务**：Bull + Redis
- **定时器**：node-schedule
- **事件总线**：EventEmitter2
- **表单验证**：Ajv

### 下一步

接下来需要完成以下文档：
1. 技术设计文档（数据库设计、API 设计等）
2. 实现方案文档（NestJS 模块化、TypeORM 等）
3. 架构设计文档（微服务、缓存、消息队列等）
4. 规范文档（代码规范、Git 策略、CI/CD 等）
