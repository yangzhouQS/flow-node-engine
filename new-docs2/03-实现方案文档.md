# Flowable 实现方案文档 - Node.js + NestJS + MySQL

## 文档说明

本文档提供 Node.js + NestJS + MySQL 技术栈重新实现 Flowable 流程引擎的完整实现方案，包括模块化设计、TypeORM 实体映射、中间件和拦截器、异常处理、日志记录、测试方案等。

---

## 一、NestJS 模块化设计

### 1.1 项目目录结构

```
src/
├── main.ts                          # 应用入口
├── app.module.ts                    # 根模块
├── config/                          # 配置模块
│   ├── database.config.ts            # 数据库配置
│   ├── redis.config.ts               # Redis 配置
│   ├── cache.config.ts               # 缓存配置
│   └── app.config.ts                # 应用配置
├── common/                          # 公共模块
│   ├── common.module.ts             # 公共模块
│   ├── constants/                   # 常量定义
│   ├── enums/                      # 枚举定义
│   ├── decorators/                  # 装饰器
│   ├── filters/                     # 异常过滤器
│   ├── interceptors/                # 拦截器
│   ├── guards/                     # 守卫
│   ├── middlewares/                 # 中间件
│   ├── pipes/                      # 管道
│   ├── dto/                        # 通用 DTO
│   └── utils/                      # 工具类
├── core/                            # 核心引擎模块
│   ├── core.module.ts               # 核心模块
│   ├── services/                   # 核心服务
│   │   ├── process-engine.service.ts
│   │   ├── event-bus.service.ts
│   │   ├── expression-evaluator.service.ts
│   │   └── bpmn-parser.service.ts
│   └── constants/                  # 核心常量
├── process-definition/               # 流程定义模块
│   ├── process-definition.module.ts
│   ├── controllers/
│   │   └── process-definition.controller.ts
│   ├── services/
│   │   └── process-definition.service.ts
│   ├── entities/
│   │   ├── process-definition.entity.ts
│   │   └── deployment.entity.ts
│   └── dto/
│       ├── deploy-process-definition.dto.ts
│       ├── process-definition-query.dto.ts
│       └── suspend-process-definition.dto.ts
├── process-instance/                # 流程实例模块
│   ├── process-instance.module.ts
│   ├── controllers/
│   │   └── process-instance.controller.ts
│   ├── services/
│   │   ├── process-instance.service.ts
│   │   └── execution.service.ts
│   ├── entities/
│   │   ├── process-instance.entity.ts
│   │   └── execution.entity.ts
│   └── dto/
│       ├── start-process-instance.dto.ts
│       └── process-instance-query.dto.ts
├── task/                            # 任务管理模块
│   ├── task.module.ts
│   ├── controllers/
│   │   └── task.controller.ts
│   ├── services/
│   │   ├── task.service.ts
│   │   └── task-listener.service.ts
│   ├── entities/
│   │   ├── task.entity.ts
│   │   ├── task-candidate-user.entity.ts
│   │   └── task-candidate-group.entity.ts
│   └── dto/
│       ├── claim-task.dto.ts
│       ├── complete-task.dto.ts
│       └── task-query.dto.ts
├── history/                         # 历史数据模块
│   ├── history.module.ts
│   ├── controllers/
│   │   └── history.controller.ts
│   ├── services/
│   │   ├── history.service.ts
│   │   ├── historic-process-instance.service.ts
│   │   └── historic-task.service.ts
│   ├── entities/
│   │   ├── historic-process-instance.entity.ts
│   │   ├── historic-task.entity.ts
│   │   └── historic-variable.entity.ts
│   └── dto/
│       └── history-query.dto.ts
├── identity/                        # 身份管理模块
│   ├── identity.module.ts
│   ├── controllers/
│   │   ├── user.controller.ts
│   │   ├── role.controller.ts
│   │   └── group.controller.ts
│   ├── services/
│   │   ├── identity.service.ts
│   │   ├── user.service.ts
│   │   ├── role.service.ts
│   │   └── group.service.ts
│   ├── entities/
│   │   ├── user.entity.ts
│   │   ├── role.entity.ts
│   │   ├── group.entity.ts
│   │   ├── user-role.entity.ts
│   │   └── user-group.entity.ts
│   └── dto/
│       ├── create-user.dto.ts
│       ├── create-role.dto.ts
│       └── create-group.dto.ts
├── form/                            # 表单管理模块
│   ├── form.module.ts
│   ├── controllers/
│   │   └── form.controller.ts
│   ├── services/
│   │   ├── form.service.ts
│   │   └── form-data.service.ts
│   ├── entities/
│   │   ├── form.entity.ts
│   │   └── form-data.entity.ts
│   └── dto/
│       ├── create-form.dto.ts
│       └── submit-form-data.dto.ts
├── event/                           # 事件处理模块
│   ├── event.module.ts
│   ├── services/
│   │   ├── timer.service.ts
│   │   ├── event-subscription.service.ts
│   │   └── async-executor.service.ts
│   └── entities/
│       ├── timer.entity.ts
│       └── event-subscription.entity.ts
└── test/                            # 测试目录
    ├── unit/
    ├── e2e/
    └── fixtures/
```

---

### 1.2 根模块设计

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule, ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { CacheModule } from '@nestjs/cache-manager';
import { ScheduleModule } from '@nestjs/schedule';
import { BullModule } from '@nestjs/bull';

// 导入业务模块
import { CommonModule } from './common/common.module';
import { ProcessEngineCoreModule } from './core/core.module';
import { ProcessDefinitionModule } from './process-definition/process-definition.module';
import { ProcessInstanceModule } from './process-instance/process-instance.module';
import { TaskModule } from './task/task.module';
import { HistoryModule } from './history/history.module';
import { IdentityModule } from './identity/identity.module';
import { FormModule } from './form/form.module';
import { EventModule } from './event/event.module';

@Module({
  imports: [
    // 配置模块
    ConfigModule.forRoot({
      isGlobal: true,
      envFilePath: `.env.${process.env.NODE_ENV || 'development'}`,
    }),

    // TypeORM 数据库模块
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        type: 'mysql',
        host: configService.get('DB_HOST'),
        port: configService.get('DB_PORT'),
        username: configService.get('DB_USERNAME'),
        password: configService.get('DB_PASSWORD'),
        database: configService.get('DB_DATABASE'),
        entities: [__dirname + '/**/*.entity{.ts,.js}'],
        synchronize: configService.get('NODE_ENV') === 'development',
        logging: configService.get('NODE_ENV') === 'development',
        timezone: '+08:00',
        charset: 'utf8mb4',
        extra: {
          connectionLimit: 10,
        },
      }),
      inject: [ConfigService],
    }),

    // Redis 缓存模块
    CacheModule.registerAsync({
      isGlobal: true,
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        store: redisStore,
        host: configService.get('REDIS_HOST'),
        port: configService.get('REDIS_PORT'),
        password: configService.get('REDIS_PASSWORD'),
        ttl: 3600,
      }),
      inject: [ConfigService],
    }),

    // 定时任务模块
    ScheduleModule.forRoot(),

    // 消息队列模块
    BullModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        redis: {
          host: configService.get('REDIS_HOST'),
          port: configService.get('REDIS_PORT'),
          password: configService.get('REDIS_PASSWORD'),
        },
      }),
      inject: [ConfigService],
    }),

    // 业务模块
    CommonModule,
    ProcessEngineCoreModule,
    ProcessDefinitionModule,
    ProcessInstanceModule,
    TaskModule,
    HistoryModule,
    IdentityModule,
    FormModule,
    EventModule,
  ],
  controllers: [],
  providers: [],
})
export class AppModule {
  constructor(private readonly configService: ConfigService) {
    console.log('Application is starting...');
    console.log('Environment:', this.configService.get('NODE_ENV'));
  }
}
```

---

### 1.3 核心模块设计

```typescript
// core/core.module.ts
import { Global, Module } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';

// 导入核心服务
import { ProcessEngineService } from './services/process-engine.service';
import { EventBusService } from './services/event-bus.service';
import { ExpressionEvaluatorService } from './services/expression-evaluator.service';
import { BpmnParserService } from './services/bpmn-parser.service';

@Global() // 全局模块，所有模块可直接注入
@Module({
  imports: [
    EventEmitterModule.forRoot(),
  ],
  providers: [
    ProcessEngineService,
    EventBusService,
    ExpressionEvaluatorService,
    BpmnParserService,
  ],
  exports: [
    ProcessEngineService,
    EventBusService,
    ExpressionEvaluatorService,
    BpmnParserService,
  ],
})
export class ProcessEngineCoreModule {}
```

---

### 1.4 流程定义模块设计

```typescript
// process-definition/process-definition.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

// 导入服务
import { ProcessDefinitionService } from './services/process-definition.service';
import { BpmnParserService } from '../core/services/bpmn-parser.service';

// 导入控制器
import { ProcessDefinitionController } from './controllers/process-definition.controller';

// 导入实体
import { ProcessDefinition } from './entities/process-definition.entity';
import { Deployment } from './entities/deployment.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      ProcessDefinition,
      Deployment,
    ]),
  ],
  controllers: [
    ProcessDefinitionController,
  ],
  providers: [
    ProcessDefinitionService,
    BpmnParserService,
  ],
  exports: [
    ProcessDefinitionService,
  ],
})
export class ProcessDefinitionModule {}
```

---

## 二、TypeORM 实体关系映射

### 2.1 基础实体类

```typescript
// common/entities/base.entity.ts
import {
  PrimaryGeneratedColumn,
  CreateDateColumn,
  UpdateDateColumn,
  Column,
} from 'typeorm';

export abstract class BaseEntity {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @CreateDateColumn({ name: 'create_time' })
  createTime: Date;

  @UpdateDateColumn({ name: 'update_time', nullable: true })
  updateTime: Date;
}
```

---

### 2.2 流程定义实体

```typescript
// process-definition/entities/process-definition.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, OneToMany, Index } from 'typeorm';
import { Deployment } from './deployment.entity';
import { ProcessInstance } from '../process-instance/entities/process-instance.entity';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('process_definition')
@Index(['key', 'version'], { unique: true })
export class ProcessDefinition extends BaseEntity {
  @Column({ name: 'name', length: 128 })
  name: string;

  @Column({ name: 'key', length: 128 })
  key: string;

  @Column({ name: 'version', type: 'int' })
  version: number;

  @Column({ name: 'bpmn_xml', type: 'text' })
  bpmnXml: string;

  @Column({ name: 'is_active', type: 'tinyint', width: 1, default: 1 })
  isActive: boolean;

  @Column({ name: 'is_suspended', type: 'tinyint', width: 1, default: 0 })
  isSuspended: boolean;

  @Column({ name: 'deployment_id', length: 64, nullable: true })
  deploymentId: string;

  // 关联关系
  @ManyToOne(() => Deployment, { onDelete: 'SET NULL' })
  @JoinColumn({ name: 'deployment_id' })
  deployment: Deployment;

  @OneToMany(() => ProcessInstance, processInstance => processInstance.processDefinition)
  processInstances: ProcessInstance[];
}
```

---

### 2.3 流程实例实体

```typescript
// process-instance/entities/process-instance.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, OneToMany, Index } from 'typeorm';
import { ProcessDefinition } from '../process-definition/entities/process-definition.entity';
import { Execution } from './execution.entity';
import { Task } from '../task/entities/task.entity';
import { Variable } from './variable.entity';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('process_instance')
export class ProcessInstance extends BaseEntity {
  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @ManyToOne(() => ProcessDefinition, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'process_definition_id' })
  processDefinition: ProcessDefinition;

  @Column({ name: 'business_key', length: 64, nullable: true })
  @Index()
  businessKey: string;

  @Column({
    name: 'status',
    length: 20,
    type: 'enum',
    enum: ProcessInstanceStatus,
    default: ProcessInstanceStatus.RUNNING,
  })
  @Index()
  status: ProcessInstanceStatus;

  @Column({ name: 'variables', type: 'json', nullable: true })
  variables: Record<string, any>;

  @Column({ name: 'start_time', type: 'datetime' })
  startTime: Date;

  @Column({ name: 'end_time', type: 'datetime', nullable: true })
  endTime: Date;

  @Column({ name: 'start_user_id', length: 64, nullable: true })
  startUserId: string;

  @Column({ name: 'super_process_instance_id', length: 64, nullable: true })
  @Index()
  superProcessInstanceId: string;

  @Column({ name: 'call_activity_id', length: 64, nullable: true })
  callActivityId: string;

  @Column({ name: 'duration', type: 'int', nullable: true })
  duration: number;

  @Column({ name: 'delete_reason', length: 255, nullable: true })
  deleteReason: string;

  // 关联关系
  @OneToMany(() => Execution, execution => execution.processInstance)
  executions: Execution[];

  @OneToMany(() => Task, task => task.processInstance)
  tasks: Task[];

  @OneToMany(() => Variable, variable => variable.processInstance)
  variables: Variable[];
}

export enum ProcessInstanceStatus {
  RUNNING = 'RUNNING',
  SUSPENDED = 'SUSPENDED',
  COMPLETED = 'COMPLETED',
  TERMINATED = 'TERMINATED',
}
```

---

### 2.4 任务实体

```typescript
// task/entities/task.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, OneToMany, Index } from 'typeorm';
import { ProcessInstance } from '../process-instance/entities/process-instance.entity';
import { Execution } from '../process-instance/entities/execution.entity';
import { TaskCandidateUser } from './task-candidate-user.entity';
import { TaskCandidateGroup } from './task-candidate-group.entity';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('task')
export class Task extends BaseEntity {
  @Column({ name: 'process_instance_id', length: 64 })
  @Index()
  processInstanceId: string;

  @ManyToOne(() => ProcessInstance, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'process_instance_id' })
  processInstance: ProcessInstance;

  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @Column({ name: 'execution_id', length: 64, nullable: true })
  @Index()
  executionId: string;

  @ManyToOne(() => Execution, { onDelete: 'SET NULL' })
  @JoinColumn({ name: 'execution_id' })
  execution: Execution;

  @Column({ name: 'task_def_key', length: 64 })
  taskDefinitionKey: string;

  @Column({ name: 'name', length: 128, nullable: true })
  name: string;

  @Column({
    name: 'type',
    length: 20,
    type: 'enum',
    enum: TaskType,
    default: TaskType.USER,
  })
  type: TaskType;

  @Column({
    name: 'status',
    length: 20,
    type: 'enum',
    enum: TaskStatus,
    default: TaskStatus.CREATED,
  })
  @Index()
  status: TaskStatus;

  @Column({ name: 'assignee', length: 64, nullable: true })
  @Index()
  assignee: string;

  @Column({ name: 'candidate_users', type: 'text', nullable: true })
  candidateUsers: string;

  @Column({ name: 'candidate_groups', type: 'text', nullable: true })
  candidateGroups: string;

  @Column({ name: 'variables', type: 'json', nullable: true })
  variables: Record<string, any>;

  @Column({ name: 'tenant_id', length: 64, nullable: true })
  tenantId: string;

  @Column({ name: 'claim_time', type: 'datetime', nullable: true })
  claimTime: Date;

  @Column({ name: 'complete_time', type: 'datetime', nullable: true })
  @Index()
  completeTime: Date;

  @Column({ name: 'complete_by', length: 64, nullable: true })
  completeBy: string;

  @Column({ name: 'priority', type: 'int', default: 50 })
  priority: number;

  @Column({ name: 'due_date', type: 'int', nullable: true })
  dueDate: number;

  // 关联关系
  @OneToMany(() => TaskCandidateUser, candidateUser => candidateUser.task)
  candidateUsers: TaskCandidateUser[];

  @OneToMany(() => TaskCandidateGroup, candidateGroup => candidateGroup.task)
  candidateGroups: TaskCandidateGroup[];
}

export enum TaskType {
  USER = 'USER',
  SYSTEM = 'SYSTEM',
  DELEGATE = 'DELEGATE',
}

export enum TaskStatus {
  CREATED = 'CREATED',
  CLAIMED = 'CLAIMED',
  ASSIGNED = 'ASSIGNED',
  COMPLETED = 'COMPLETED',
  DELEGATED = 'DELEGATED',
  DELETED = 'DELETED',
}
```

---

### 2.5 用户实体

```typescript
// identity/entities/user.entity.ts
import { Entity, Column, OneToMany, Index } from 'typeorm';
import { UserRole } from './user-role.entity';
import { UserGroup } from './user-group.entity';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('user')
@Index(['username'], { unique: true })
export class User extends BaseEntity {
  @Column({ name: 'username', length: 64 })
  username: string;

  @Column({ name: 'password', length: 128 })
  password: string;

  @Column({ name: 'real_name', length: 64, nullable: true })
  realName: string;

  @Column({ name: 'email', length: 128, nullable: true })
  @Index()
  email: string;

  @Column({ name: 'is_active', type: 'tinyint', width: 1, default: 1 })
  @Index()
  isActive: boolean;

  // 关联关系
  @OneToMany(() => UserRole, userRole => userRole.user)
  roles: UserRole[];

  @OneToMany(() => UserGroup, userGroup => userGroup.user)
  groups: UserGroup[];
}
```

---

## 三、中间件和拦截器设计

### 3.1 全局日志中间件

```typescript
// common/middlewares/logger.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { Logger } from '@nestjs/common';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  private readonly logger = new Logger('HTTP');

  use(req: Request, res: Response, next: NextFunction) {
    const { method, originalUrl, ip } = req;
    const startTime = Date.now();

    // 响应完成后记录日志
    res.on('finish', () => {
      const { statusCode } = res;
      const duration = Date.now() - startTime;
      const contentLength = res.get('content-length');

      // 记录访问日志
      this.logger.log({
        method,
        url: originalUrl,
        statusCode,
        duration: `${duration}ms`,
        ip,
        contentLength,
        userAgent: req.headers['user-agent'],
      });
    });

    next();
  }
}
```

---

### 3.2 请求 ID 中间件

```typescript
// common/middlewares/request-id.middleware.ts
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { v4 as uuidv4 } from 'uuid';

@Injectable()
export class RequestIdMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction) {
    // 生成请求 ID
    const requestId = uuidv4();
    
    // 添加到请求对象
    req['requestId'] = requestId;
    
    // 添加到响应头
    res.setHeader('X-Request-ID', requestId);
    
    next();
  }
}
```

---

### 3.3 统一响应拦截器

```typescript
// common/interceptors/response.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface ApiResponse<T> {
  code: number;
  message: string;
  data: T;
  timestamp: number;
}

@Injectable()
export class ResponseInterceptor<T> implements NestInterceptor<T, ApiResponse<T>> {
  intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Observable<ApiResponse<T>> {
    return next.handle().pipe(
      map(data => ({
        code: 200,
        message: '操作成功',
        data: data || null,
        timestamp: Date.now(),
      })),
    );
  }
}
```

---

### 3.4 异常响应拦截器

```typescript
// common/interceptors/exception.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  BadRequestException,
  HttpException,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Injectable()
export class ExceptionInterceptor implements NestInterceptor {
  intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Observable<any> {
    return next.handle().pipe(
      catchError(error => {
        // 统一异常响应格式
        if (error instanceof BadRequestException) {
          // 参数验证错误
          return {
            code: 400,
            message: error.message,
            data: error.getResponse(),
            timestamp: Date.now(),
          };
        } else if (error instanceof HttpException) {
          // HTTP 异常
          return {
            code: error.getStatus(),
            message: error.message,
            data: null,
            timestamp: Date.now(),
          };
        } else {
          // 系统异常
          return {
            code: 500,
            message: '服务器内部错误',
            data: null,
            timestamp: Date.now(),
          };
        }
      }),
    );
  }
}
```

---

### 3.5 缓存拦截器

```typescript
// common/interceptors/cache.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';
import { Reflector } from '@nestjs/core';

export const CACHE_KEY_METADATA = 'cacheKey';
export const CACHE_TTL_METADATA = 'cacheTtl';

@Injectable()
export class CacheInterceptor implements NestInterceptor {
  constructor(private readonly reflector: Reflector) {}

  intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Observable<any> {
    // 获取缓存元数据
    const cacheKey = this.reflector.get<string>(
      CACHE_KEY_METADATA,
      context.getHandler(),
    );
    const cacheTtl = this.reflector.get<number>(
      CACHE_TTL_METADATA,
      context.getHandler(),
    );

    if (!cacheKey) {
      // 没有缓存键，直接执行
      return next.handle();
    }

    const request = context.switchToHttp().getRequest();
    const cacheManager = request.cacheManager;

    // 先从缓存获取
    return cacheManager.get(cacheKey).then(cachedValue => {
      if (cachedValue) {
        // 缓存命中
        return cachedValue;
      }

      // 缓存未命中，执行方法
      return next.handle().pipe(
        tap(response => {
          // 写入缓存
          cacheManager.set(cacheKey, response, { ttl: cacheTtl || 3600 });
        }),
      );
    });
  }
}

// 缓存装饰器
export const Cache = (key: string, ttl?: number) => {
  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
    Reflect.defineMetadata(CACHE_KEY_METADATA, key, descriptor.value);
    Reflect.defineMetadata(CACHE_TTL_METADATA, ttl, descriptor.value);
    return descriptor;
  };
};
```

---

### 3.6 事务拦截器

```typescript
// common/interceptors/transaction.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
import { DataSource, QueryRunner } from 'typeorm';

@Injectable()
export class TransactionInterceptor implements NestInterceptor {
  constructor(private readonly dataSource: DataSource) {}

  intercept(
    context: ExecutionContext,
    next: CallHandler,
  ): Observable<any> {
    const queryRunner = this.dataSource.createQueryRunner();
    
    // 开启事务
    return queryRunner.connect().then(() => {
      return queryRunner.startTransaction();
    }).then(() => {
      return next.handle().pipe(
        tap(() => {
          // 提交事务
          return queryRunner.commitTransaction();
        }),
        catchError(error => {
          // 回滚事务
          return queryRunner.rollbackTransaction().then(() => {
            throw error;
          });
        }),
        tap({
          finalize: () => {
            // 释放连接
            return queryRunner.release();
          },
        }),
      );
    });
  }
}

// 事务装饰器
export const Transactional = () => {
  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {
    Reflect.defineMetadata('transactional', true, descriptor.value);
    return descriptor;
  };
};
```

---

## 四、异常处理机制

### 4.1 自定义异常类

```typescript
// common/exceptions/business.exception.ts
import { HttpException, HttpStatus } from '@nestjs/common';

export interface ErrorDetail {
  field?: string;
  message: string;
}

export class BusinessException extends HttpException {
  constructor(
    message: string,
    code: number = 400,
    details?: ErrorDetail[],
  ) {
    super(
      {
        code,
        message,
        details: details || [],
        timestamp: Date.now(),
      },
      HttpStatus.OK, // 统一返回200，通过code区分错误
    );
  }
}
```

---

### 4.2 全局异常过滤器

```typescript
// common/filters/global-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  HttpException,
  Logger,
} from '@nestjs/common';
import { Request, Response } from 'express';

@Catch()
export class GlobalExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger('GlobalExceptionFilter');

  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();

    // 区分业务异常和系统异常
    if (exception instanceof HttpException) {
      const res = exception.getResponse() as any;
      
      // 记录日志
      this.logger.error({
        url: request.url,
        method: request.method,
        error: res,
        requestId: request['requestId'],
      });

      response.status(200).json({
        code: res.code || exception.getStatus(),
        message: res.message || exception.message,
        data: res.data || null,
        timestamp: Date.now(),
      });
    } else {
      // 系统异常
      this.logger.error({
        url: request.url,
        method: request.method,
        error: exception,
        requestId: request['requestId'],
        stack: (exception as Error).stack,
      });

      response.status(200).json({
        code: 500,
        message: '服务器内部错误',
        data: null,
        timestamp: Date.now(),
      });
    }
  }
}
```

---

### 4.3 参数验证异常处理

```typescript
// common/filters/validation-exception.filter.ts
import {
  ExceptionFilter,
  Catch,
  ArgumentsHost,
  BadRequestException,
  Logger,
} from '@nestjs/common';
import { ValidationError } from 'class-validator';

@Catch(BadRequestException)
export class ValidationExceptionFilter implements ExceptionFilter {
  private readonly logger = new Logger('ValidationExceptionFilter');

  catch(exception: BadRequestException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();

    const exceptionResponse = exception.getResponse();
    
    // 提取验证错误
    const validationErrors = exceptionResponse instanceof Array
      ? exceptionResponse
      : [];

    const details: ErrorDetail[] = validationErrors.map((error: ValidationError) => ({
      field: error.property,
      message: Object.values(error.constraints || {}).join(', '),
    }));

    // 记录日志
    this.logger.warn({
      url: request.url,
      method: request.method,
      validationErrors: details,
      requestId: request['requestId'],
    });

    response.status(200).json({
      code: 400,
      message: '参数验证失败',
      data: details,
      timestamp: Date.now(),
    });
  }
}
```

---

## 五、日志记录策略

### 5.1 日志配置

```typescript
// config/logger.config.ts
import * as winston from 'winston';
import * as DailyRotateFile from 'winston-daily-rotate-file';
import { ConfigService } from '@nestjs/config';

export const createLoggerConfig = (configService: ConfigService) => {
  const logDir = configService.get('LOG_DIR') || 'logs';
  const logLevel = configService.get('LOG_LEVEL') || 'info';
  const isProduction = configService.get('NODE_ENV') === 'production';

  // 日志格式
  const logFormat = winston.format.combine(
    winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss' }),
    winston.format.errors({ stack: true }),
    winston.format.json(),
  );

  // 日志传输
  const transports: winston.transport[] = [
    // 控制台输出
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple(),
      ),
    }),
  ];

  // 生产环境添加文件输出
  if (isProduction) {
    // 按日期分割的日志文件
    transports.push(
      new DailyRotateFile({
        filename: `${logDir}/app-%DATE%.log`,
        datePattern: 'YYYY-MM-DD',
        maxSize: '20m',
        maxFiles: '14d',
        format: logFormat,
        level: logLevel,
      }),
    );

    // 错误日志单独记录
    transports.push(
      new DailyRotateFile({
        filename: `${logDir}/error-%DATE%.log`,
        datePattern: 'YYYY-MM-DD',
        maxSize: '20m',
        maxFiles: '30d',
        format: logFormat,
        level: 'error',
      }),
    );
  }

  return {
    level: logLevel,
    format: logFormat,
    transports,
    exitOnError: false,
  };
};
```

---

### 5.2 日志服务

```typescript
// common/services/logger.service.ts
import { Injectable, LoggerService as NestLoggerService } from '@nestjs/common';
import * as winston from 'winston';

@Injectable()
export class LoggerService implements NestLoggerService {
  private readonly logger: winston.Logger;

  constructor() {
    this.logger = winston.createLogger({
      // 使用配置创建 logger
      ...createLoggerConfig(),
    });
  }

  log(message: any, context?: string) {
    this.logger.info(message, { context });
  }

  error(message: any, trace?: string, context?: string) {
    this.logger.error(message, { trace, context });
  }

  warn(message: any, context?: string) {
    this.logger.warn(message, { context });
  }

  debug(message: any, context?: string) {
    this.logger.debug(message, { context });
  }

  verbose(message: any, context?: string) {
    this.logger.verbose(message, { context });
  }
}
```

---

### 5.3 结构化日志

```typescript
// 使用结构化日志
this.logger.log({
  requestId: request['requestId'],
  userId: user.id,
  action: 'PROCESS_INSTANCE_START',
  processInstanceId: processInstance.id,
  processDefinitionKey: processDefinition.key,
  businessKey: businessKey,
  timestamp: new Date().toISOString(),
});

// 日志输出示例
{
  "level": "info",
  "message": "流程实例启动",
  "requestId": "550e8400-e29b-41d4-a716-446655440000",
  "userId": "user001",
  "action": "PROCESS_INSTANCE_START",
  "processInstanceId": "proc-inst-001",
  "processDefinitionKey": "leave",
  "businessKey": "ORDER123",
  "timestamp": "2026-02-12T03:30:00.000Z",
  "context": "ProcessInstanceService"
}
```

---

## 六、单元测试和集成测试方案

### 6.1 单元测试

#### 6.1.1 测试配置

```typescript
// test/jest.e2e.js
module.exports = {
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  testEnvironment: 'node',
  coverageDirectory: '../coverage',
  collectCoverageFrom: [
    'src/**/*.{js,ts}',
    '!src/main.ts',
    '!src/**/*.module.ts',
    '!src/**/*.dto.ts',
    '!src/**/*.interface.ts',
  ],
  coverageThresholds: {
    global: {
      branches: 70,
      functions: 70,
      lines: 70,
      statements: 70,
    },
  },
};
```

---

#### 6.1.2 服务单元测试示例

```typescript
// process-definition/services/process-definition.service.spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { ProcessDefinitionService } from './process-definition.service';
import { ProcessDefinition } from '../entities/process-definition.entity';
import { BpmnParserService } from '../../core/services/bpmn-parser.service';

describe('ProcessDefinitionService', () => {
  let service: ProcessDefinitionService;
  let repository: Repository<ProcessDefinition>;
  let bpmnParserService: BpmnParserService;

  const mockBpmnXml = `
    <?xml version="1.0" encoding="UTF-8"?>
    <definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL">
      <process id="leaveProcess" name="请假流程">
        <startEvent id="startEvent" />
        <userTask id="submitTask" name="提交申请" />
        <endEvent id="endEvent" />
      </process>
    </definitions>
  `;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ProcessDefinitionService,
        {
          provide: getRepositoryToken(ProcessDefinition),
          useValue: {
            find: jest.fn(),
            findOne: jest.fn(),
            save: jest.fn(),
            update: jest.fn(),
            delete: jest.fn(),
          },
        },
        {
          provide: BpmnParserService,
          useValue: {
            parse: jest.fn().mockResolvedValue({
              id: 'leaveProcess',
              processes: [
                {
                  id: 'leaveProcess',
                  name: '请假流程',
                },
              ],
            }),
            validate: jest.fn().mockReturnValue([]),
          },
        },
      ],
    }).compile();

    service = module.get<ProcessDefinitionService>(ProcessDefinitionService);
    repository = module.get(getRepositoryToken(ProcessDefinition));
    bpmnParserService = module.get(BpmnParserService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('deploy', () => {
    it('should deploy a process definition successfully', async () => {
      const dto = {
        name: '请假流程',
        key: 'leave',
        bpmnXml: mockBpmnXml,
        generateDiagram: false,
      };

      const result = await service.deploy(dto);

      expect(bpmnParserService.parse).toHaveBeenCalledWith(mockBpmnXml);
      expect(bpmnParserService.validate).toHaveBeenCalled();
      expect(repository.save).toHaveBeenCalled();
      expect(result).toHaveProperty('id');
      expect(result.name).toBe('请假流程');
    });

    it('should throw error if BPMN validation fails', async () => {
      const dto = {
        name: '请假流程',
        key: 'leave',
        bpmnXml: mockBpmnXml,
        generateDiagram: false,
      };

      // Mock 验证失败
      (bpmnParserService.validate as jest.Mock).mockReturnValue([
        {
          level: 'ERROR',
          message: '流程缺少结束事件',
        },
      ]);

      await expect(service.deploy(dto)).rejects.toThrow(
        expect.objectContaining({
          message: 'BPMN 模型验证失败',
        }),
      );
    });
  });

  describe('findById', () => {
    it('should find process definition by id', async () => {
      const mockProcessDefinition = {
        id: 'proc-def-001',
        name: '请假流程',
        key: 'leave',
        version: 1,
      };

      (repository.findOne as jest.Mock).mockResolvedValue(mockProcessDefinition);

      const result = await service.findById('proc-def-001');

      expect(repository.findOne).toHaveBeenCalledWith({
        where: { id: 'proc-def-001' },
      });
      expect(result).toEqual(mockProcessDefinition);
    });
  });
});
```

---

### 6.2 集成测试

#### 6.2.1 E2E 测试配置

```typescript
// test/jest-e2e.e2e.js
module.exports = {
  rootDir: '.',
  testEnvironment: 'node',
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  setupFiles: ['./test/setup.ts'],
  testMatch: ['**/*.e2e-spec.ts'],
};
```

---

#### 6.2.2 E2E 测试示例

```typescript
// process-definition/process-definition.controller.e2e-spec.ts
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from '../app.module';
import { ConfigService } from '@nestjs/config';

describe('ProcessDefinitionController (e2e)', () => {
  let app: INestApplication;
  let configService: ConfigService;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    configService = moduleFixture.get(ConfigService);
    
    await app.init();
  });

  afterAll(async () => {
    await app.close();
  });

  describe('/api/v1/process-definitions (POST)', () => {
    it('should deploy a process definition', () => {
      const bpmnXml = `
        <?xml version="1.0" encoding="UTF-8"?>
        <definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL">
          <process id="leaveProcess" name="请假流程">
            <startEvent id="startEvent" />
            <userTask id="submitTask" name="提交申请" />
            <endEvent id="endEvent" />
          </process>
        </definitions>
      `;

      return request(app.getHttpServer())
        .post('/api/v1/process-definitions')
        .send({
          name: '请假流程',
          key: 'leave',
          bpmnXml,
          generateDiagram: false,
        })
        .expect(200)
        .expect(res => {
          expect(res.body).toMatchObject({
            code: 200,
            message: '部署成功',
            data: {
              id: expect.any(String),
              name: '请假流程',
              key: 'leave',
              version: 1,
            },
          });
        });
    });

    it('should return 400 if BPMN XML is invalid', () => {
      return request(app.getHttpServer())
        .post('/api/v1/process-definitions')
        .send({
          name: '请假流程',
          key: 'leave',
          bpmnXml: 'invalid xml',
          generateDiagram: false,
        })
        .expect(200)
        .expect(res => {
          expect(res.body).toMatchObject({
            code: 400,
            message: expect.stringContaining('验证失败'),
          });
        });
    });
  });

  describe('/api/v1/process-definitions/:id (GET)', () => {
    it('should find process definition by id', () => {
      return request(app.getHttpServer())
        .get('/api/v1/process-definitions/proc-def-001')
        .expect(200)
        .expect(res => {
          expect(res.body).toMatchObject({
            code: 200,
            message: '查询成功',
            data: {
              id: 'proc-def-001',
            },
          });
        });
    });

    it('should return 404 if process definition not found', () => {
      return request(app.getHttpServer())
        .get('/api/v1/process-definitions/not-found')
        .expect(200)
        .expect(res => {
          expect(res.body).toMatchObject({
            code: 404,
            message: '流程定义不存在',
          });
        });
    });
  });
});
```

---

### 6.3 测试数据准备

```typescript
// test/fixtures/process-definition.fixture.ts
export const mockProcessDefinition = {
  id: 'proc-def-001',
  name: '请假流程',
  key: 'leave',
  version: 1,
  bpmnXml: `
    <?xml version="1.0" encoding="UTF-8"?>
    <definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL">
      <process id="leaveProcess" name="请假流程">
        <startEvent id="startEvent" />
        <userTask id="submitTask" name="提交申请" />
        <endEvent id="endEvent" />
      </process>
    </definitions>
  `,
  isActive: true,
  createTime: new Date('2026-02-12T03:30:00.000Z'),
};

export const mockProcessInstance = {
  id: 'proc-inst-001',
  processDefinitionId: 'proc-def-001',
  businessKey: 'ORDER123',
  status: 'RUNNING',
  startTime: new Date('2026-02-12T03:30:00.000Z'),
  variables: {
    applicant: 'user001',
    leaveDays: 3,
  },
};
```

---

## 七、新增服务模块设计

基于Flowable源码分析，添加以下新模块的实现设计。

### 7.1 作业服务模块（Job Module）

#### 7.1.1 模块目录结构

```
src/job/
├── job.module.ts
├── controllers/
│   └── job.controller.ts
├── services/
│   ├── job.service.ts
│   ├── timer-job.service.ts
│   ├── message-job.service.ts
│   ├── external-worker.service.ts
│   └── async-executor.service.ts
├── entities/
│   ├── job.entity.ts
│   ├── timer-job.entity.ts
│   ├── suspended-job.entity.ts
│   └── deadletter-job.entity.ts
├── dto/
│   ├── create-job.dto.ts
│   ├── job-query.dto.ts
│   └── acquire-jobs.dto.ts
└── processors/
    └── job.processor.ts
```

#### 7.1.2 作业模块定义

```typescript
// job/job.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { BullModule } from '@nestjs/bull';

import { JobController } from './controllers/job.controller';
import { JobService } from './services/job.service';
import { TimerJobService } from './services/timer-job.service';
import { MessageJobService } from './services/message-job.service';
import { ExternalWorkerService } from './services/external-worker.service';
import { AsyncExecutorService } from './services/async-executor.service';
import { JobProcessor } from './processors/job.processor';

import { JobEntity } from './entities/job.entity';
import { TimerJobEntity } from './entities/timer-job.entity';
import { SuspendedJobEntity } from './entities/suspended-job.entity';
import { DeadLetterJobEntity } from './entities/deadletter-job.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      JobEntity,
      TimerJobEntity,
      SuspendedJobEntity,
      DeadLetterJobEntity,
    ]),
    BullModule.registerQueue({
      name: 'job-queue',
    }),
  ],
  controllers: [JobController],
  providers: [
    JobService,
    TimerJobService,
    MessageJobService,
    ExternalWorkerService,
    AsyncExecutorService,
    JobProcessor,
  ],
  exports: [
    JobService,
    TimerJobService,
    ExternalWorkerService,
  ],
})
export class JobModule {}
```

#### 7.1.3 作业服务实现

```typescript
// job/services/job.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, LessThanOrEqual, In } from 'typeorm';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';

import { JobEntity } from '../entities/job.entity';
import { DeadLetterJobEntity } from '../entities/deadletter-job.entity';
import { SuspendedJobEntity } from '../entities/suspended-job.entity';
import { EventBusService } from '../../core/services/event-bus.service';
import { CreateJobDto } from '../dto/create-job.dto';
import { JobQueryDto } from '../dto/job-query.dto';

export enum JobType {
  TIMER = 'timer',
  MESSAGE = 'message',
  EXTERNAL_WORKER = 'externalWorker',
}

@Injectable()
export class JobService {
  constructor(
    @InjectRepository(JobEntity)
    private readonly jobRepository: Repository<JobEntity>,
    @InjectRepository(DeadLetterJobEntity)
    private readonly deadLetterJobRepository: Repository<DeadLetterJobEntity>,
    @InjectRepository(SuspendedJobEntity)
    private readonly suspendedJobRepository: Repository<SuspendedJobEntity>,
    @InjectQueue('job-queue')
    private readonly jobQueue: Queue,
    private readonly eventBus: EventBusService,
  ) {}

  // 创建作业
  async createJob(dto: CreateJobDto): Promise<JobEntity> {
    const job = this.jobRepository.create({
      id_: this.generateUuid(),
      job_type_: dto.jobType,
      job_handler_type_: dto.jobHandlerType,
      process_inst_id_: dto.processInstanceId,
      process_def_id_: dto.processDefinitionId,
      execution_id_: dto.executionId,
      element_id_: dto.elementId,
      element_name_: dto.elementName,
      duedate_: dto.duedate || new Date(),
      retries_: 3,
      job_handler_cfg_: dto.config ? Buffer.from(JSON.stringify(dto.config)) : null,
      tenant_id_: dto.tenantId,
      create_time_: new Date(),
    });

    const savedJob = await this.jobRepository.save(job);

    // 添加到队列
    await this.jobQueue.add('execute-job', {
      jobId: savedJob.id_,
    }, {
      delay: dto.duedate ? dto.duedate.getTime() - Date.now() : 0,
    });

    return savedJob;
  }

  // 查询到期作业
  async findDueJobs(limit: number = 100): Promise<JobEntity[]> {
    const now = new Date();
    return this.jobRepository.find({
      where: {
        duedate_: LessThanOrEqual(now),
        retries_: 0, // retries > 0
      },
      take: limit,
      order: { duedate_: 'ASC' },
    });
  }

  // 执行作业
  async executeJob(jobId: string): Promise<void> {
    const job = await this.jobRepository.findOne({ where: { id_: jobId } });
    if (!job) {
      throw new NotFoundException('作业不存在');
    }

    try {
      // 根据作业类型执行
      switch (job.job_type_) {
        case JobType.TIMER:
          await this.executeTimerJob(job);
          break;
        case JobType.MESSAGE:
          await this.executeMessageJob(job);
          break;
        case JobType.EXTERNAL_WORKER:
          // 外部工作者作业不自动执行
          return;
        default:
          throw new Error(`不支持的作业类型: ${job.job_type_}`);
      }

      // 执行成功，删除作业
      await this.jobRepository.delete(jobId);

      // 发布事件
      this.eventBus.emit('job.completed', {
        jobId,
        jobType: job.job_type_,
      });
    } catch (error) {
      await this.handleJobFailure(job, error);
    }
  }

  // 处理作业失败
  private async handleJobFailure(job: JobEntity, error: Error): Promise<void> {
    const retries = job.retries_ - 1;

    if (retries <= 0) {
      // 移动到死信队列
      await this.moveToDeadLetterJob(job, error);
    } else {
      // 更新重试次数和异常信息
      const backoffDate = this.calculateBackoffDate(retries);
      await this.jobRepository.update(job.id_, {
        retries_: retries,
        exception_msg_: error.message?.substring(0, 4000),
        exception_stack_: error.stack,
        duedate_: backoffDate,
      });
    }

    this.eventBus.emit('job.failed', {
      jobId: job.id_,
      retries,
      error: error.message,
    });
  }

  // 移动到死信队列
  private async moveToDeadLetterJob(job: JobEntity, error: Error): Promise<void> {
    const deadLetterJob = this.deadLetterJobRepository.create({
      id_: this.generateUuid(),
      job_type_: job.job_type_,
      job_handler_type_: job.job_handler_type_,
      process_inst_id_: job.process_inst_id_,
      process_def_id_: job.process_def_id_,
      execution_id_: job.execution_id_,
      element_id_: job.element_id_,
      exception_msg_: error.message?.substring(0, 4000),
      exception_stack_: error.stack,
      job_handler_cfg_: job.job_handler_cfg_,
      tenant_id_: job.tenant_id_,
      create_time_: new Date(),
    });

    await this.deadLetterJobRepository.save(deadLetterJob);
    await this.jobRepository.delete(job.id_);
  }

  // 计算退避时间
  private calculateBackoffDate(retries: number): Date {
    const delay = Math.pow(2, 4 - retries) * 1000; // 指数退避
    return new Date(Date.now() + delay);
  }

  // 执行定时器作业
  private async executeTimerJob(job: JobEntity): Promise<void> {
    const config = job.job_handler_cfg_ ? JSON.parse(job.job_handler_cfg_.toString()) : {};
    
    this.eventBus.emit('timer.triggered', {
      jobId: job.id_,
      executionId: job.execution_id_,
      processInstanceId: job.process_inst_id_,
      elementId: job.element_id_,
      config,
    });
  }

  // 执行消息作业
  private async executeMessageJob(job: JobEntity): Promise<void> {
    const config = job.job_handler_cfg_ ? JSON.parse(job.job_handler_cfg_.toString()) : {};
    
    this.eventBus.emit('message.triggered', {
      jobId: job.id_,
      executionId: job.execution_id_,
      processInstanceId: job.process_inst_id_,
      messageName: config.messageName,
      correlationKeys: config.correlationKeys,
    });
  }

  // 暂停作业
  async suspendJob(jobId: string): Promise<void> {
    const job = await this.jobRepository.findOne({ where: { id_: jobId } });
    if (!job) return;

    const suspendedJob = this.suspendedJobRepository.create({
      id_: this.generateUuid(),
      job_type_: job.job_type_,
      job_handler_type_: job.job_handler_type_,
      process_inst_id_: job.process_inst_id_,
      process_def_id_: job.process_def_id_,
      execution_id_: job.execution_id_,
      element_id_: job.element_id_,
      duedate_: job.duedate_,
      retries_: job.retries_,
      job_handler_cfg_: job.job_handler_cfg_,
      tenant_id_: job.tenant_id_,
      create_time_: new Date(),
    });

    await this.suspendedJobRepository.save(suspendedJob);
    await this.jobRepository.delete(jobId);
  }

  // 恢复作业
  async activateJob(suspendedJobId: string): Promise<void> {
    const suspendedJob = await this.suspendedJobRepository.findOne({
      where: { id_: suspendedJobId },
    });
    if (!suspendedJob) return;

    const job = this.jobRepository.create({
      id_: this.generateUuid(),
      job_type_: suspendedJob.job_type_,
      job_handler_type_: suspendedJob.job_handler_type_,
      process_inst_id_: suspendedJob.process_inst_id_,
      process_def_id_: suspendedJob.process_def_id_,
      execution_id_: suspendedJob.execution_id_,
      element_id_: suspendedJob.element_id_,
      duedate_: suspendedJob.duedate_,
      retries_: suspendedJob.retries_,
      job_handler_cfg_: suspendedJob.job_handler_cfg_,
      tenant_id_: suspendedJob.tenant_id_,
      create_time_: new Date(),
    });

    await this.jobRepository.save(job);
    await this.suspendedJobRepository.delete(suspendedJobId);
  }

  // 查询作业
  async findJobs(query: JobQueryDto): Promise<[JobEntity[], number]> {
    const queryBuilder = this.jobRepository.createQueryBuilder('job');

    if (query.jobType) {
      queryBuilder.andWhere('job.job_type_ = :jobType', { jobType: query.jobType });
    }

    if (query.processInstanceId) {
      queryBuilder.andWhere('job.process_inst_id_ = :processInstanceId', {
        processInstanceId: query.processInstanceId,
      });
    }

    if (query.executionId) {
      queryBuilder.andWhere('job.execution_id_ = :executionId', {
        executionId: query.executionId,
      });
    }

    if (query.withException) {
      queryBuilder.andWhere('job.exception_msg_ IS NOT NULL');
    }

    queryBuilder
      .skip((query.page - 1) * query.pageSize)
      .take(query.pageSize)
      .orderBy('job.duedate_', 'ASC');

    return queryBuilder.getManyAndCount();
  }

  // 重试死信作业
  async retryDeadLetterJob(deadLetterJobId: string): Promise<void> {
    const deadLetterJob = await this.deadLetterJobRepository.findOne({
      where: { id_: deadLetterJobId },
    });
    if (!deadLetterJob) {
      throw new NotFoundException('死信作业不存在');
    }

    const job = this.jobRepository.create({
      id_: this.generateUuid(),
      job_type_: deadLetterJob.job_type_,
      job_handler_type_: deadLetterJob.job_handler_type_,
      process_inst_id_: deadLetterJob.process_inst_id_,
      process_def_id_: deadLetterJob.process_def_id_,
      execution_id_: deadLetterJob.execution_id_,
      element_id_: deadLetterJob.element_id_,
      retries_: 3,
      job_handler_cfg_: deadLetterJob.job_handler_cfg_,
      tenant_id_: deadLetterJob.tenant_id_,
      create_time_: new Date(),
    });

    await this.jobRepository.save(job);
    await this.deadLetterJobRepository.delete(deadLetterJobId);

    // 添加到队列
    await this.jobQueue.add('execute-job', { jobId: job.id_ });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

#### 7.1.4 外部工作者服务实现

```typescript
// job/services/external-worker.service.ts
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, LessThanOrEqual } from 'typeorm';

import { JobEntity } from '../entities/job.entity';
import { JobService, JobType } from './job.service';
import { EventBusService } from '../../core/services/event-bus.service';
import { VariableService } from '../../process-instance/services/variable.service';
import { AcquireJobsDto } from '../dto/acquire-jobs.dto';

@Injectable()
export class ExternalWorkerService {
  constructor(
    @InjectRepository(JobEntity)
    private readonly jobRepository: Repository<JobEntity>,
    private readonly jobService: JobService,
    private readonly variableService: VariableService,
    private readonly eventBus: EventBusService,
  ) {}

  // 领取作业
  async acquireJobs(workerId: string, dto: AcquireJobsDto): Promise<JobEntity[]> {
    const now = new Date();
    const lockTime = new Date(now.getTime() + (dto.lockDuration || 5 * 60 * 1000));

    const jobs = await this.jobRepository
      .createQueryBuilder('job')
      .where('job.job_type_ = :type', { type: JobType.EXTERNAL_WORKER })
      .andWhere('job.job_handler_type_ = :topic', { topic: dto.topic })
      .andWhere('job.duedate_ <= :now', { now })
      .andWhere('job.retries_ > 0')
      .orderBy('job.duedate_', 'ASC')
      .take(dto.maxTasks || 10)
      .getMany();

    // 标记作业已被领取
    for (const job of jobs) {
      const config = job.job_handler_cfg_ ? JSON.parse(job.job_handler_cfg_.toString()) : {};
      config.workerId = workerId;
      config.lockTime = lockTime;
      
      await this.jobRepository.update(job.id_, {
        job_handler_cfg_: Buffer.from(JSON.stringify(config)),
      });
    }

    return jobs;
  }

  // 完成作业
  async completeJob(jobId: string, variables?: Record<string, any>): Promise<void> {
    const job = await this.jobRepository.findOne({ where: { id_: jobId } });
    if (!job) {
      throw new NotFoundException('作业不存在');
    }

    // 检查是否被锁定
    const config = job.job_handler_cfg_ ? JSON.parse(job.job_handler_cfg_.toString()) : {};
    if (config.lockTime && new Date(config.lockTime) < new Date()) {
      throw new BadRequestException('作业锁已过期');
    }

    // 设置流程变量
    if (variables && Object.keys(variables).length > 0) {
      await this.variableService.setVariables(job.process_inst_id_, variables);
    }

    // 删除作业
    await this.jobRepository.delete(jobId);

    // 发布事件
    this.eventBus.emit('external-worker.job.completed', {
      jobId,
      processInstanceId: job.process_inst_id_,
      executionId: job.execution_id_,
      variables,
    });
  }

  // 作业失败
  async failJob(jobId: string, errorMessage: string, retries?: number): Promise<void> {
    const job = await this.jobRepository.findOne({ where: { id_: jobId } });
    if (!job) {
      throw new NotFoundException('作业不存在');
    }

    if (retries !== undefined && retries > 0) {
      // 更新重试次数
      await this.jobRepository.update(jobId, {
        retries_: retries,
        exception_msg_: errorMessage?.substring(0, 4000),
      });
    } else {
      // 标记为失败
      await this.jobService.handleJobFailure(job, new Error(errorMessage));
    }
  }

  // 作业退回（延长锁时间）
  async extendLock(jobId: string, lockDuration: number): Promise<void> {
    const job = await this.jobRepository.findOne({ where: { id_: jobId } });
    if (!job) {
      throw new NotFoundException('作业不存在');
    }

    const config = job.job_handler_cfg_ ? JSON.parse(job.job_handler_cfg_.toString()) : {};
    config.lockTime = new Date(Date.now() + lockDuration);

    await this.jobRepository.update(jobId, {
      job_handler_cfg_: Buffer.from(JSON.stringify(config)),
    });
  }
}
```

---

### 7.2 身份链接模块（IdentityLink Module）

#### 7.2.1 模块定义

```typescript
// identity-link/identity-link.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

import { IdentityLinkService } from './services/identity-link.service';
import { IdentityLinkEntity } from './entities/identity-link.entity';
import { HistoricIdentityLinkEntity } from './entities/historic-identity-link.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      IdentityLinkEntity,
      HistoricIdentityLinkEntity,
    ]),
  ],
  providers: [IdentityLinkService],
  exports: [IdentityLinkService],
})
export class IdentityLinkModule {}
```

#### 7.2.2 身份链接服务实现

```typescript
// identity-link/services/identity-link.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';

import { IdentityLinkEntity } from '../entities/identity-link.entity';
import { HistoricIdentityLinkEntity } from '../entities/historic-identity-link.entity';
import { EventBusService } from '../../core/services/event-bus.service';

export class IdentityLinkType {
  static readonly ASSIGNEE = 'assignee';
  static readonly CANDIDATE = 'candidate';
  static readonly OWNER = 'owner';
  static readonly STARTER = 'starter';
  static readonly PARTICIPANT = 'participant';
  static readonly REACTIVATOR = 'reactivator';
}

@Injectable()
export class IdentityLinkService {
  constructor(
    @InjectRepository(IdentityLinkEntity)
    private readonly identityLinkRepository: Repository<IdentityLinkEntity>,
    @InjectRepository(HistoricIdentityLinkEntity)
    private readonly historicIdentityLinkRepository: Repository<HistoricIdentityLinkEntity>,
    private readonly eventBus: EventBusService,
  ) {}

  // 添加任务候选人（用户）
  async addCandidateUser(taskId: string, userId: string): Promise<IdentityLinkEntity> {
    const link = this.identityLinkRepository.create({
      id_: this.generateUuid(),
      type_: IdentityLinkType.CANDIDATE,
      user_id_: userId,
      task_id_: taskId,
      create_time_: new Date(),
    });

    const saved = await this.identityLinkRepository.save(link);

    this.eventBus.emit('identity-link.created', {
      type: IdentityLinkType.CANDIDATE,
      taskId,
      userId,
    });

    return saved;
  }

  // 添加任务候选组
  async addCandidateGroup(taskId: string, groupId: string): Promise<IdentityLinkEntity> {
    const link = this.identityLinkRepository.create({
      id_: this.generateUuid(),
      type_: IdentityLinkType.CANDIDATE,
      group_id_: groupId,
      task_id_: taskId,
      create_time_: new Date(),
    });

    const saved = await this.identityLinkRepository.save(link);

    this.eventBus.emit('identity-link.created', {
      type: IdentityLinkType.CANDIDATE,
      taskId,
      groupId,
    });

    return saved;
  }

  // 设置任务分配人
  async setAssignee(taskId: string, userId: string): Promise<IdentityLinkEntity> {
    // 先删除旧的分配人
    await this.identityLinkRepository.delete({
      task_id_: taskId,
      type_: IdentityLinkType.ASSIGNEE,
    });

    const link = this.identityLinkRepository.create({
      id_: this.generateUuid(),
      type_: IdentityLinkType.ASSIGNEE,
      user_id_: userId,
      task_id_: taskId,
      create_time_: new Date(),
    });

    return this.identityLinkRepository.save(link);
  }

  // 设置任务所有者
  async setOwner(taskId: string, userId: string): Promise<IdentityLinkEntity> {
    await this.identityLinkRepository.delete({
      task_id_: taskId,
      type_: IdentityLinkType.OWNER,
    });

    const link = this.identityLinkRepository.create({
      id_: this.generateUuid(),
      type_: IdentityLinkType.OWNER,
      user_id_: userId,
      task_id_: taskId,
      create_time_: new Date(),
    });

    return this.identityLinkRepository.save(link);
  }

  // 添加流程参与者
  async addParticipant(processInstanceId: string, userId: string): Promise<IdentityLinkEntity> {
    // 检查是否已存在
    const existing = await this.identityLinkRepository.findOne({
      where: {
        type_: IdentityLinkType.PARTICIPANT,
        user_id_: userId,
        proc_inst_id_: processInstanceId,
      },
    });

    if (existing) {
      return existing;
    }

    const link = this.identityLinkRepository.create({
      id_: this.generateUuid(),
      type_: IdentityLinkType.PARTICIPANT,
      user_id_: userId,
      proc_inst_id_: processInstanceId,
      create_time_: new Date(),
    });

    return this.identityLinkRepository.save(link);
  }

  // 设置流程启动者
  async setStarter(processInstanceId: string, userId: string): Promise<IdentityLinkEntity> {
    const link = this.identityLinkRepository.create({
      id_: this.generateUuid(),
      type_: IdentityLinkType.STARTER,
      user_id_: userId,
      proc_inst_id_: processInstanceId,
      create_time_: new Date(),
    });

    return this.identityLinkRepository.save(link);
  }

  // 查询任务的候选用户
  async findCandidateUsers(taskId: string): Promise<string[]> {
    const links = await this.identityLinkRepository.find({
      where: { task_id_: taskId, type_: IdentityLinkType.CANDIDATE },
    });
    return links.filter(l => l.user_id_).map(l => l.user_id_);
  }

  // 查询任务的候选组
  async findCandidateGroups(taskId: string): Promise<string[]> {
    const links = await this.identityLinkRepository.find({
      where: { task_id_: taskId, type_: IdentityLinkType.CANDIDATE },
    });
    return links.filter(l => l.group_id_).map(l => l.group_id_);
  }

  // 查询用户可认领的任务ID列表
  async findTaskIdsForUser(userId: string, groupIds: string[]): Promise<string[]> {
    const queryBuilder = this.identityLinkRepository
      .createQueryBuilder('link')
      .select('DISTINCT link.task_id_', 'taskId')
      .where('link.type_ = :type', { type: IdentityLinkType.CANDIDATE })
      .andWhere('link.task_id_ IS NOT NULL');

    if (groupIds.length > 0) {
      queryBuilder.andWhere(
        '(link.user_id_ = :userId OR link.group_id_ IN (:...groupIds))',
        { userId, groupIds }
      );
    } else {
      queryBuilder.andWhere('link.user_id_ = :userId', { userId });
    }

    const results = await queryBuilder.getRawMany();
    return results.map(r => r.taskId);
  }

  // 查询流程实例的参与者
  async findParticipants(processInstanceId: string): Promise<string[]> {
    const links = await this.identityLinkRepository.find({
      where: { proc_inst_id_: processInstanceId },
    });
    return [...new Set(links.filter(l => l.user_id_).map(l => l.user_id_))];
  }

  // 查询流程启动者
  async findStarter(processInstanceId: string): Promise<string | null> {
    const link = await this.identityLinkRepository.findOne({
      where: {
        proc_inst_id_: processInstanceId,
        type_: IdentityLinkType.STARTER,
      },
    });
    return link?.user_id_ || null;
  }

  // 删除任务的候选用户
  async deleteCandidateUser(taskId: string, userId: string): Promise<void> {
    await this.identityLinkRepository.delete({
      task_id_: taskId,
      type_: IdentityLinkType.CANDIDATE,
      user_id_: userId,
    });
  }

  // 删除任务的候选组
  async deleteCandidateGroup(taskId: string, groupId: string): Promise<void> {
    await this.identityLinkRepository.delete({
      task_id_: taskId,
      type_: IdentityLinkType.CANDIDATE,
      group_id_: groupId,
    });
  }

  // 删除任务的所有身份链接
  async deleteByIdentityLinksForTask(taskId: string): Promise<void> {
    // 先保存到历史
    const links = await this.identityLinkRepository.find({
      where: { task_id_: taskId },
    });

    for (const link of links) {
      const historicLink = this.historicIdentityLinkRepository.create({
        id_: this.generateUuid(),
        type_: link.type_,
        user_id_: link.user_id_,
        group_id_: link.group_id_,
        task_id_: link.task_id_,
        proc_inst_id_: link.proc_inst_id_,
        proc_def_id_: link.proc_def_id_,
        create_time_: link.create_time_,
      });
      await this.historicIdentityLinkRepository.save(historicLink);
    }

    // 删除运行时链接
    await this.identityLinkRepository.delete({ task_id_: taskId });
  }

  // 删除流程实例的所有身份链接
  async deleteIdentityLinksForProcessInstance(processInstanceId: string): Promise<void> {
    const links = await this.identityLinkRepository.find({
      where: { proc_inst_id_: processInstanceId },
    });

    for (const link of links) {
      const historicLink = this.historicIdentityLinkRepository.create({
        id_: this.generateUuid(),
        type_: link.type_,
        user_id_: link.user_id_,
        group_id_: link.group_id_,
        task_id_: link.task_id_,
        proc_inst_id_: link.proc_inst_id_,
        proc_def_id_: link.proc_def_id_,
        create_time_: link.create_time_,
      });
      await this.historicIdentityLinkRepository.save(historicLink);
    }

    await this.identityLinkRepository.delete({ proc_inst_id_: processInstanceId });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

---

### 7.3 事件订阅模块（Event Subscription Module）

#### 7.3.1 事件订阅服务实现

```typescript
// event-subscription/services/event-subscription.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, FindConditions } from 'typeorm';

import { EventSubscriptionEntity } from '../entities/event-subscription.entity';
import { EventBusService } from '../../core/services/event-bus.service';

export class EventType {
  static readonly SIGNAL = 'signal';
  static readonly MESSAGE = 'message';
  static readonly CONDITIONAL = 'conditional';
}

@Injectable()
export class EventSubscriptionService {
  constructor(
    @InjectRepository(EventSubscriptionEntity)
    private readonly subscriptionRepository: Repository<EventSubscriptionEntity>,
    private readonly eventBus: EventBusService,
  ) {}

  // 创建信号订阅
  async createSignalSubscription(dto: CreateEventSubscriptionDto): Promise<EventSubscriptionEntity> {
    const subscription = this.subscriptionRepository.create({
      id_: this.generateUuid(),
      event_type_: EventType.SIGNAL,
      event_name_: dto.eventName,
      execution_id_: dto.executionId,
      proc_inst_id_: dto.processInstanceId,
      activity_id_: dto.activityId,
      proc_def_id_: dto.processDefinitionId,
      tenant_id_: dto.tenantId,
      created_: new Date(),
    });
    return this.subscriptionRepository.save(subscription);
  }

  // 创建消息订阅
  async createMessageSubscription(dto: CreateEventSubscriptionDto): Promise<EventSubscriptionEntity> {
    const subscription = this.subscriptionRepository.create({
      id_: this.generateUuid(),
      event_type_: EventType.MESSAGE,
      event_name_: dto.eventName,
      execution_id_: dto.executionId,
      proc_inst_id_: dto.processInstanceId,
      activity_id_: dto.activityId,
      proc_def_id_: dto.processDefinitionId,
      tenant_id_: dto.tenantId,
      created_: new Date(),
    });
    return this.subscriptionRepository.save(subscription);
  }

  // 创建条件订阅
  async createConditionalSubscription(dto: CreateEventSubscriptionDto): Promise<EventSubscriptionEntity> {
    const subscription = this.subscriptionRepository.create({
      id_: this.generateUuid(),
      event_type_: EventType.CONDITIONAL,
      event_name_: dto.eventName,
      execution_id_: dto.executionId,
      proc_inst_id_: dto.processInstanceId,
      activity_id_: dto.activityId,
      proc_def_id_: dto.processDefinitionId,
      tenant_id_: dto.tenantId,
      created_: new Date(),
    });
    return this.subscriptionRepository.save(subscription);
  }

  // 触发信号事件
  async signalEventReceived(signalName: string, payload?: Record<string, any>): Promise<void> {
    const subscriptions = await this.subscriptionRepository.find({
      where: { event_type_: EventType.SIGNAL, event_name_: signalName },
    });

    for (const subscription of subscriptions) {
      await this.triggerSubscription(subscription, payload);
    }
  }

  // 触发消息事件
  async messageEventReceived(
    messageName: string,
    executionId?: string,
    payload?: Record<string, any>
  ): Promise<void> {
    const where: FindConditions<EventSubscriptionEntity> = {
      event_type_: EventType.MESSAGE,
      event_name_: messageName,
    };

    if (executionId) {
      where.execution_id_ = executionId;
    }

    const subscriptions = await this.subscriptionRepository.find({ where });

    for (const subscription of subscriptions) {
      await this.triggerSubscription(subscription, payload);
    }
  }

  // 触发订阅
  private async triggerSubscription(
    subscription: EventSubscriptionEntity,
    payload?: Record<string, any>
  ): Promise<void> {
    // 发布事件
    this.eventBus.emit('event.subscription.triggered', {
      subscriptionId: subscription.id_,
      eventType: subscription.event_type_,
      eventName: subscription.event_name_,
      executionId: subscription.execution_id_,
      processInstanceId: subscription.proc_inst_id_,
      activityId: subscription.activity_id_,
      payload,
    });

    // 删除订阅
    await this.subscriptionRepository.delete(subscription.id_);
  }

  // 查询事件订阅
  async findSubscriptions(query: EventSubscriptionQueryDto): Promise<EventSubscriptionEntity[]> {
    const queryBuilder = this.subscriptionRepository.createQueryBuilder('sub');

    if (query.eventType) {
      queryBuilder.andWhere('sub.event_type_ = :eventType', { eventType: query.eventType });
    }

    if (query.eventName) {
      queryBuilder.andWhere('sub.event_name_ = :eventName', { eventName: query.eventName });
    }

    if (query.processInstanceId) {
      queryBuilder.andWhere('sub.proc_inst_id_ = :procInstId', {
        procInstId: query.processInstanceId,
      });
    }

    if (query.executionId) {
      queryBuilder.andWhere('sub.execution_id_ = :executionId', {
        executionId: query.executionId,
      });
    }

    if (query.activityId) {
      queryBuilder.andWhere('sub.activity_id_ = :activityId', {
        activityId: query.activityId,
      });
    }

    return queryBuilder.getMany();
  }

  // 删除执行的所有订阅
  async deleteSubscriptionsForExecution(executionId: string): Promise<void> {
    await this.subscriptionRepository.delete({ execution_id_: executionId });
  }

  // 删除流程实例的所有订阅
  async deleteSubscriptionsForProcessInstance(processInstanceId: string): Promise<void> {
    await this.subscriptionRepository.delete({ proc_inst_id_: processInstanceId });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}

// DTO 定义
interface CreateEventSubscriptionDto {
  eventName: string;
  executionId?: string;
  processInstanceId?: string;
  activityId?: string;
  processDefinitionId?: string;
  tenantId?: string;
}

interface EventSubscriptionQueryDto {
  eventType?: string;
  eventName?: string;
  processInstanceId?: string;
  executionId?: string;
  activityId?: string;
}
```

---

### 7.4 批处理模块（Batch Module）

#### 7.4.1 批处理服务实现

```typescript
// batch/services/batch.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';

import { BatchEntity } from '../entities/batch.entity';
import { BatchPartEntity } from '../entities/batch-part.entity';
import { EventBusService } from '../../core/services/event-bus.service';

export class BatchType {
  static readonly MIGRATION = 'migration';
  static readonly DELETION = 'deletion';
  static readonly DMN = 'dmn';
}

export class BatchPartStatus {
  static readonly PENDING = 'pending';
  static readonly RUNNING = 'running';
  static readonly COMPLETED = 'completed';
  static readonly FAILED = 'failed';
}

export class BatchStatus {
  static readonly RUNNING = 'running';
  static readonly COMPLETED = 'completed';
  static readonly COMPLETED_WITH_ERRORS = 'completed_with_errors';
}

@Injectable()
export class BatchService {
  constructor(
    @InjectRepository(BatchEntity)
    private readonly batchRepository: Repository<BatchEntity>,
    @InjectRepository(BatchPartEntity)
    private readonly batchPartRepository: Repository<BatchPartEntity>,
    @InjectQueue('batch-queue')
    private readonly batchQueue: Queue,
    private readonly eventBus: EventBusService,
  ) {}

  // 创建批处理
  async createBatch(
    type: string,
    items: any[],
    createdBy?: string
  ): Promise<BatchEntity> {
    // 创建批处理记录
    const batch = this.batchRepository.create({
      id_: this.generateUuid(),
      type_: type,
      total_batches_: items.length,
      completed_batches_: 0,
      failed_batches_: 0,
      created_by_: createdBy,
      create_time_: new Date(),
    });
    await this.batchRepository.save(batch);

    // 创建批处理部分
    for (const item of items) {
      const part = this.batchPartRepository.create({
        id_: this.generateUuid(),
        batch_id_: batch.id_,
        type_: type,
        status_: BatchPartStatus.PENDING,
        data_: JSON.stringify(item),
        create_time_: new Date(),
      });
      await this.batchPartRepository.save(part);

      // 添加到队列
      await this.batchQueue.add('execute-batch-part', {
        batchId: batch.id_,
        partId: part.id_,
        data: item,
      });
    }

    this.eventBus.emit('batch.created', {
      batchId: batch.id_,
      type,
      totalItems: items.length,
    });

    return batch;
  }

  // 执行批处理部分
  async executeBatchPart(partId: string): Promise<void> {
    const part = await this.batchPartRepository.findOne({ where: { id_: partId } });
    if (!part) {
      throw new NotFoundException('批处理部分不存在');
    }

    // 更新状态为运行中
    await this.batchPartRepository.update(partId, {
      status_: BatchPartStatus.RUNNING,
    });

    try {
      const data = JSON.parse(part.data_);

      switch (part.type_) {
        case BatchType.MIGRATION:
          await this.executeMigration(data);
          break;
        case BatchType.DELETION:
          await this.executeDeletion(data);
          break;
        default:
          throw new Error(`不支持的批处理类型: ${part.type_}`);
      }

      // 更新部分状态为完成
      await this.batchPartRepository.update(partId, {
        status_: BatchPartStatus.COMPLETED,
        end_time_: new Date(),
      });

      // 更新批处理进度
      await this.updateBatchProgress(part.batch_id_, true);
    } catch (error) {
      // 更新部分状态为失败
      await this.batchPartRepository.update(partId, {
        status_: BatchPartStatus.FAILED,
        end_time_: new Date(),
        error_message_: error.message?.substring(0, 4000),
      });

      // 更新批处理进度
      await this.updateBatchProgress(part.batch_id_, false);
    }
  }

  // 执行迁移
  private async executeMigration(data: any): Promise<void> {
    // 实现迁移逻辑
    this.eventBus.emit('batch.migration.executed', data);
  }

  // 执行删除
  private async executeDeletion(data: any): Promise<void> {
    // 实现删除逻辑
    this.eventBus.emit('batch.deletion.executed', data);
  }

  // 更新批处理进度
  private async updateBatchProgress(batchId: string, success: boolean): Promise<void> {
    const batch = await this.batchRepository.findOne({ where: { id_: batchId } });
    if (!batch) return;

    if (success) {
      batch.completed_batches_ += 1;
    } else {
      batch.failed_batches_ += 1;
    }

    // 检查是否完成
    if (batch.completed_batches_ + batch.failed_batches_ >= batch.total_batches_) {
      batch.end_time_ = new Date();
      
      this.eventBus.emit('batch.completed', {
        batchId,
        total: batch.total_batches_,
        completed: batch.completed_batches_,
        failed: batch.failed_batches_,
        status: this.calculateStatus(batch),
      });
    }

    await this.batchRepository.save(batch);
  }

  // 查询批处理状态
  async getBatchStatus(batchId: string): Promise<BatchStatusDto> {
    const batch = await this.batchRepository.findOne({ where: { id_: batchId } });
    if (!batch) {
      throw new NotFoundException('批处理不存在');
    }

    return {
      id: batch.id_,
      type: batch.type_,
      total: batch.total_batches_,
      completed: batch.completed_batches_,
      failed: batch.failed_batches_,
      status: this.calculateStatus(batch),
      createTime: batch.create_time_,
      endTime: batch.end_time_,
      createdBy: batch.created_by_,
    };
  }

  // 计算批处理状态
  private calculateStatus(batch: BatchEntity): string {
    const processed = batch.completed_batches_ + batch.failed_batches_;
    if (processed >= batch.total_batches_) {
      return batch.failed_batches_ > 0
        ? BatchStatus.COMPLETED_WITH_ERRORS
        : BatchStatus.COMPLETED;
    }
    return BatchStatus.RUNNING;
  }

  // 查询批处理部分列表
  async getBatchParts(batchId: string): Promise<BatchPartEntity[]> {
    return this.batchPartRepository.find({
      where: { batch_id_: batchId },
      order: { create_time_: 'ASC' },
    });
  }

  // 取消批处理
  async cancelBatch(batchId: string): Promise<void> {
    const batch = await this.batchRepository.findOne({ where: { id_: batchId } });
    if (!batch) {
      throw new NotFoundException('批处理不存在');
    }

    // 删除待处理的部分
    await this.batchPartRepository.delete({
      batch_id_: batchId,
      status_: BatchPartStatus.PENDING,
    });

    // 更新批处理状态
    await this.batchRepository.update(batchId, {
      end_time_: new Date(),
    });

    this.eventBus.emit('batch.cancelled', { batchId });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}

interface BatchStatusDto {
  id: string;
  type: string;
  total: number;
  completed: number;
  failed: number;
  status: string;
  createTime: Date;
  endTime?: Date;
  createdBy?: string;
}
```

---

### 7.5 内容服务模块（Content Module）

#### 7.5.1 内容服务实现

```typescript
// content/services/content.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Readable } from 'stream';

import { ContentItemEntity } from '../entities/content-item.entity';
import { StorageService } from './storage.service';
import { EventBusService } from '../../core/services/event-bus.service';

@Injectable()
export class ContentService {
  constructor(
    @InjectRepository(ContentItemEntity)
    private readonly contentRepository: Repository<ContentItemEntity>,
    private readonly storageService: StorageService,
    private readonly eventBus: EventBusService,
  ) {}

  // 创建内容项
  async createContentItem(
    dto: CreateContentItemDto,
    file: Express.Multer.File
  ): Promise<ContentItemEntity> {
    // 存储文件
    const storageId = await this.storageService.store(file);

    const contentItem = this.contentRepository.create({
      id_: this.generateUuid(),
      name_: dto.name || file.originalname,
      description_: dto.description,
      type_: file.mimetype,
      content_size_: file.size,
      process_instance_id_: dto.processInstanceId,
      task_id_: dto.taskId,
      scope_id_: dto.scopeId,
      scope_type_: dto.scopeType,
      created_by_: dto.userId,
      created_: new Date(),
      content_store_id_: storageId,
      tenant_id_: dto.tenantId,
    });

    const saved = await this.contentRepository.save(contentItem);

    this.eventBus.emit('content.created', {
      contentId: saved.id_,
      name: saved.name_,
      processInstanceId: saved.process_instance_id_,
      taskId: saved.task_id_,
    });

    return saved;
  }

  // 获取内容
  async getContent(
    contentItemId: string
  ): Promise<{ item: ContentItemEntity; stream: Readable }> {
    const item = await this.contentRepository.findOne({ where: { id_: contentItemId } });
    if (!item) {
      throw new NotFoundException('内容项不存在');
    }

    const stream = await this.storageService.retrieve(item.content_store_id_);
    return { item, stream };
  }

  // 查询任务附件
  async findContentItemsByTask(taskId: string): Promise<ContentItemEntity[]> {
    return this.contentRepository.find({
      where: { task_id_: taskId },
      order: { created_: 'DESC' },
    });
  }

  // 查询流程实例附件
  async findContentItemsByProcess(processInstanceId: string): Promise<ContentItemEntity[]> {
    return this.contentRepository.find({
      where: { process_instance_id_: processInstanceId },
      order: { created_: 'DESC' },
    });
  }

  // 更新内容项
  async updateContentItem(
    contentItemId: string,
    dto: UpdateContentItemDto
  ): Promise<ContentItemEntity> {
    const item = await this.contentRepository.findOne({ where: { id_: contentItemId } });
    if (!item) {
      throw new NotFoundException('内容项不存在');
    }

    if (dto.name) {
      item.name_ = dto.name;
    }
    if (dto.description !== undefined) {
      item.description_ = dto.description;
    }
    item.last_modified_ = new Date();
    item.last_modified_by_ = dto.userId;

    return this.contentRepository.save(item);
  }

  // 删除内容项
  async deleteContentItem(contentItemId: string): Promise<void> {
    const item = await this.contentRepository.findOne({ where: { id_: contentItemId } });
    if (!item) {
      throw new NotFoundException('内容项不存在');
    }

    // 删除存储内容
    await this.storageService.delete(item.content_store_id_);

    // 删除元数据
    await this.contentRepository.delete(contentItemId);

    this.eventBus.emit('content.deleted', {
      contentId: contentItemId,
      processInstanceId: item.process_instance_id_,
      taskId: item.task_id_,
    });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}

interface CreateContentItemDto {
  name?: string;
  description?: string;
  processInstanceId?: string;
  taskId?: string;
  scopeId?: string;
  scopeType?: string;
  userId?: string;
  tenantId?: string;
}

interface UpdateContentItemDto {
  name?: string;
  description?: string;
  userId?: string;
}
```

---

### 7.6 评论服务模块（Comment Module）

#### 7.6.1 评论服务实现

```typescript
// comment/services/comment.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';

import { CommentEntity } from '../entities/comment.entity';
import { EventBusService } from '../../core/services/event-bus.service';

@Injectable()
export class CommentService {
  constructor(
    @InjectRepository(CommentEntity)
    private readonly commentRepository: Repository<CommentEntity>,
    private readonly eventBus: EventBusService,
  ) {}

  // 添加评论
  async addComment(dto: AddCommentDto): Promise<CommentEntity> {
    const comment = this.commentRepository.create({
      id_: this.generateUuid(),
      user_id_: dto.userId,
      task_id_: dto.taskId,
      process_instance_id_: dto.processInstanceId,
      type_: dto.type || 'comment',
      message_: dto.message,
      time_: new Date(),
      tenant_id_: dto.tenantId,
    });

    const saved = await this.commentRepository.save(comment);

    this.eventBus.emit('comment.added', {
      commentId: saved.id_,
      userId: saved.user_id_,
      taskId: saved.task_id_,
      processInstanceId: saved.process_instance_id_,
    });

    return saved;
  }

  // 查询流程实例评论
  async findCommentsByProcess(processInstanceId: string): Promise<CommentEntity[]> {
    return this.commentRepository.find({
      where: { process_instance_id_: processInstanceId },
      order: { time_: 'ASC' },
    });
  }

  // 查询任务评论
  async findCommentsByTask(taskId: string): Promise<CommentEntity[]> {
    return this.commentRepository.find({
      where: { task_id_: taskId },
      order: { time_: 'ASC' },
    });
  }

  // 查询评论
  async findCommentById(commentId: string): Promise<CommentEntity> {
    const comment = await this.commentRepository.findOne({
      where: { id_: commentId },
    });
    if (!comment) {
      throw new NotFoundException('评论不存在');
    }
    return comment;
  }

  // 删除评论
  async deleteComment(commentId: string): Promise<void> {
    const comment = await this.commentRepository.findOne({
      where: { id_: commentId },
    });
    if (!comment) {
      throw new NotFoundException('评论不存在');
    }

    await this.commentRepository.delete(commentId);

    this.eventBus.emit('comment.deleted', {
      commentId,
      taskId: comment.task_id_,
      processInstanceId: comment.process_instance_id_,
    });
  }

  // 删除任务的所有评论
  async deleteCommentsByTask(taskId: string): Promise<void> {
    await this.commentRepository.delete({ task_id_: taskId });
  }

  // 删除流程实例的所有评论
  async deleteCommentsByProcess(processInstanceId: string): Promise<void> {
    await this.commentRepository.delete({ process_instance_id_: processInstanceId });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}

interface AddCommentDto {
  userId: string;
  taskId?: string;
  processInstanceId?: string;
  type?: string;
  message: string;
  tenantId?: string;
}
```

---

## 八、总结

本文档提供了 Node.js + NestJS + MySQL 技术栈重新实现 Flowable 流程引擎的完整实现方案，包括：

### 核心要点

1. **模块化设计**：清晰的模块划分，职责明确
2. **实体映射**：完整的 TypeORM 实体定义和关联关系
3. **中间件和拦截器**：日志、请求 ID、响应、缓存、事务等
4. **异常处理**：自定义异常类、全局异常过滤器
5. **日志记录**：结构化日志、多级别日志、文件轮转
6. **测试方案**：单元测试、集成测试、测试数据准备

### 技术栈

- **后端框架**：NestJS 10.x
- **数据库**：MySQL 8.0+
- **ORM**：TypeORM 0.3.x
- **缓存**：Redis 7.x
- **消息队列**：Bull 4.x + Redis
- **日志**：Winston 3.x
- **测试**：Jest 29.x
- **验证**：class-validator 0.14.x

### 下一步

接下来需要完成以下文档：
1. 架构设计文档（微服务、缓存、消息队列等）
2. 规范文档（代码规范、Git 策略、CI/CD 等）
3. 总览文档（整合所有文档）

---

## 九、任务操作模块设计

本章节补充任务驳回、抄送、多实例退回策略等功能的 NestJS 模块实现设计。

### 9.1 任务驳回模块（Task Reject Module）

#### 9.1.1 模块目录结构

```
src/task/
├── entities/
│   ├── task-reject.entity.ts        # 任务驳回记录实体
│   └── reject-config.entity.ts      # 驳回配置实体
├── services/
│   ├── task-reject.service.ts       # 任务驳回服务
│   └── multi-instance-reject.service.ts  # 多实例驳回服务
├── dto/
│   ├── reject-task.dto.ts           # 驳回任务DTO
│   └── reject-config.dto.ts         # 驳回配置DTO
└── controllers/
    └── task-reject.controller.ts    # 任务驳回控制器
```

#### 9.1.2 任务驳回实体

```typescript
// task/entities/task-reject.entity.ts
import { Entity, Column, PrimaryColumn, Index, ManyToOne, JoinColumn } from 'typeorm';

@Entity('act_ru_task_reject')
export class TaskRejectEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 64 })
  @Index()
  task_id_: string;

  @Column({ length: 64 })
  @Index()
  process_inst_id_: string;

  @Column({ length: 64, nullable: true })
  execution_id_: string;

  @Column({ length: 64, nullable: true })
  process_def_id_: string;

  @Column({ length: 20 })
  reject_type_: string; // ROLLBACK / REJECT / DENY

  @Column({ length: 30 })
  reject_strategy_: string; // TO_PREVIOUS / TO_STARTER / TO_SPECIFIC / TO_ANY_HISTORY

  @Column({ length: 64, nullable: true })
  target_activity_id_: string;

  @Column({ length: 255, nullable: true })
  target_activity_name_: string;

  @Column({ length: 64 })
  reject_user_id_: string;

  @Column({ type: 'text', nullable: true })
  reject_reason_: string;

  @Column({ type: 'datetime' })
  reject_time_: Date;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;
}

// 驳回类型枚举
export enum RejectType {
  ROLLBACK = 'ROLLBACK',     // 退回到上一节点
  REJECT = 'REJECT',         // 驳回到指定节点
  DENY = 'DENY',             // 拒绝，直接结束流程
}

// 驳回策略枚举
export enum RejectStrategy {
  TO_PREVIOUS = 'TO_PREVIOUS',           // 退回到上一节点
  TO_STARTER = 'TO_STARTER',             // 退回到发起人
  TO_SPECIFIC = 'TO_SPECIFIC',           // 退回到指定节点
  TO_ANY_HISTORY = 'TO_ANY_HISTORY',     // 退回到任意历史节点
  NOT_ALLOWED = 'NOT_ALLOWED',           // 不允许驳回
}
```

#### 9.1.3 驳回配置实体

```typescript
// task/entities/reject-config.entity.ts
import { Entity, Column, PrimaryColumn, Index } from 'typeorm';

@Entity('act_re_reject_config')
export class RejectConfigEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 64 })
  @Index()
  process_def_id_: string;

  @Column({ length: 64 })
  @Index()
  activity_id_: string;

  @Column({ length: 255, nullable: true })
  activity_name_: string;

  @Column({ type: 'tinyint', width: 1, default: 1 })
  allow_reject_: boolean;

  @Column({ length: 30, default: RejectStrategy.TO_PREVIOUS })
  default_strategy_: string;

  @Column({ type: 'text', nullable: true })
  allowed_target_activities_: string; // JSON 数组

  @Column({ type: 'text', nullable: true })
  reject_condition_: string; // EL 表达式

  @Column({ length: 64, nullable: true })
  tenant_id_: string;
}
```

#### 9.1.4 任务驳回服务

```typescript
// task/services/task-reject.service.ts
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, In } from 'typeorm';

import { TaskRejectEntity, RejectType, RejectStrategy } from '../entities/task-reject.entity';
import { RejectConfigEntity } from '../entities/reject-config.entity';
import { TaskEntity } from '../entities/task.entity';
import { HistoricActivityInstanceEntity } from '../../history/entities/historic-activity-instance.entity';
import { EventBusService } from '../../core/services/event-bus.service';
import { RejectTaskDto } from '../dto/reject-task.dto';

@Injectable()
export class TaskRejectService {
  constructor(
    @InjectRepository(TaskRejectEntity)
    private readonly taskRejectRepository: Repository<TaskRejectEntity>,
    @InjectRepository(RejectConfigEntity)
    private readonly rejectConfigRepository: Repository<RejectConfigEntity>,
    @InjectRepository(TaskEntity)
    private readonly taskRepository: Repository<TaskEntity>,
    @InjectRepository(HistoricActivityInstanceEntity)
    private readonly historicActivityRepository: Repository<HistoricActivityInstanceEntity>,
    private readonly dataSource: DataSource,
    private readonly eventBus: EventBusService,
  ) {}

  /**
   * 驳回任务
   */
  async rejectTask(dto: RejectTaskDto): Promise<TaskRejectEntity> {
    // 1. 查询任务信息
    const task = await this.taskRepository.findOne({ where: { id_: dto.taskId } });
    if (!task) {
      throw new NotFoundException('任务不存在');
    }

    // 2. 检查驳回配置
    const config = await this.getRejectConfig(task.process_def_id_, task.task_def_key_);
    if (config && !config.allow_reject_) {
      throw new BadRequestException('当前节点不允许驳回');
    }

    // 3. 确定驳回策略
    const strategy = dto.rejectStrategy || config?.default_strategy_ || RejectStrategy.TO_PREVIOUS;

    // 4. 计算目标节点
    const targetActivity = await this.resolveTargetActivity(task, strategy, dto.targetActivityId);
    if (!targetActivity) {
      throw new BadRequestException('无法确定驳回目标节点');
    }

    // 5. 创建驳回记录
    const rejectRecord = this.taskRejectRepository.create({
      id_: this.generateUuid(),
      task_id_: task.id_,
      process_inst_id_: task.process_inst_id_,
      execution_id_: task.execution_id_,
      process_def_id_: task.process_def_id_,
      reject_type_: dto.rejectType,
      reject_strategy_: strategy,
      target_activity_id_: targetActivity.activityId,
      target_activity_name_: targetActivity.activityName,
      reject_user_id_: dto.userId,
      reject_reason_: dto.reason,
      reject_time_: new Date(),
      tenant_id_: task.tenant_id_,
    });

    await this.taskRejectRepository.save(rejectRecord);

    // 6. 执行驳回操作
    await this.executeReject(task, targetActivity, dto);

    // 7. 发布事件
    this.eventBus.emit('task.rejected', {
      taskId: task.id_,
      processInstanceId: task.process_inst_id_,
      rejectType: dto.rejectType,
      targetActivityId: targetActivity.activityId,
      userId: dto.userId,
      reason: dto.reason,
    });

    return rejectRecord;
  }

  /**
   * 获取可退回的节点列表
   */
  async getRejectTargets(taskId: string): Promise<RejectTargetDto[]> {
    const task = await this.taskRepository.findOne({ where: { id_: taskId } });
    if (!task) {
      throw new NotFoundException('任务不存在');
    }

    // 查询历史活动节点
    const historicActivities = await this.historicActivityRepository.find({
      where: {
        process_inst_id_: task.process_inst_id_,
        activity_type_: In(['userTask', 'multiInstanceBody']),
      },
      order: { start_time_: 'ASC' },
    });

    // 过滤掉当前节点之后的节点
    const currentActivity = historicActivities.find(
      a => a.activity_id_ === task.task_def_key_ && !a.end_time_
    );

    const targets: RejectTargetDto[] = [];
    for (const activity of historicActivities) {
      if (activity.activity_id_ !== task.task_def_key_ && activity.end_time_) {
        targets.push({
          activityId: activity.activity_id_,
          activityName: activity.activity_name_,
          endTime: activity.end_time_,
        });
      }
    }

    return targets;
  }

  /**
   * 获取驳回配置
   */
  private async getRejectConfig(processDefId: string, activityId: string): Promise<RejectConfigEntity | null> {
    return this.rejectConfigRepository.findOne({
      where: { process_def_id_: processDefId, activity_id_: activityId },
    });
  }

  /**
   * 解析目标活动节点
   */
  private async resolveTargetActivity(
    task: TaskEntity,
    strategy: RejectStrategy,
    specificActivityId?: string
  ): Promise<{ activityId: string; activityName: string } | null> {
    switch (strategy) {
      case RejectStrategy.TO_PREVIOUS:
        return this.getPreviousActivity(task);

      case RejectStrategy.TO_STARTER:
        return this.getStarterActivity(task);

      case RejectStrategy.TO_SPECIFIC:
        if (!specificActivityId) {
          throw new BadRequestException('指定节点驳回需要提供目标节点ID');
        }
        return this.getActivityInfo(task.process_def_id_, specificActivityId);

      case RejectStrategy.TO_ANY_HISTORY:
        return this.getLatestHistoricalActivity(task);

      default:
        return null;
    }
  }

  /**
   * 获取上一节点
   */
  private async getPreviousActivity(task: TaskEntity): Promise<{ activityId: string; activityName: string } | null> {
    const historicActivities = await this.historicActivityRepository.find({
      where: { process_inst_id_: task.process_inst_id_ },
      order: { end_time_: 'DESC' },
      take: 10,
    });

    // 找到当前节点之前完成的用户任务
    for (const activity of historicActivities) {
      if (activity.activity_id_ !== task.task_def_key_ && activity.end_time_) {
        return {
          activityId: activity.activity_id_,
          activityName: activity.activity_name_,
        };
      }
    }

    return null;
  }

  /**
   * 获取发起人所在节点
   */
  private async getStarterActivity(task: TaskEntity): Promise<{ activityId: string; activityName: string } | null> {
    // 获取流程的第一个用户任务节点
    const firstActivity = await this.historicActivityRepository.findOne({
      where: {
        process_inst_id_: task.process_inst_id_,
        activity_type_: 'userTask',
      },
      order: { start_time_: 'ASC' },
    });

    if (firstActivity) {
      return {
        activityId: firstActivity.activity_id_,
        activityName: firstActivity.activity_name_,
      };
    }

    return null;
  }

  /**
   * 获取最近的历史节点
   */
  private async getLatestHistoricalActivity(task: TaskEntity): Promise<{ activityId: string; activityName: string } | null> {
    return this.getPreviousActivity(task);
  }

  /**
   * 获取活动节点信息
   */
  private async getActivityInfo(processDefId: string, activityId: string): Promise<{ activityId: string; activityName: string } | null> {
    // 从流程定义中获取活动信息
    // 实际实现需要解析 BPMN XML
    return {
      activityId,
      activityName: activityId,
    };
  }

  /**
   * 执行驳回操作
   */
  private async executeReject(
    task: TaskEntity,
    targetActivity: { activityId: string; activityName: string },
    dto: RejectTaskDto
  ): Promise<void> {
    // 使用事务执行驳回
    await this.dataSource.transaction(async (manager) => {
      // 1. 删除当前任务
      await manager.delete(TaskEntity, { id_: task.id_ });

      // 2. 创建新的任务（在目标节点）
      // 实际实现需要调用流程引擎的跳转功能
      // 这里简化处理，发布事件由流程引擎处理
      this.eventBus.emit('process.jump', {
        processInstanceId: task.process_inst_id_,
        executionId: task.execution_id_,
        targetActivityId: targetActivity.activityId,
        variables: {
          rejectReason: dto.reason,
          rejectUserId: dto.userId,
          rejectTime: new Date(),
        },
      });
    });
  }

  /**
   * 查询驳回记录
   */
  async findRejectRecords(processInstanceId: string): Promise<TaskRejectEntity[]> {
    return this.taskRejectRepository.find({
      where: { process_inst_id_: processInstanceId },
      order: { reject_time_: 'DESC' },
    });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}

interface RejectTargetDto {
  activityId: string;
  activityName: string;
  endTime: Date;
}
```

#### 9.1.5 驳回任务 DTO

```typescript
// task/dto/reject-task.dto.ts
import { IsString, IsNotEmpty, IsOptional, IsEnum, IsLength } from 'class-validator';
import { RejectType, RejectStrategy } from '../entities/task-reject.entity';

export class RejectTaskDto {
  @IsString()
  @IsNotEmpty()
  taskId: string;

  @IsString()
  @IsNotEmpty()
  userId: string;

  @IsEnum(RejectType)
  rejectType: RejectType;

  @IsOptional()
  @IsEnum(RejectStrategy)
  rejectStrategy?: RejectStrategy;

  @IsOptional()
  @IsString()
  targetActivityId?: string;

  @IsOptional()
  @IsString()
  @IsLength(0, 2000)
  reason?: string;
}
```

---

### 9.2 抄送模块（CC Module）

#### 9.2.1 模块目录结构

```
src/task/
├── entities/
│   ├── cc-record.entity.ts          # 抄送记录实体
│   └── cc-config.entity.ts          # 抄送配置实体
├── services/
│   └── cc.service.ts                # 抄送服务
├── dto/
│   ├── create-cc.dto.ts             # 创建抄送DTO
│   └── cc-query.dto.ts              # 抄送查询DTO
└── controllers/
    └── cc.controller.ts             # 抄送控制器
```

#### 9.2.2 抄送记录实体

```typescript
// task/entities/cc-record.entity.ts
import { Entity, Column, PrimaryColumn, Index, ManyToOne, JoinColumn } from 'typeorm';

@Entity('act_ru_cc_record')
export class CcRecordEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 64 })
  @Index()
  task_id_: string;

  @Column({ length: 64 })
  @Index()
  process_inst_id_: string;

  @Column({ length: 64, nullable: true })
  process_def_id_: string;

  @Column({ length: 64 })
  @Index()
  cc_user_id_: string;

  @Column({ length: 64 })
  cc_from_user_id_: string;

  @Column({ length: 20 })
  cc_type_: string; // USER / GROUP / ROLE

  @Column({ length: 20 })
  cc_source_: string; // MANUAL / AUTO_TASK / AUTO_PROCESS

  @Column({ type: 'text', nullable: true })
  cc_reason_: string;

  @Column({ length: 20, default: 'UNREAD' })
  status_: string; // UNREAD / READ

  @Column({ type: 'datetime', nullable: true })
  read_time_: Date;

  @Column({ type: 'datetime' })
  create_time_: Date;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;
}

// 抄送类型枚举
export enum CcType {
  USER = 'USER',       // 抄送给指定用户
  GROUP = 'GROUP',     // 抄送给指定组
  ROLE = 'ROLE',       // 抄送给指定角色
}

// 抄送来源枚举
export enum CcSource {
  MANUAL = 'MANUAL',           // 手动抄送
  AUTO_TASK = 'AUTO_TASK',     // 任务自动抄送
  AUTO_PROCESS = 'AUTO_PROCESS', // 流程自动抄送
}

// 抄送状态枚举
export enum CcStatus {
  UNREAD = 'UNREAD',   // 未读
  READ = 'READ',       // 已读
}
```

#### 9.2.3 抄送配置实体

```typescript
// task/entities/cc-config.entity.ts
import { Entity, Column, PrimaryColumn, Index } from 'typeorm';

@Entity('act_re_cc_config')
export class CcConfigEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 64 })
  @Index()
  process_def_id_: string;

  @Column({ length: 64, nullable: true })
  @Index()
  activity_id_: string;

  @Column({ type: 'text' })
  cc_users_: string; // JSON 数组，抄送用户列表

  @Column({ type: 'text', nullable: true })
  cc_condition_: string; // EL 表达式

  @Column({ length: 20, default: CcSource.AUTO_TASK })
  cc_source_: string;

  @Column({ type: 'tinyint', width: 1, default: 1 })
  enabled_: boolean;

  @Column({ length: 64, nullable: true })
  tenant_id_: string;
}
```

#### 9.2.4 抄送服务

```typescript
// task/services/cc.service.ts
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';

import { CcRecordEntity, CcType, CcSource, CcStatus } from '../entities/cc-record.entity';
import { CcConfigEntity } from '../entities/cc-config.entity';
import { TaskEntity } from '../entities/task.entity';
import { EventBusService } from '../../core/services/event-bus.service';
import { CreateCcDto } from '../dto/create-cc.dto';
import { CcQueryDto } from '../dto/cc-query.dto';

@Injectable()
export class CcService {
  constructor(
    @InjectRepository(CcRecordEntity)
    private readonly ccRecordRepository: Repository<CcRecordEntity>,
    @InjectRepository(CcConfigEntity)
    private readonly ccConfigRepository: Repository<CcConfigEntity>,
    @InjectRepository(TaskEntity)
    private readonly taskRepository: Repository<TaskEntity>,
    private readonly eventBus: EventBusService,
  ) {}

  /**
   * 创建抄送
   */
  async createCc(dto: CreateCcDto): Promise<CcRecordEntity[]> {
    // 1. 查询任务信息
    const task = await this.taskRepository.findOne({ where: { id_: dto.taskId } });
    if (!task) {
      throw new NotFoundException('任务不存在');
    }

    // 2. 为每个抄送用户创建记录
    const records: CcRecordEntity[] = [];
    for (const ccUserId of dto.ccUserIds) {
      const record = this.ccRecordRepository.create({
        id_: this.generateUuid(),
        task_id_: task.id_,
        process_inst_id_: task.process_inst_id_,
        process_def_id_: task.process_def_id_,
        cc_user_id_: ccUserId,
        cc_from_user_id_: dto.fromUserId,
        cc_type_: dto.ccType,
        cc_source_: CcSource.MANUAL,
        cc_reason_: dto.reason,
        status_: CcStatus.UNREAD,
        create_time_: new Date(),
        tenant_id_: task.tenant_id_,
      });

      records.push(record);
    }

    // 3. 批量保存
    await this.ccRecordRepository.save(records);

    // 4. 发布事件
    this.eventBus.emit('cc.created', {
      taskId: task.id_,
      processInstanceId: task.process_inst_id_,
      ccUserIds: dto.ccUserIds,
      fromUserId: dto.fromUserId,
      reason: dto.reason,
    });

    return records;
  }

  /**
   * 自动抄送（根据配置）
   */
  async autoCc(taskId: string): Promise<CcRecordEntity[]> {
    const task = await this.taskRepository.findOne({ where: { id_: taskId } });
    if (!task) {
      return [];
    }

    // 查询抄送配置
    const configs = await this.ccConfigRepository.find({
      where: {
        process_def_id_: task.process_def_id_,
        enabled_: true,
      },
    });

    // 过滤匹配当前节点的配置
    const matchedConfigs = configs.filter(config => {
      // 如果配置了活动节点ID，则需要匹配
      if (config.activity_id_ && config.activity_id_ !== task.task_def_key_) {
        return false;
      }
      return true;
    });

    const records: CcRecordEntity[] = [];
    for (const config of matchedConfigs) {
      const ccUsers = JSON.parse(config.cc_users_);
      
      for (const ccUserId of ccUsers) {
        const record = this.ccRecordRepository.create({
          id_: this.generateUuid(),
          task_id_: task.id_,
          process_inst_id_: task.process_inst_id_,
          process_def_id_: task.process_def_id_,
          cc_user_id_: ccUserId,
          cc_from_user_id_: task.assignee_ || 'system',
          cc_type_: CcType.USER,
          cc_source_: config.cc_source_,
          status_: CcStatus.UNREAD,
          create_time_: new Date(),
          tenant_id_: task.tenant_id_,
        });

        records.push(record);
      }
    }

    if (records.length > 0) {
      await this.ccRecordRepository.save(records);
    }

    return records;
  }

  /**
   * 标记抄送为已读
   */
  async markAsRead(ccRecordId: string, userId: string): Promise<void> {
    const record = await this.ccRecordRepository.findOne({ where: { id_: ccRecordId } });
    if (!record) {
      throw new NotFoundException('抄送记录不存在');
    }

    if (record.cc_user_id_ !== userId) {
      throw new BadRequestException('无权操作此抄送记录');
    }

    record.status_ = CcStatus.READ;
    record.read_time_ = new Date();

    await this.ccRecordRepository.save(record);

    this.eventBus.emit('cc.read', {
      ccRecordId,
      userId,
      taskId: record.task_id_,
    });
  }

  /**
   * 查询用户的抄送列表
   */
  async findCcList(query: CcQueryDto): Promise<[CcRecordEntity[], number]> {
    const queryBuilder = this.ccRecordRepository.createQueryBuilder('cc');

    if (query.userId) {
      queryBuilder.andWhere('cc.cc_user_id_ = :userId', { userId: query.userId });
    }

    if (query.status) {
      queryBuilder.andWhere('cc.status_ = :status', { status: query.status });
    }

    if (query.processInstanceId) {
      queryBuilder.andWhere('cc.process_inst_id_ = :processInstanceId', {
        processInstanceId: query.processInstanceId,
      });
    }

    if (query.taskId) {
      queryBuilder.andWhere('cc.task_id_ = :taskId', { taskId: query.taskId });
    }

    queryBuilder
      .skip((query.page - 1) * query.pageSize)
      .take(query.pageSize)
      .orderBy('cc.create_time_', 'DESC');

    return queryBuilder.getManyAndCount();
  }

  /**
   * 查询未读抄送数量
   */
  async getUnreadCount(userId: string): Promise<number> {
    return this.ccRecordRepository.count({
      where: { cc_user_id_: userId, status_: CcStatus.UNREAD },
    });
  }

  /**
   * 删除任务的抄送记录
   */
  async deleteCcByTask(taskId: string): Promise<void> {
    await this.ccRecordRepository.delete({ task_id_: taskId });
  }

  /**
   * 删除流程实例的抄送记录
   */
  async deleteCcByProcessInstance(processInstanceId: string): Promise<void> {
    await this.ccRecordRepository.delete({ process_inst_id_: processInstanceId });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

---

### 9.3 多实例驳回策略模块

#### 9.3.1 多实例配置实体

```typescript
// task/entities/multi-instance-config.entity.ts
import { Entity, Column, PrimaryColumn, Index } from 'typeorm';

@Entity('act_re_multi_instance_config')
export class MultiInstanceConfigEntity {
  @PrimaryColumn({ length: 64 })
  id_: string;

  @Column({ length: 64 })
  @Index()
  process_def_id_: string;

  @Column({ length: 64 })
  @Index()
  activity_id_: string;

  @Column({ length: 255, nullable: true })
  activity_name_: string;

  @Column({ length: 30, default: 'ALL_BACK' })
  mi_reject_strategy_: string; // 多实例驳回策略

  @Column({ type: 'int', nullable: true })
  completion_condition_: string; // 完成条件（百分比）

  @Column({ type: 'tinyint', width: 1, default: 1 })
  sequential_: boolean; // 是否串行

  @Column({ length: 64, nullable: true })
  tenant_id_: string;
}

// 多实例驳回策略枚举
export enum MiRejectStrategy {
  ALL_BACK = 'ALL_BACK',           // 全部退回：所有实例退回到上一节点
  ONLY_CURRENT = 'ONLY_CURRENT',   // 仅当前：只退回当前实例
  MAJORITY_BACK = 'MAJORITY_BACK', // 多数退回：超过半数驳回时全部退回
  KEEP_COMPLETED = 'KEEP_COMPLETED', // 保留已完成：已完成实例保持，新实例重新生成
  RESET_ALL = 'RESET_ALL',         // 重置全部：所有实例重新生成
  WAIT_COMPLETION = 'WAIT_COMPLETION', // 等待完成：当前实例完成后才能退回
  IMMEDIATE = 'IMMEDIATE',         // 立即退回：立即退回，无需等待其他实例
}
```

#### 9.3.2 多实例驳回服务

```typescript
// task/services/multi-instance-reject.service.ts
import { Injectable, NotFoundException, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In, DataSource } from 'typeorm';

import { MultiInstanceConfigEntity, MiRejectStrategy } from '../entities/multi-instance-config.entity';
import { TaskEntity } from '../entities/task.entity';
import { TaskRejectEntity, RejectType } from '../entities/task-reject.entity';
import { EventBusService } from '../../core/services/event-bus.service';
import { TaskService } from './task.service';

@Injectable()
export class MultiInstanceRejectService {
  constructor(
    @InjectRepository(MultiInstanceConfigEntity)
    private readonly miConfigRepository: Repository<MultiInstanceConfigEntity>,
    @InjectRepository(TaskEntity)
    private readonly taskRepository: Repository<TaskEntity>,
    @InjectRepository(TaskRejectEntity)
    private readonly taskRejectRepository: Repository<TaskRejectEntity>,
    private readonly dataSource: DataSource,
    private readonly eventBus: EventBusService,
    private readonly taskService: TaskService,
  ) {}

  /**
   * 处理多实例任务驳回
   */
  async handleMiReject(
    taskId: string,
    userId: string,
    rejectType: RejectType,
    reason?: string
  ): Promise<TaskRejectEntity> {
    // 1. 查询当前任务
    const currentTask = await this.taskRepository.findOne({ where: { id_: taskId } });
    if (!currentTask) {
      throw new NotFoundException('任务不存在');
    }

    // 2. 检查是否是多实例任务
    const siblingTasks = await this.findSiblingTasks(currentTask);
    if (siblingTasks.length <= 1) {
      throw new BadRequestException('不是多实例任务');
    }

    // 3. 获取多实例配置
    const miConfig = await this.getMiConfig(currentTask.process_def_id_, currentTask.task_def_key_);
    const strategy = miConfig?.mi_reject_strategy_ || MiRejectStrategy.ALL_BACK;

    // 4. 根据策略执行驳回
    const rejectRecord = await this.executeMiRejectStrategy(
      currentTask,
      siblingTasks,
      strategy,
      userId,
      rejectType,
      reason
    );

    return rejectRecord;
  }

  /**
   * 执行多实例驳回策略
   */
  private async executeMiRejectStrategy(
    currentTask: TaskEntity,
    siblingTasks: TaskEntity[],
    strategy: string,
    userId: string,
    rejectType: RejectType,
    reason?: string
  ): Promise<TaskRejectEntity> {
    switch (strategy) {
      case MiRejectStrategy.ALL_BACK:
        return this.executeAllBack(currentTask, siblingTasks, userId, rejectType, reason);

      case MiRejectStrategy.ONLY_CURRENT:
        return this.executeOnlyCurrent(currentTask, userId, rejectType, reason);

      case MiRejectStrategy.MAJORITY_BACK:
        return this.executeMajorityBack(currentTask, siblingTasks, userId, rejectType, reason);

      case MiRejectStrategy.KEEP_COMPLETED:
        return this.executeKeepCompleted(currentTask, siblingTasks, userId, rejectType, reason);

      case MiRejectStrategy.RESET_ALL:
        return this.executeResetAll(currentTask, siblingTasks, userId, rejectType, reason);

      case MiRejectStrategy.WAIT_COMPLETION:
        return this.executeWaitCompletion(currentTask, siblingTasks, userId, rejectType, reason);

      case MiRejectStrategy.IMMEDIATE:
        return this.executeImmediate(currentTask, userId, rejectType, reason);

      default:
        return this.executeAllBack(currentTask, siblingTasks, userId, rejectType, reason);
    }
  }

  /**
   * 策略：全部退回
   * 所有实例都退回到上一节点
   */
  private async executeAllBack(
    currentTask: TaskEntity,
    siblingTasks: TaskEntity[],
    userId: string,
    rejectType: RejectType,
    reason?: string
  ): Promise<TaskRejectEntity> {
    await this.dataSource.transaction(async (manager) => {
      // 1. 删除所有同级任务
      const taskIds = siblingTasks.map(t => t.id_);
      await manager.delete(TaskEntity, { id_: In(taskIds) });

      // 2. 发布多实例退回事件
      this.eventBus.emit('mi.reject.all', {
        processInstanceId: currentTask.process_inst_id_,
        executionId: currentTask.execution_id_,
        activityId: currentTask.task_def_key_,
        userId,
        rejectType,
        reason,
        affectedTaskIds: taskIds,
      });
    });

    // 3. 创建驳回记录
    return this.createRejectRecord(currentTask, userId, rejectType, MiRejectStrategy.ALL_BACK, reason);
  }

  /**
   * 策略：仅当前
   * 只退回当前实例，其他实例继续
   */
  private async executeOnlyCurrent(
    currentTask: TaskEntity,
    userId: string,
    rejectType: RejectType,
    reason?: string
  ): Promise<TaskRejectEntity> {
    // 1. 删除当前任务
    await this.taskRepository.delete(currentTask.id_);

    // 2. 发布单个实例退回事件
    this.eventBus.emit('mi.reject.current', {
      taskId: currentTask.id_,
      processInstanceId: currentTask.process_inst_id_,
      executionId: currentTask.execution_id_,
      userId,
      rejectType,
      reason,
    });

    // 3. 创建驳回记录
    return this.createRejectRecord(currentTask, userId, rejectType, MiRejectStrategy.ONLY_CURRENT, reason);
  }

  /**
   * 策略：多数退回
   * 超过半数驳回时全部退回
   */
  private async executeMajorityBack(
    currentTask: TaskEntity,
    siblingTasks: TaskEntity[],
    userId: string,
    rejectType: RejectType,
    reason?: string
  ): Promise<TaskRejectEntity> {
    // 1. 统计已完成和已驳回的任务数量
    const completedCount = siblingTasks.filter(t => t.status_ === 'COMPLETED').length;
    const rejectedCount = await this.countRejectedTasks(siblingTasks.map(t => t.id_));
    const totalCount = siblingTasks.length;

    // 2. 判断是否超过半数
    if (rejectedCount + 1 > totalCount / 2) {
      // 超过半数，执行全部退回
      return this.executeAllBack(currentTask, siblingTasks, userId, rejectType, reason);
    } else {
      // 未超过半数，仅退回当前
      return this.executeOnlyCurrent(currentTask, userId, rejectType, reason);
    }
  }

  /**
   * 策略：保留已完成
   * 已完成的实例保持，新实例重新生成
   */
  private async executeKeepCompleted(
    currentTask: TaskEntity,
    siblingTasks: TaskEntity[],
    userId: string,
    rejectType: RejectType,
    reason?: string
  ): Promise<TaskRejectEntity> {
    // 1. 找出未完成的任务
    const uncompletedTasks = siblingTasks.filter(t => t.status_ !== 'COMPLETED');

    // 2. 删除未完成的任务
    if (uncompletedTasks.length > 0) {
      const taskIds = uncompletedTasks.map(t => t.id_);
      await this.taskRepository.delete({ id_: In(taskIds) });

      // 3. 发布重新生成实例事件
      this.eventBus.emit('mi.reject.regenerate', {
        processInstanceId: currentTask.process_inst_id_,
        executionId: currentTask.execution_id_,
        activityId: currentTask.task_def_key_,
        userId,
        keepCompleted: true,
      });
    }

    // 4. 创建驳回记录
    return this.createRejectRecord(currentTask, userId, rejectType, MiRejectStrategy.KEEP_COMPLETED, reason);
  }

  /**
   * 策略：重置全部
   * 所有实例重新生成
   */
  private async executeResetAll(
    currentTask: TaskEntity,
    siblingTasks: TaskEntity[],
    userId: string,
    rejectType: RejectType,
    reason?: string
  ): Promise<TaskRejectEntity> {
    // 1. 删除所有任务
    const taskIds = siblingTasks.map(t => t.id_);
    await this.taskRepository.delete({ id_: In(taskIds) });

    // 2. 发布重新生成全部实例事件
    this.eventBus.emit('mi.reject.reset', {
      processInstanceId: currentTask.process_inst_id_,
      executionId: currentTask.execution_id_,
      activityId: currentTask.task_def_key_,
      userId,
      resetAll: true,
    });

    // 3. 创建驳回记录
    return this.createRejectRecord(currentTask, userId, rejectType, MiRejectStrategy.RESET_ALL, reason);
  }

  /**
   * 策略：等待完成
   * 当前实例完成后才能退回
   */
  private async executeWaitCompletion(
    currentTask: TaskEntity,
    siblingTasks: TaskEntity[],
    userId: string,
    rejectType: RejectType,
    reason?: string
  ): Promise<TaskRejectEntity> {
    // 1. 检查是否所有实例都已完成
    const allCompleted = siblingTasks.every(t => t.status_ === 'COMPLETED');

    if (!allCompleted) {
      throw new BadRequestException('需要等待所有实例完成后才能驳回');
    }

    // 2. 所有实例已完成，执行全部退回
    return this.executeAllBack(currentTask, siblingTasks, userId, rejectType, reason);
  }

  /**
   * 策略：立即退回
   * 立即退回，无需等待其他实例
   */
  private async executeImmediate(
    currentTask: TaskEntity,
    userId: string,
    rejectType: RejectType,
    reason?: string
  ): Promise<TaskRejectEntity> {
    // 立即退回当前实例
    return this.executeOnlyCurrent(currentTask, userId, rejectType, reason);
  }

  /**
   * 查找同级任务
   */
  private async findSiblingTasks(task: TaskEntity): Promise<TaskEntity[]> {
    return this.taskRepository.find({
      where: {
        process_inst_id_: task.process_inst_id_,
        task_def_key_: task.task_def_key_,
      },
    });
  }

  /**
   * 获取多实例配置
   */
  private async getMiConfig(processDefId: string, activityId: string): Promise<MultiInstanceConfigEntity | null> {
    return this.miConfigRepository.findOne({
      where: { process_def_id_: processDefId, activity_id_: activityId },
    });
  }

  /**
   * 统计已驳回的任务数量
   */
  private async countRejectedTasks(taskIds: string[]): Promise<number> {
    return this.taskRejectRepository.count({
      where: { task_id_: In(taskIds) },
    });
  }

  /**
   * 创建驳回记录
   */
  private async createRejectRecord(
    task: TaskEntity,
    userId: string,
    rejectType: RejectType,
    strategy: string,
    reason?: string
  ): Promise<TaskRejectEntity> {
    const record = this.taskRejectRepository.create({
      id_: this.generateUuid(),
      task_id_: task.id_,
      process_inst_id_: task.process_inst_id_,
      execution_id_: task.execution_id_,
      process_def_id_: task.process_def_id_,
      reject_type_: rejectType,
      reject_strategy_: strategy,
      reject_user_id_: userId,
      reject_reason_: reason,
      reject_time_: new Date(),
      tenant_id_: task.tenant_id_,
    });

    return this.taskRejectRepository.save(record);
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

---

### 9.4 任务模块更新

需要更新任务模块以包含新的实体和服务：

```typescript
// task/task.module.ts
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';

import { TaskController } from './controllers/task.controller';
import { TaskRejectController } from './controllers/task-reject.controller';
import { CcController } from './controllers/cc.controller';

import { TaskService } from './services/task.service';
import { TaskRejectService } from './services/task-reject.service';
import { MultiInstanceRejectService } from './services/multi-instance-reject.service';
import { CcService } from './services/cc.service';
import { TaskListenerService } from './services/task-listener.service';

import { TaskEntity } from './entities/task.entity';
import { TaskCandidateUserEntity } from './entities/task-candidate-user.entity';
import { TaskCandidateGroupEntity } from './entities/task-candidate-group.entity';
import { TaskRejectEntity } from './entities/task-reject.entity';
import { RejectConfigEntity } from './entities/reject-config.entity';
import { CcRecordEntity } from './entities/cc-record.entity';
import { CcConfigEntity } from './entities/cc-config.entity';
import { MultiInstanceConfigEntity } from './entities/multi-instance-config.entity';

@Module({
  imports: [
    TypeOrmModule.forFeature([
      TaskEntity,
      TaskCandidateUserEntity,
      TaskCandidateGroupEntity,
      TaskRejectEntity,
      RejectConfigEntity,
      CcRecordEntity,
      CcConfigEntity,
      MultiInstanceConfigEntity,
    ]),
  ],
  controllers: [
    TaskController,
    TaskRejectController,
    CcController,
  ],
  providers: [
    TaskService,
    TaskRejectService,
    MultiInstanceRejectService,
    CcService,
    TaskListenerService,
  ],
  exports: [
    TaskService,
    TaskRejectService,
    MultiInstanceRejectService,
    CcService,
  ],
})
export class TaskModule {}
```

---

### 9.5 API 接口设计

#### 9.5.1 任务驳回控制器

```typescript
// task/controllers/task-reject.controller.ts
import { Controller, Post, Get, Body, Param, Query, UseGuards } from '@nestjs/common';

import { TaskRejectService } from '../services/task-reject.service';
import { MultiInstanceRejectService } from '../services/multi-instance-reject.service';
import { RejectTaskDto } from '../dto/reject-task.dto';
import { PermissionsGuard } from '../../identity/guards/permissions.guard';
import { Permissions } from '../../identity/decorators/permissions.decorator';

@Controller('api/v1')
@UseGuards(PermissionsGuard)
export class TaskRejectController {
  constructor(
    private readonly taskRejectService: TaskRejectService,
    private readonly miRejectService: MultiInstanceRejectService,
  ) {}

  /**
   * 驳回任务
   * POST /api/v1/tasks/:id/reject
   */
  @Post('tasks/:id/reject')
  @Permissions('task:reject')
  async rejectTask(
    @Param('id') taskId: string,
    @Body() dto: RejectTaskDto,
  ) {
    dto.taskId = taskId;
    const result = await this.taskRejectService.rejectTask(dto);
    return {
      code: 200,
      message: '驳回成功',
      data: result,
    };
  }

  /**
   * 获取可退回节点列表
   * GET /api/v1/tasks/:id/reject-targets
   */
  @Get('tasks/:id/reject-targets')
  @Permissions('task:view')
  async getRejectTargets(@Param('id') taskId: string) {
    const targets = await this.taskRejectService.getRejectTargets(taskId);
    return {
      code: 200,
      message: '查询成功',
      data: targets,
    };
  }

  /**
   * 查询驳回记录
   * GET /api/v1/process-instances/:id/reject-records
   */
  @Get('process-instances/:id/reject-records')
  @Permissions('process:view')
  async getRejectRecords(@Param('id') processInstanceId: string) {
    const records = await this.taskRejectService.findRejectRecords(processInstanceId);
    return {
      code: 200,
      message: '查询成功',
      data: records,
    };
  }
}
```

#### 9.5.2 抄送控制器

```typescript
// task/controllers/cc.controller.ts
import { Controller, Post, Get, Put, Body, Param, Query, UseGuards } from '@nestjs/common';

import { CcService } from '../services/cc.service';
import { CreateCcDto } from '../dto/create-cc.dto';
import { CcQueryDto } from '../dto/cc-query.dto';
import { PermissionsGuard } from '../../identity/guards/permissions.guard';
import { Permissions } from '../../identity/decorators/permissions.decorator';
import { CurrentUser } from '../../identity/decorators/current-user.decorator';

@Controller('api/v1')
@UseGuards(PermissionsGuard)
export class CcController {
  constructor(private readonly ccService: CcService) {}

  /**
   * 创建抄送
   * POST /api/v1/tasks/:id/cc
   */
  @Post('tasks/:id/cc')
  @Permissions('task:cc')
  async createCc(
    @Param('id') taskId: string,
    @Body() dto: CreateCcDto,
    @CurrentUser() currentUser: any,
  ) {
    dto.taskId = taskId;
    dto.fromUserId = currentUser.id;
    const result = await this.ccService.createCc(dto);
    return {
      code: 200,
      message: '抄送成功',
      data: result,
    };
  }

  /**
   * 查询我的抄送列表
   * GET /api/v1/cc/my
   */
  @Get('cc/my')
  @Permissions('cc:view')
  async getMyCcList(
    @Query() query: CcQueryDto,
    @CurrentUser() currentUser: any,
  ) {
    query.userId = currentUser.id;
    const [list, total] = await this.ccService.findCcList(query);
    return {
      code: 200,
      message: '查询成功',
      data: { list, total },
    };
  }

  /**
   * 标记抄送为已读
   * PUT /api/v1/cc/:id/read
   */
  @Put('cc/:id/read')
  @Permissions('cc:read')
  async markAsRead(
    @Param('id') ccRecordId: string,
    @CurrentUser() currentUser: any,
  ) {
    await this.ccService.markAsRead(ccRecordId, currentUser.id);
    return {
      code: 200,
      message: '标记成功',
    };
  }

  /**
   * 获取未读抄送数量
   * GET /api/v1/cc/unread-count
   */
  @Get('cc/unread-count')
  @Permissions('cc:view')
  async getUnreadCount(@CurrentUser() currentUser: any) {
    const count = await this.ccService.getUnreadCount(currentUser.id);
    return {
      code: 200,
      message: '查询成功',
      data: { count },
    };
  }
}
```

---

## 十、总结

本章节补充了任务操作模块的完整实现设计，包括：

1. **任务驳回模块**：支持退回、驳回、拒绝三种操作，支持多种驳回策略
2. **抄送模块**：支持手动抄送和自动抄送，支持用户、组、角色三种抄送类型
3. **多实例驳回策略**：支持全部退回、仅当前、多数退回、保留已完成、重置全部、等待完成、立即退回七种策略

这些模块与现有的任务模块、流程实例模块紧密集成，通过事件总线实现解耦，确保系统的可扩展性和可维护性。
