# Flowable 任务操作补充设计文档

## 文档说明

本文档补充设计 Flowable 流程引擎中任务操作的核心功能，包括：
- 驳回操作功能设计
- 抄送操作功能设计
- 退回策略设计
- 相同步骤多人的退回策略设计

---

## 一、驳回操作功能设计

### 1.1 驳回与退回的区别

| 操作类型 | 定义 | 使用场景 | 目标节点 |
|---------|------|---------|---------|
| **退回 (Rollback)** | 将流程退回到指定的历史节点 | 审批不通过，需要重新审批 | 任意已执行过的节点 |
| **驳回 (Reject)** | 将流程直接驳回到流程发起人 | 申请不符合要求，需要重新填写 | 流程发起节点 |
| **拒绝 (Deny)** | 直接终止流程实例 | 申请被完全拒绝 | 流程结束（终止状态） |

### 1.2 驳回操作数据模型

#### 1.2.1 驳回记录实体

```typescript
// task/entities/task-reject.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('task_reject')
export class TaskReject extends BaseEntity {
  @Column({ name: 'task_id', length: 64 })
  @Index()
  taskId: string;

  @Column({ name: 'process_instance_id', length: 64 })
  @Index()
  processInstanceId: string;

  @Column({ name: 'reject_from_activity_id', length: 64 })
  rejectFromActivityId: string;

  @Column({ name: 'reject_from_activity_name', length: 128, nullable: true })
  rejectFromActivityName: string;

  @Column({ name: 'reject_to_activity_id', length: 64 })
  rejectToActivityId: string;

  @Column({ name: 'reject_to_activity_name', length: 128, nullable: true })
  rejectToActivityName: string;

  @Column({ name: 'reject_type', length: 20, type: 'enum', enum: RejectType })
  rejectType: RejectType;

  @Column({ name: 'reason', type: 'text', nullable: true })
  reason: string;

  @Column({ name: 'operator_id', length: 64 })
  operatorId: string;

  @Column({ name: 'operator_name', length: 64, nullable: true })
  operatorName: string;

  @Column({ name: 'create_time', type: 'datetime' })
  createTime: Date;
}

export enum RejectType {
  ROLLBACK = 'ROLLBACK',     // 退回到指定节点
  REJECT = 'REJECT',         // 驳回到发起人
  DENY = 'DENY',             // 拒绝（终止流程）
}
```

#### 1.2.2 驳回配置实体

```typescript
// process-definition/entities/reject-config.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';
import { ProcessDefinition } from './process-definition.entity';

@Entity('reject_config')
export class RejectConfig extends BaseEntity {
  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @ManyToOne(() => ProcessDefinition, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'process_definition_id' })
  processDefinition: ProcessDefinition;

  @Column({ name: 'activity_id', length: 64 })
  @Index()
  activityId: string;

  @Column({ name: 'activity_name', length: 128, nullable: true })
  activityName: string;

  @Column({ name: 'reject_strategy', length: 20, type: 'enum', enum: RejectStrategy })
  rejectStrategy: RejectStrategy;

  @Column({ name: 'target_activity_id', length: 64, nullable: true })
  targetActivityId: string;

  @Column({ name: 'allow_custom_target', type: 'tinyint', width: 1, default: 0 })
  allowCustomTarget: boolean;

  @Column({ name: 'require_reason', type: 'tinyint', width: 1, default: 1 })
  requireReason: boolean;

  @Column({ name: 'notify_starter', type: 'tinyint', width: 1, default: 1 })
  notifyStarter: boolean;

  @Column({ name: 'notify_participants', type: 'tinyint', width: 1, default: 0 })
  notifyParticipants: boolean;
}

export enum RejectStrategy {
  TO_PREVIOUS = 'TO_PREVIOUS',       // 退回到上一节点
  TO_STARTER = 'TO_STARTER',         // 驳回到发起人
  TO_SPECIFIC = 'TO_SPECIFIC',       // 退回到指定节点
  TO_ANY_HISTORY = 'TO_ANY_HISTORY', // 可退回到任意历史节点
  NOT_ALLOWED = 'NOT_ALLOWED',       // 不允许退回
}
```

### 1.3 驳回服务实现

```typescript
// task/services/task-reject.service.ts
import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, QueryRunner } from 'typeorm';

import { Task } from '../entities/task.entity';
import { TaskReject, RejectType } from '../entities/task-reject.entity';
import { RejectConfig, RejectStrategy } from '../../process-definition/entities/reject-config.entity';
import { ProcessInstance } from '../../process-instance/entities/process-instance.entity';
import { Execution } from '../../process-instance/entities/execution.entity';
import { HistoryService } from '../../history/services/history.service';
import { EventBusService } from '../../core/services/event-bus.service';
import { TaskService } from './task.service';

export interface RejectTaskDto {
  taskId: string;
  userId: string;
  rejectType: RejectType;
  targetActivityId?: string;
  reason: string;
}

@Injectable()
export class TaskRejectService {
  constructor(
    @InjectRepository(Task)
    private readonly taskRepository: Repository<Task>,
    @InjectRepository(TaskReject)
    private readonly taskRejectRepository: Repository<TaskReject>,
    @InjectRepository(RejectConfig)
    private readonly rejectConfigRepository: Repository<RejectConfig>,
    @InjectRepository(ProcessInstance)
    private readonly processInstanceRepository: Repository<ProcessInstance>,
    @InjectRepository(Execution)
    private readonly executionRepository: Repository<Execution>,
    private readonly historyService: HistoryService,
    private readonly taskService: TaskService,
    private readonly eventBus: EventBusService,
    private readonly dataSource: DataSource,
  ) {}

  /**
   * 驳回任务
   */
  async rejectTask(dto: RejectTaskDto): Promise<Task> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // 1. 获取当前任务
      const currentTask = await this.taskRepository.findOne({
        where: { id: dto.taskId },
        relations: ['processInstance'],
      });

      if (!currentTask) {
        throw new NotFoundException('任务不存在');
      }

      if (currentTask.status !== 'CREATED' && currentTask.status !== 'CLAIMED') {
        throw new BadRequestException('任务状态不允许驳回');
      }

      // 2. 获取驳回配置
      const rejectConfig = await this.getRejectConfig(
        currentTask.processDefinitionId,
        currentTask.taskDefinitionKey,
      );

      // 3. 确定驳回目标
      const targetActivityId = await this.determineRejectTarget(
        dto,
        rejectConfig,
        currentTask,
      );

      // 4. 执行驳回操作
      let newTask: Task;

      switch (dto.rejectType) {
        case RejectType.ROLLBACK:
          newTask = await this.executeRollback(currentTask, targetActivityId, dto, queryRunner);
          break;
        case RejectType.REJECT:
          newTask = await this.executeReject(currentTask, dto, queryRunner);
          break;
        case RejectType.DENY:
          await this.executeDeny(currentTask, dto, queryRunner);
          return null;
        default:
          throw new BadRequestException('不支持的驳回类型');
      }

      // 5. 记录驳回历史
      await this.recordRejectHistory(currentTask, targetActivityId, dto, queryRunner);

      // 6. 发送通知
      await this.sendRejectNotification(currentTask, newTask, dto, rejectConfig);

      await queryRunner.commitTransaction();

      // 7. 发布事件
      this.eventBus.emit('task.rejected', {
        taskId: dto.taskId,
        processInstanceId: currentTask.processInstanceId,
        rejectType: dto.rejectType,
        targetActivityId,
        reason: dto.reason,
        operatorId: dto.userId,
      });

      return newTask;
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  /**
   * 获取驳回配置
   */
  private async getRejectConfig(
    processDefinitionId: string,
    activityId: string,
  ): Promise<RejectConfig | null> {
    return this.rejectConfigRepository.findOne({
      where: {
        processDefinitionId,
        activityId,
      },
    });
  }

  /**
   * 确定驳回目标节点
   */
  private async determineRejectTarget(
    dto: RejectTaskDto,
    config: RejectConfig | null,
    currentTask: Task,
  ): Promise<string> {
    // 如果指定了目标节点
    if (dto.targetActivityId) {
      // 检查是否允许自定义目标
      if (config && !config.allowCustomTarget && config.rejectStrategy !== RejectStrategy.TO_ANY_HISTORY) {
        throw new BadRequestException('该节点不允许自定义退回目标');
      }

      // 验证目标节点是否在历史中
      const historyActivities = await this.historyService.getHistoricActivities(
        currentTask.processInstanceId,
      );
      const isValidTarget = historyActivities.some(a => a.activityId === dto.targetActivityId);
      
      if (!isValidTarget) {
        throw new BadRequestException('目标节点不在流程历史中');
      }

      return dto.targetActivityId;
    }

    // 根据配置确定目标
    if (!config) {
      // 默认退回到上一节点
      return this.getPreviousActivityId(currentTask);
    }

    switch (config.rejectStrategy) {
      case RejectStrategy.TO_PREVIOUS:
        return this.getPreviousActivityId(currentTask);
      case RejectStrategy.TO_STARTER:
        return this.getStarterActivityId(currentTask);
      case RejectStrategy.TO_SPECIFIC:
        return config.targetActivityId;
      case RejectStrategy.TO_ANY_HISTORY:
        throw new BadRequestException('请指定退回目标节点');
      case RejectStrategy.NOT_ALLOWED:
        throw new BadRequestException('该节点不允许退回');
      default:
        return this.getPreviousActivityId(currentTask);
    }
  }

  /**
   * 执行退回操作
   */
  private async executeRollback(
    currentTask: Task,
    targetActivityId: string,
    dto: RejectTaskDto,
    queryRunner: QueryRunner,
  ): Promise<Task> {
    // 1. 删除当前任务
    await queryRunner.manager.delete(Task, currentTask.id);

    // 2. 删除当前执行实例
    await queryRunner.manager.delete(Execution, currentTask.executionId);

    // 3. 获取目标活动的执行上下文
    const historyExecution = await this.historyService.getHistoricExecution(
      currentTask.processInstanceId,
      targetActivityId,
    );

    // 4. 创建新的执行实例
    const newExecution = queryRunner.manager.create(Execution, {
      id: this.generateUuid(),
      processInstanceId: currentTask.processInstanceId,
      processDefinitionId: currentTask.processDefinitionId,
      activityId: targetActivityId,
      isActive: true,
      isConcurrent: false,
      parentId: historyExecution?.parentId || null,
    });
    await queryRunner.manager.save(newExecution);

    // 5. 创建新任务
    const newTask = queryRunner.manager.create(Task, {
      id: this.generateUuid(),
      processInstanceId: currentTask.processInstanceId,
      processDefinitionId: currentTask.processDefinitionId,
      executionId: newExecution.id,
      taskDefinitionKey: targetActivityId,
      name: currentTask.name,
      status: 'CREATED',
      assignee: historyExecution?.assignee || null,
      variables: currentTask.variables,
      createTime: new Date(),
    });
    await queryRunner.manager.save(newTask);

    return newTask;
  }

  /**
   * 执行驳回操作（驳回到发起人）
   */
  private async executeReject(
    currentTask: Task,
    dto: RejectTaskDto,
    queryRunner: QueryRunner,
  ): Promise<Task> {
    // 获取流程发起人
    const processInstance = await this.processInstanceRepository.findOne({
      where: { id: currentTask.processInstanceId },
    });

    const starterActivityId = await this.getStarterActivityId(currentTask);

    // 调用退回逻辑
    return this.executeRollback(currentTask, starterActivityId, dto, queryRunner);
  }

  /**
   * 执行拒绝操作（终止流程）
   */
  private async executeDeny(
    currentTask: Task,
    dto: RejectTaskDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 删除所有活动任务
    await queryRunner.manager.delete(Task, { processInstanceId: currentTask.processInstanceId });

    // 2. 删除所有执行实例
    await queryRunner.manager.delete(Execution, { processInstanceId: currentTask.processInstanceId });

    // 3. 更新流程实例状态
    await queryRunner.manager.update(
      ProcessInstance,
      currentTask.processInstanceId,
      {
        status: 'TERMINATED',
        endTime: new Date(),
        deleteReason: dto.reason,
      },
    );

    // 4. 归档历史数据
    await this.historyService.archiveProcessInstance(
      currentTask.processInstanceId,
      'TERMINATED',
      dto.reason,
      queryRunner,
    );
  }

  /**
   * 获取上一节点ID
   */
  private async getPreviousActivityId(currentTask: Task): Promise<string> {
    const historyActivities = await this.historyService.getHistoricActivities(
      currentTask.processInstanceId,
    );
    
    const currentIndex = historyActivities.findIndex(
      a => a.activityId === currentTask.taskDefinitionKey,
    );
    
    if (currentIndex > 0) {
      return historyActivities[currentIndex - 1].activityId;
    }
    
    throw new BadRequestException('无法确定上一节点');
  }

  /**
   * 获取发起人节点ID
   */
  private async getStarterActivityId(currentTask: Task): Promise<string> {
    const historyActivities = await this.historyService.getHistoricActivities(
      currentTask.processInstanceId,
    );
    
    // 返回第一个用户任务节点
    const firstUserTask = historyActivities.find(a => a.activityType === 'userTask');
    return firstUserTask?.activityId || historyActivities[0]?.activityId;
  }

  /**
   * 记录驳回历史
   */
  private async recordRejectHistory(
    currentTask: Task,
    targetActivityId: string,
    dto: RejectTaskDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    const rejectRecord = queryRunner.manager.create(TaskReject, {
      id: this.generateUuid(),
      taskId: currentTask.id,
      processInstanceId: currentTask.processInstanceId,
      rejectFromActivityId: currentTask.taskDefinitionKey,
      rejectFromActivityName: currentTask.name,
      rejectToActivityId: targetActivityId,
      rejectType: dto.rejectType,
      reason: dto.reason,
      operatorId: dto.userId,
      createTime: new Date(),
    });
    await queryRunner.manager.save(rejectRecord);
  }

  /**
   * 发送驳回通知
   */
  private async sendRejectNotification(
    currentTask: Task,
    newTask: Task | null,
    dto: RejectTaskDto,
    config: RejectConfig | null,
  ): Promise<void> {
    if (config?.notifyStarter) {
      const processInstance = await this.processInstanceRepository.findOne({
        where: { id: currentTask.processInstanceId },
      });

      this.eventBus.emit('notification.reject', {
        recipientId: processInstance?.startUserId,
        type: 'REJECT',
        taskId: currentTask.id,
        processInstanceId: currentTask.processInstanceId,
        reason: dto.reason,
      });
    }

    if (newTask && newTask.assignee) {
      this.eventBus.emit('notification.task.assigned', {
        recipientId: newTask.assignee,
        taskId: newTask.id,
        processInstanceId: newTask.processInstanceId,
        message: `任务已退回，请重新处理`,
      });
    }
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

### 1.4 驳回 API 设计

```typescript
// task/dto/reject-task.dto.ts
import { IsEnum, IsNotEmpty, IsOptional, IsString, MaxLength } from 'class-validator';
import { RejectType } from '../entities/task-reject.entity';

export class RejectTaskDto {
  @IsString()
  @IsNotEmpty()
  userId: string;

  @IsEnum(RejectType)
  rejectType: RejectType;

  @IsString()
  @IsOptional()
  targetActivityId?: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(2000)
  reason: string;
}

// task/controllers/task.controller.ts
@Controller('api/v1/tasks')
export class TaskController {
  constructor(
    private readonly taskRejectService: TaskRejectService,
  ) {}

  /**
   * 驳回任务
   * POST /api/v1/tasks/:id/reject
   */
  @Post(':id/reject')
  async rejectTask(
    @Param('id') taskId: string,
    @Body() dto: RejectTaskDto,
  ) {
    return this.taskRejectService.rejectTask({
      taskId,
      ...dto,
    });
  }

  /**
   * 获取可退回的节点列表
   * GET /api/v1/tasks/:id/reject-targets
   */
  @Get(':id/reject-targets')
  async getRejectTargets(@Param('id') taskId: string) {
    return this.taskRejectService.getRejectTargets(taskId);
  }

  /**
   * 获取驳回历史
   * GET /api/v1/tasks/:id/reject-history
   */
  @Get(':id/reject-history')
  async getRejectHistory(@Param('id') taskId: string) {
    return this.taskRejectService.getRejectHistory(taskId);
  }
}
```

---

## 二、抄送操作功能设计

### 2.1 抄送概念定义

**抄送 (CC - Carbon Copy)**：在流程流转过程中，将流程信息同步发送给非流程参与者，抄送对象无需对流程进行审批，仅作信息通知。

**使用场景**：
- 知会相关人员流程进展
- 备案存档
- 信息共享

### 2.2 抄送数据模型

#### 2.2.1 抄送记录实体

```typescript
// cc/entities/cc-record.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('cc_record')
export class CcRecord extends BaseEntity {
  @Column({ name: 'process_instance_id', length: 64 })
  @Index()
  processInstanceId: string;

  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @Column({ name: 'task_id', length: 64, nullable: true })
  @Index()
  taskId: string;

  @Column({ name: 'activity_id', length: 64, nullable: true })
  activityId: string;

  @Column({ name: 'activity_name', length: 128, nullable: true })
  activityName: string;

  @Column({ name: 'cc_user_id', length: 64 })
  @Index()
  ccUserId: string;

  @Column({ name: 'cc_user_name', length: 64, nullable: true })
  ccUserName: string;

  @Column({ name: 'cc_type', length: 20, type: 'enum', enum: CcType })
  ccType: CcType;

  @Column({ name: 'cc_source', length: 20, type: 'enum', enum: CcSource })
  ccSource: CcSource;

  @Column({ name: 'sender_id', length: 64 })
  senderId: string;

  @Column({ name: 'sender_name', length: 64, nullable: true })
  senderName: string;

  @Column({ name: 'message', type: 'text', nullable: true })
  message: string;

  @Column({ name: 'status', length: 20, type: 'enum', enum: CcStatus, default: CcStatus.UNREAD })
  status: CcStatus;

  @Column({ name: 'read_time', type: 'datetime', nullable: true })
  readTime: Date;

  @Column({ name: 'business_key', length: 64, nullable: true })
  @Index()
  businessKey: string;

  @Column({ name: 'tenant_id', length: 64, nullable: true })
  tenantId: string;

  @Column({ name: 'create_time', type: 'datetime' })
  createTime: Date;
}

export enum CcType {
  USER = 'USER',       // 抄送给用户
  GROUP = 'GROUP',     // 抄送给组
  ROLE = 'ROLE',       // 抄送给角色
}

export enum CcSource {
  MANUAL = 'MANUAL',           // 手动抄送
  AUTO_TASK = 'AUTO_TASK',     // 任务节点自动抄送
  AUTO_PROCESS = 'AUTO_PROCESS', // 流程启动自动抄送
}

export enum CcStatus {
  UNREAD = 'UNREAD',   // 未读
  READ = 'READ',       // 已读
}
```

#### 2.2.2 抄送配置实体

```typescript
// process-definition/entities/cc-config.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';
import { ProcessDefinition } from './process-definition.entity';

@Entity('cc_config')
export class CcConfig extends BaseEntity {
  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @ManyToOne(() => ProcessDefinition, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'process_definition_id' })
  processDefinition: ProcessDefinition;

  @Column({ name: 'activity_id', length: 64, nullable: true })
  @Index()
  activityId: string;

  @Column({ name: 'activity_name', length: 128, nullable: true })
  activityName: string;

  @Column({ name: 'cc_type', length: 20, type: 'enum', enum: CcType })
  ccType: CcType;

  @Column({ name: 'cc_target', type: 'text' })
  ccTarget: string; // JSON 数组，存储用户ID/组ID/角色ID

  @Column({ name: 'cc_source', length: 20, type: 'enum', enum: CcSource })
  ccSource: CcSource;

  @Column({ name: 'trigger_event', length: 20, type: 'enum', enum: CcTriggerEvent })
  triggerEvent: CcTriggerEvent;

  @Column({ name: 'message_template', length: 500, nullable: true })
  messageTemplate: string;

  @Column({ name: 'is_active', type: 'tinyint', width: 1, default: 1 })
  isActive: boolean;
}

export enum CcTriggerEvent {
  TASK_CREATED = 'TASK_CREATED',     // 任务创建时
  TASK_COMPLETED = 'TASK_COMPLETED', // 任务完成时
  PROCESS_STARTED = 'PROCESS_STARTED', // 流程启动时
  PROCESS_ENDED = 'PROCESS_ENDED',   // 流程结束时
}
```

### 2.3 抄送服务实现

```typescript
// cc/services/cc.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';

import { CcRecord, CcType, CcSource, CcStatus } from '../entities/cc-record.entity';
import { CcConfig, CcTriggerEvent } from '../../process-definition/entities/cc-config.entity';
import { ProcessInstance } from '../../process-instance/entities/process-instance.entity';
import { Task } from '../../task/entities/task.entity';
import { EventBusService } from '../../core/services/event-bus.service';
import { IdentityService } from '../../identity/services/identity.service';

export interface CreateCcDto {
  processInstanceId: string;
  taskId?: string;
  activityId?: string;
  activityName?: string;
  ccType: CcType;
  ccTarget: string | string[];
  ccSource: CcSource;
  senderId: string;
  senderName?: string;
  message?: string;
}

export interface CcQueryDto {
  userId?: string;
  processInstanceId?: string;
  taskId?: string;
  status?: CcStatus;
  page?: number;
  pageSize?: number;
}

@Injectable()
export class CcService {
  constructor(
    @InjectRepository(CcRecord)
    private readonly ccRecordRepository: Repository<CcRecord>,
    @InjectRepository(CcConfig)
    private readonly ccConfigRepository: Repository<CcConfig>,
    @InjectRepository(ProcessInstance)
    private readonly processInstanceRepository: Repository<ProcessInstance>,
    @InjectRepository(Task)
    private readonly taskRepository: Repository<Task>,
    private readonly identityService: IdentityService,
    private readonly eventBus: EventBusService,
  ) {}

  /**
   * 创建抄送记录
   */
  async createCc(dto: CreateCcDto): Promise<CcRecord[]> {
    const processInstance = await this.processInstanceRepository.findOne({
      where: { id: dto.processInstanceId },
    });

    if (!processInstance) {
      throw new NotFoundException('流程实例不存在');
    }

    // 解析抄送目标
    const targets = Array.isArray(dto.ccTarget) ? dto.ccTarget : [dto.ccTarget];
    const ccRecords: CcRecord[] = [];

    for (const target of targets) {
      // 获取目标用户列表
      const userIds = await this.resolveCcTargets(dto.ccType, target);

      for (const userId of userIds) {
        const user = await this.identityService.findUserById(userId);
        
        const ccRecord = this.ccRecordRepository.create({
          id: this.generateUuid(),
          processInstanceId: dto.processInstanceId,
          processDefinitionId: processInstance.processDefinitionId,
          taskId: dto.taskId || null,
          activityId: dto.activityId || null,
          activityName: dto.activityName || null,
          ccUserId: userId,
          ccUserName: user?.realName || user?.username || null,
          ccType: dto.ccType,
          ccSource: dto.ccSource,
          senderId: dto.senderId,
          senderName: dto.senderName || null,
          message: dto.message || null,
          status: CcStatus.UNREAD,
          businessKey: processInstance.businessKey || null,
          createTime: new Date(),
        });

        ccRecords.push(await this.ccRecordRepository.save(ccRecord));
      }
    }

    // 发送通知
    this.eventBus.emit('cc.created', {
      processInstanceId: dto.processInstanceId,
      ccRecords,
      senderId: dto.senderId,
    });

    return ccRecords;
  }

  /**
   * 解析抄送目标为用户ID列表
   */
  private async resolveCcTargets(ccType: CcType, target: string): Promise<string[]> {
    switch (ccType) {
      case CcType.USER:
        return [target];
      case CcType.GROUP:
        const groupUsers = await this.identityService.findUsersByGroup(target);
        return groupUsers.map(u => u.id);
      case CcType.ROLE:
        const roleUsers = await this.identityService.findUsersByRole(target);
        return roleUsers.map(u => u.id);
      default:
        return [];
    }
  }

  /**
   * 处理自动抄送
   */
  async processAutoCc(
    processInstanceId: string,
    triggerEvent: CcTriggerEvent,
    taskId?: string,
  ): Promise<void> {
    const processInstance = await this.processInstanceRepository.findOne({
      where: { id: processInstanceId },
    });

    if (!processInstance) return;

    // 查找适用的抄送配置
    const configs = await this.ccConfigRepository.find({
      where: {
        processDefinitionId: processInstance.processDefinitionId,
        triggerEvent,
        isActive: true,
      },
    });

    for (const config of configs) {
      const targets = JSON.parse(config.ccTarget);
      
      await this.createCc({
        processInstanceId,
        taskId,
        activityId: config.activityId || undefined,
        activityName: config.activityName || undefined,
        ccType: config.ccType,
        ccTarget: targets,
        ccSource: config.ccSource,
        senderId: 'SYSTEM',
        senderName: '系统',
        message: this.renderMessageTemplate(config.messageTemplate, processInstance),
      });
    }
  }

  /**
   * 渲染消息模板
   */
  private renderMessageTemplate(
    template: string | null,
    processInstance: ProcessInstance,
  ): string | null {
    if (!template) return null;

    return template
      .replace('${processName}', processInstance.name || '')
      .replace('${businessKey}', processInstance.businessKey || '')
      .replace('${startTime}', processInstance.startTime?.toISOString() || '');
  }

  /**
   * 查询我的抄送列表
   */
  async findMyCcList(dto: CcQueryDto): Promise<[CcRecord[], number]> {
    const queryBuilder = this.ccRecordRepository.createQueryBuilder('cc');

    if (dto.userId) {
      queryBuilder.andWhere('cc.cc_user_id = :userId', { userId: dto.userId });
    }

    if (dto.processInstanceId) {
      queryBuilder.andWhere('cc.process_instance_id = :processInstanceId', {
        processInstanceId: dto.processInstanceId,
      });
    }

    if (dto.taskId) {
      queryBuilder.andWhere('cc.task_id = :taskId', { taskId: dto.taskId });
    }

    if (dto.status) {
      queryBuilder.andWhere('cc.status = :status', { status: dto.status });
    }

    const page = dto.page || 1;
    const pageSize = dto.pageSize || 20;

    queryBuilder
      .skip((page - 1) * pageSize)
      .take(pageSize)
      .orderBy('cc.create_time', 'DESC');

    return queryBuilder.getManyAndCount();
  }

  /**
   * 标记抄送为已读
   */
  async markAsRead(ccId: string, userId: string): Promise<void> {
    const ccRecord = await this.ccRecordRepository.findOne({
      where: { id: ccId },
    });

    if (!ccRecord) {
      throw new NotFoundException('抄送记录不存在');
    }

    if (ccRecord.ccUserId !== userId) {
      throw new Error('无权操作此抄送记录');
    }

    await this.ccRecordRepository.update(ccId, {
      status: CcStatus.READ,
      readTime: new Date(),
    });
  }

  /**
   * 批量标记已读
   */
  async markBatchAsRead(ccIds: string[], userId: string): Promise<void> {
    await this.ccRecordRepository.update(
      {
        id: In(ccIds),
        ccUserId: userId,
      },
      {
        status: CcStatus.READ,
        readTime: new Date(),
      },
    );
  }

  /**
   * 获取未读数量
   */
  async getUnreadCount(userId: string): Promise<number> {
    return this.ccRecordRepository.count({
      where: {
        ccUserId: userId,
        status: CcStatus.UNREAD,
      },
    });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

### 2.4 抄送 API 设计

```typescript
// cc/controllers/cc.controller.ts
import { Controller, Get, Post, Body, Param, Query } from '@nestjs/common';
import { CcService, CreateCcDto, CcQueryDto } from '../services/cc.service';
import { CcType, CcSource } from '../entities/cc-record.entity';

@Controller('api/v1/cc')
export class CcController {
  constructor(private readonly ccService: CcService) {}

  /**
   * 手动抄送
   * POST /api/v1/cc
   */
  @Post()
  async createCc(@Body() dto: CreateCcDto) {
    return this.ccService.createCc(dto);
  }

  /**
   * 查询我的抄送列表
   * GET /api/v1/cc/my
   */
  @Get('my')
  async findMyCcList(@Query() query: CcQueryDto) {
    return this.ccService.findMyCcList(query);
  }

  /**
   * 获取未读数量
   * GET /api/v1/cc/unread-count
   */
  @Get('unread-count')
  async getUnreadCount(@Query('userId') userId: string) {
    return {
      count: await this.ccService.getUnreadCount(userId),
    };
  }

  /**
   * 标记已读
   * POST /api/v1/cc/:id/read
   */
  @Post(':id/read')
  async markAsRead(
    @Param('id') ccId: string,
    @Body('userId') userId: string,
  ) {
    await this.ccService.markAsRead(ccId, userId);
    return { success: true };
  }

  /**
   * 批量标记已读
   * POST /api/v1/cc/batch-read
   */
  @Post('batch-read')
  async markBatchAsRead(
    @Body('ccIds') ccIds: string[],
    @Body('userId') userId: string,
  ) {
    await this.ccService.markBatchAsRead(ccIds, userId);
    return { success: true };
  }
}
```

---

## 三、退回策略设计

### 3.1 退回策略类型

| 策略类型 | 描述 | 使用场景 |
|---------|------|---------|
| **TO_PREVIOUS** | 退回到上一节点 | 简单的审批不通过场景 |
| **TO_STARTER** | 驳回到发起人 | 需要重新填写申请 |
| **TO_SPECIFIC** | 退回到指定节点 | 固定退回点 |
| **TO_ANY_HISTORY** | 可退回到任意历史节点 | 灵活的退回需求 |
| **NOT_ALLOWED** | 不允许退回 | 关键节点不允许退回 |

### 3.2 退回策略配置

#### 3.2.1 流程级别配置

```typescript
// process-definition/entities/process-reject-strategy.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';
import { ProcessDefinition } from './process-definition.entity';

@Entity('process_reject_strategy')
export class ProcessRejectStrategy extends BaseEntity {
  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @ManyToOne(() => ProcessDefinition, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'process_definition_id' })
  processDefinition: ProcessDefinition;

  @Column({ name: 'default_strategy', length: 20, type: 'enum', enum: RejectStrategy })
  defaultStrategy: RejectStrategy;

  @Column({ name: 'allow_custom_target', type: 'tinyint', width: 1, default: false })
  allowCustomTarget: boolean;

  @Column({ name: 'require_reason', type: 'tinyint', width: 1, default: true })
  requireReason: boolean;

  @Column({ name: 'max_reject_count', type: 'int', nullable: true })
  maxRejectCount: number;

  @Column({ name: 'notify_on_reject', type: 'tinyint', width: 1, default: true })
  notifyOnReject: boolean;
}
```

#### 3.2.2 节点级别配置

```typescript
// 在 BPMN XML 中扩展退回策略配置
<userTask id="approveTask" name="审批">
  <extensionElements>
    <flowable:rejectStrategy 
      strategy="TO_PREVIOUS"
      allowCustomTarget="false"
      requireReason="true"
      targetActivityId=""
      notifyStarter="true"
      notifyParticipants="false" />
  </extensionElements>
</userTask>
```

### 3.3 退回策略服务

```typescript
// task/services/reject-strategy.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';

import { RejectConfig, RejectStrategy } from '../../process-definition/entities/reject-config.entity';
import { ProcessRejectStrategy } from '../../process-definition/entities/process-reject-strategy.entity';
import { HistoryService } from '../../history/services/history.service';
import { Task } from '../entities/task.entity';

export interface RejectTarget {
  activityId: string;
  activityName: string;
  activityType: string;
  assignee?: string;
  isAllowed: boolean;
}

@Injectable()
export class RejectStrategyService {
  constructor(
    @InjectRepository(RejectConfig)
    private readonly rejectConfigRepository: Repository<RejectConfig>,
    @InjectRepository(ProcessRejectStrategy)
    private readonly processStrategyRepository: Repository<ProcessRejectStrategy>,
    private readonly historyService: HistoryService,
  ) {}

  /**
   * 获取可退回的节点列表
   */
  async getRejectTargets(task: Task): Promise<RejectTarget[]> {
    const config = await this.getNodeConfig(task.processDefinitionId, task.taskDefinitionKey);
    const processStrategy = await this.getProcessStrategy(task.processDefinitionId);
    const historyActivities = await this.historyService.getHistoricActivities(task.processInstanceId);

    const targets: RejectTarget[] = [];

    for (const activity of historyActivities) {
      // 跳过当前节点
      if (activity.activityId === task.taskDefinitionKey) {
        continue;
      }

      // 跳过非用户任务节点
      if (activity.activityType !== 'userTask') {
        continue;
      }

      const isAllowed = this.isRejectAllowed(config, processStrategy, activity.activityId);

      targets.push({
        activityId: activity.activityId,
        activityName: activity.activityName,
        activityType: activity.activityType,
        assignee: activity.assignee,
        isAllowed,
      });
    }

    return targets;
  }

  /**
   * 获取节点退回配置
   */
  private async getNodeConfig(
    processDefinitionId: string,
    activityId: string,
  ): Promise<RejectConfig | null> {
    return this.rejectConfigRepository.findOne({
      where: {
        processDefinitionId,
        activityId,
      },
    });
  }

  /**
   * 获取流程退回策略
   */
  private async getProcessStrategy(
    processDefinitionId: string,
  ): Promise<ProcessRejectStrategy | null> {
    return this.processStrategyRepository.findOne({
      where: { processDefinitionId },
    });
  }

  /**
   * 判断是否允许退回到指定节点
   */
  private isRejectAllowed(
    nodeConfig: RejectConfig | null,
    processStrategy: ProcessRejectStrategy | null,
    targetActivityId: string,
  ): boolean {
    // 节点级别配置优先
    if (nodeConfig) {
      switch (nodeConfig.rejectStrategy) {
        case RejectStrategy.NOT_ALLOWED:
          return false;
        case RejectStrategy.TO_SPECIFIC:
          return targetActivityId === nodeConfig.targetActivityId;
        case RejectStrategy.TO_ANY_HISTORY:
          return true;
        case RejectStrategy.TO_PREVIOUS:
        case RejectStrategy.TO_STARTER:
          return true;
        default:
          return true;
      }
    }

    // 流程级别配置
    if (processStrategy) {
      return processStrategy.allowCustomTarget;
    }

    // 默认允许
    return true;
  }

  /**
   * 验证退回操作
   */
  async validateReject(
    task: Task,
    targetActivityId: string,
  ): Promise<{ valid: boolean; message?: string }> {
    const config = await this.getNodeConfig(task.processDefinitionId, task.taskDefinitionKey);
    const processStrategy = await this.getProcessStrategy(task.processDefinitionId);

    // 检查是否允许退回
    if (config?.rejectStrategy === RejectStrategy.NOT_ALLOWED) {
      return { valid: false, message: '该节点不允许退回' };
    }

    // 检查退回次数限制
    if (processStrategy?.maxRejectCount) {
      const rejectCount = await this.historyService.getRejectCount(task.processInstanceId);
      if (rejectCount >= processStrategy.maxRejectCount) {
        return { valid: false, message: `已达到最大退回次数限制 (${processStrategy.maxRejectCount})` };
      }
    }

    // 检查目标节点是否在历史中
    const historyActivities = await this.historyService.getHistoricActivities(task.processInstanceId);
    const targetExists = historyActivities.some(a => a.activityId === targetActivityId);
    
    if (!targetExists) {
      return { valid: false, message: '目标节点不在流程历史中' };
    }

    // 检查是否允许退回到指定节点
    if (config?.rejectStrategy === RejectStrategy.TO_SPECIFIC) {
      if (targetActivityId !== config.targetActivityId) {
        return { valid: false, message: '只能退回到指定节点' };
      }
    }

    return { valid: true };
  }
}
```

---

## 四、相同步骤多人的退回策略设计

### 4.1 多人任务类型

| 任务类型 | 描述 | 完成条件 |
|---------|------|---------|
| **单人任务** | 只有一个处理人 | 一人完成即流转 |
| **会签任务 (Parallel)** | 多人并行处理 | 按比例或全部完成 |
| **或签任务 (Sequential)** | 多人顺序处理 | 一人完成即流转 |
| **竞争任务** | 多人竞争认领 | 一人认领后其他人不可处理 |

### 4.2 多人退回策略类型

```typescript
// common/enums/multi-instance-reject-strategy.enum.ts
export enum MultiInstanceRejectStrategy {
  // 退回策略
  ALL_BACK = 'ALL_BACK',               // 所有人任务都退回
  ONLY_CURRENT = 'ONLY_CURRENT',       // 仅退回当前操作人的任务
  MAJORITY_BACK = 'MAJORITY_BACK',     // 多数人退回则全部退回
  
  // 完成后退回策略
  KEEP_COMPLETED = 'KEEP_COMPLETED',   // 保留已完成状态，仅重置未完成任务
  RESET_ALL = 'RESET_ALL',             // 重置所有任务，需要重新审批
  
  // 部分完成时的退回策略
  WAIT_COMPLETION = 'WAIT_COMPLETION', // 等待其他人完成后再退回
  IMMEDIATE = 'IMMEDIATE',             // 立即退回，取消其他人的任务
}
```

### 4.3 多人任务退回数据模型

```typescript
// task/entities/multi-instance-config.entity.ts
import { Entity, Column, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('multi_instance_config')
export class MultiInstanceConfig extends BaseEntity {
  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @Column({ name: 'activity_id', length: 64 })
  @Index()
  activityId: string;

  @Column({ name: 'is_multi_instance', type: 'tinyint', width: 1, default: 0 })
  isMultiInstance: boolean;

  @Column({ name: 'is_sequential', type: 'tinyint', width: 1, default: 0 })
  isSequential: boolean;

  @Column({ name: 'completion_condition', length: 255, nullable: true })
  completionCondition: string; // 完成条件表达式，如 "nrOfCompletedInstances/nrOfInstances >= 0.6"

  @Column({ name: 'reject_strategy', length: 20, type: 'enum', enum: MultiInstanceRejectStrategy })
  rejectStrategy: MultiInstanceRejectStrategy;

  @Column({ name: 'collection_variable', length: 64, nullable: true })
  collectionVariable: string; // 集合变量名

  @Column({ name: 'element_variable', length: 64, nullable: true })
  elementVariable: string; // 元素变量名

  @Column({ name: 'notify_on_reject', type: 'tinyint', width: 1, default: 1 })
  notifyOnReject: boolean;
}
```

### 4.4 多人任务退回服务

```typescript
// task/services/multi-instance-reject.service.ts
import { Injectable, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, QueryRunner, In } from 'typeorm';

import { Task } from '../entities/task.entity';
import { MultiInstanceConfig, MultiInstanceRejectStrategy } from '../entities/multi-instance-config.entity';
import { Execution } from '../../process-instance/entities/execution.entity';
import { HistoryService } from '../../history/services/history.service';
import { EventBusService } from '../../core/services/event-bus.service';
import { TaskRejectService } from './task-reject.service';

export interface MultiInstanceRejectDto {
  taskId: string;
  userId: string;
  targetActivityId: string;
  reason: string;
}

@Injectable()
export class MultiInstanceRejectService {
  constructor(
    @InjectRepository(Task)
    private readonly taskRepository: Repository<Task>,
    @InjectRepository(MultiInstanceConfig)
    private readonly miConfigRepository: Repository<MultiInstanceConfig>,
    @InjectRepository(Execution)
    private readonly executionRepository: Repository<Execution>,
    private readonly historyService: HistoryService,
    private readonly taskRejectService: TaskRejectService,
    private readonly eventBus: EventBusService,
    private readonly dataSource: DataSource,
  ) {}

  /**
   * 处理多人任务退回
   */
  async rejectMultiInstanceTask(dto: MultiInstanceRejectDto): Promise<void> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // 1. 获取当前任务
      const currentTask = await this.taskRepository.findOne({
        where: { id: dto.taskId },
        relations: ['execution'],
      });

      if (!currentTask) {
        throw new BadRequestException('任务不存在');
      }

      // 2. 获取多人任务配置
      const miConfig = await this.getMiConfig(
        currentTask.processDefinitionId,
        currentTask.taskDefinitionKey,
      );

      if (!miConfig || !miConfig.isMultiInstance) {
        // 非多人任务，走普通退回逻辑
        await this.taskRejectService.rejectTask({
          taskId: dto.taskId,
          userId: dto.userId,
          rejectType: 'ROLLBACK' as any,
          targetActivityId: dto.targetActivityId,
          reason: dto.reason,
        });
        return;
      }

      // 3. 获取同一节点的所有任务
      const siblingTasks = await this.getSiblingTasks(currentTask, queryRunner);

      // 4. 根据策略执行退回
      await this.executeRejectByStrategy(
        currentTask,
        siblingTasks,
        miConfig,
        dto,
        queryRunner,
      );

      await queryRunner.commitTransaction();

      // 5. 发布事件
      this.eventBus.emit('multi-instance-task.rejected', {
        taskId: dto.taskId,
        processInstanceId: currentTask.processInstanceId,
        activityId: currentTask.taskDefinitionKey,
        strategy: miConfig.rejectStrategy,
        affectedTasks: siblingTasks.length,
        operatorId: dto.userId,
      });
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  /**
   * 获取多人任务配置
   */
  private async getMiConfig(
    processDefinitionId: string,
    activityId: string,
  ): Promise<MultiInstanceConfig | null> {
    return this.miConfigRepository.findOne({
      where: {
        processDefinitionId,
        activityId,
      },
    });
  }

  /**
   * 获取同一节点的所有任务
   */
  private async getSiblingTasks(
    currentTask: Task,
    queryRunner: QueryRunner,
  ): Promise<Task[]> {
    // 获取父执行实例
    const execution = await queryRunner.manager.findOne(Execution, {
      where: { id: currentTask.executionId },
    });

    if (!execution || !execution.parentId) {
      return [currentTask];
    }

    // 获取同一父执行下的所有任务
    const siblingExecutions = await queryRunner.manager.find(Execution, {
      where: { parentId: execution.parentId },
    });

    const executionIds = siblingExecutions.map(e => e.id);

    return queryRunner.manager.find(Task, {
      where: {
        executionId: In(executionIds),
        taskDefinitionKey: currentTask.taskDefinitionKey,
      },
    });
  }

  /**
   * 根据策略执行退回
   */
  private async executeRejectByStrategy(
    currentTask: Task,
    siblingTasks: Task[],
    miConfig: MultiInstanceConfig,
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    switch (miConfig.rejectStrategy) {
      case MultiInstanceRejectStrategy.ALL_BACK:
        await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.ONLY_CURRENT:
        await this.executeOnlyCurrent(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.MAJORITY_BACK:
        await this.executeMajorityBack(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.KEEP_COMPLETED:
        await this.executeKeepCompleted(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.RESET_ALL:
        await this.executeResetAll(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.WAIT_COMPLETION:
        await this.executeWaitCompletion(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.IMMEDIATE:
        await this.executeImmediate(currentTask, siblingTasks, dto, queryRunner);
        break;

      default:
        await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
    }
  }

  /**
   * 策略：所有人任务都退回
   */
  private async executeAllBack(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 取消所有同级任务
    for (const task of siblingTasks) {
      await queryRunner.manager.update(Task, task.id, {
        status: 'DELETED',
        deleteReason: `退回取消: ${dto.reason}`,
      });
    }

    // 2. 删除所有执行实例
    for (const task of siblingTasks) {
      if (task.executionId) {
        await queryRunner.manager.delete(Execution, task.executionId);
      }
    }

    // 3. 创建目标节点任务
    await this.createTargetTask(currentTask, dto, queryRunner);
  }

  /**
   * 策略：仅退回当前操作人的任务
   */
  private async executeOnlyCurrent(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 仅取消当前任务
    await queryRunner.manager.update(Task, currentTask.id, {
      status: 'DELETED',
      deleteReason: `退回取消: ${dto.reason}`,
    });

    // 2. 删除当前执行实例
    if (currentTask.executionId) {
      await queryRunner.manager.delete(Execution, currentTask.executionId);
    }

    // 3. 检查是否还有未完成的任务
    const remainingTasks = siblingTasks.filter(t => 
      t.id !== currentTask.id && t.status !== 'COMPLETED'
    );

    // 4. 如果没有剩余任务，创建目标节点任务
    if (remainingTasks.length === 0) {
      await this.createTargetTask(currentTask, dto, queryRunner);
    }
  }

  /**
   * 策略：多数人退回则全部退回
   */
  private async executeMajorityBack(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 计算退回比例
    const totalTasks = siblingTasks.length;
    const rejectTasks = siblingTasks.filter(t => 
      t.status === 'DELETED' || t.id === currentTask.id
    ).length;

    const rejectRatio = rejectTasks / totalTasks;

    // 如果超过50%，则全部退回
    if (rejectRatio > 0.5) {
      await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
    } else {
      // 否则仅退回当前任务
      await this.executeOnlyCurrent(currentTask, siblingTasks, dto, queryRunner);
    }
  }

  /**
   * 策略：保留已完成状态
   */
  private async executeKeepCompleted(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 仅取消未完成的任务
    for (const task of siblingTasks) {
      if (task.status !== 'COMPLETED') {
        await queryRunner.manager.update(Task, task.id, {
          status: 'DELETED',
          deleteReason: `退回取消: ${dto.reason}`,
        });

        if (task.executionId) {
          await queryRunner.manager.delete(Execution, task.executionId);
        }
      }
    }

    // 2. 创建目标节点任务（仅针对未完成的人员）
    await this.createTargetTask(currentTask, dto, queryRunner);
  }

  /**
   * 策略：重置所有任务
   */
  private async executeResetAll(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 取消所有任务（包括已完成的）
    for (const task of siblingTasks) {
      await queryRunner.manager.update(Task, task.id, {
        status: 'DELETED',
        deleteReason: `退回重置: ${dto.reason}`,
      });

      if (task.executionId) {
        await queryRunner.manager.delete(Execution, task.executionId);
      }
    }

    // 2. 清除完成记录
    await this.historyService.deleteHistoricTasks(
      siblingTasks.map(t => t.id),
      queryRunner,
    );

    // 3. 创建目标节点任务
    await this.createTargetTask(currentTask, dto, queryRunner);
  }

  /**
   * 策略：等待其他人完成后再退回
   */
  private async executeWaitCompletion(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 标记当前任务为待退回状态
    await queryRunner.manager.update(Task, currentTask.id, {
      status: 'PENDING_REJECT',
      variables: {
        ...currentTask.variables,
        pendingRejectTarget: dto.targetActivityId,
        pendingRejectReason: dto.reason,
      },
    });

    // 2. 检查是否所有任务都已完成或待退回
    const pendingTasks = siblingTasks.filter(t => 
      t.status !== 'COMPLETED' && t.status !== 'PENDING_REJECT'
    );

    // 3. 如果所有任务都已完成或待退回，执行退回
    if (pendingTasks.length === 0) {
      await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
    }
  }

  /**
   * 策略：立即退回
   */
  private async executeImmediate(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 立即取消所有任务并退回
    await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
  }

  /**
   * 创建目标节点任务
   */
  private async createTargetTask(
    currentTask: Task,
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<Task> {
    // 获取目标活动的历史执行信息
    const historyExecution = await this.historyService.getHistoricExecution(
      currentTask.processInstanceId,
      dto.targetActivityId,
    );

    // 创建新的执行实例
    const newExecution = queryRunner.manager.create(Execution, {
      id: this.generateUuid(),
      processInstanceId: currentTask.processInstanceId,
      processDefinitionId: currentTask.processDefinitionId,
      activityId: dto.targetActivityId,
      isActive: true,
      isConcurrent: false,
    });
    await queryRunner.manager.save(newExecution);

    // 创建新任务
    const newTask = queryRunner.manager.create(Task, {
      id: this.generateUuid(),
      processInstanceId: currentTask.processInstanceId,
      processDefinitionId: currentTask.processDefinitionId,
      executionId: newExecution.id,
      taskDefinitionKey: dto.targetActivityId,
      name: historyExecution?.activityName || '退回任务',
      status: 'CREATED',
      assignee: historyExecution?.assignee || null,
      variables: {
        ...currentTask.variables,
        rejectReason: dto.reason,
        rejectFrom: currentTask.taskDefinitionKey,
      },
      createTime: new Date(),
    });
    await queryRunner.manager.save(newTask);

    return newTask;
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

### 4.5 多人退回 API 设计

```typescript
// task/dto/multi-instance-reject.dto.ts
import { IsNotEmpty, IsString, MaxLength, IsOptional } from 'class-validator';

export class MultiInstanceRejectDto {
  @IsString()
  @IsNotEmpty()
  userId: string;

  @IsString()
  @IsNotEmpty()
  targetActivityId: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(2000)
  reason: string;
}

// task/controllers/task.controller.ts 扩展
@Controller('api/v1/tasks')
export class TaskController {
  constructor(
    private readonly multiInstanceRejectService: MultiInstanceRejectService,
  ) {}

  /**
   * 多人任务退回
   * POST /api/v1/tasks/:id/mi-reject
   */
  @Post(':id/mi-reject')
  async multiInstanceReject(
    @Param('id') taskId: string,
    @Body() dto: MultiInstanceRejectDto,
  ) {
    return this.multiInstanceRejectService.rejectMultiInstanceTask({
      taskId,
      ...dto,
    });
  }

  /**
   * 获取多人任务状态
   * GET /api/v1/tasks/:id/mi-status
   */
  @Get(':id/mi-status')
  async getMultiInstanceStatus(@Param('id') taskId: string) {
    return this.multiInstanceRejectService.getMultiInstanceStatus(taskId);
  }
}
```

---

## 五、数据库表结构汇总

### 5.1 新增表结构

```sql
-- 任务驳回记录表
CREATE TABLE `task_reject` (
  `id` varchar(64) NOT NULL,
  `task_id` varchar(64) NOT NULL COMMENT '任务ID',
  `process_instance_id` varchar(64) NOT NULL COMMENT '流程实例ID',
  `reject_from_activity_id` varchar(64) NOT NULL COMMENT '驳回源节点ID',
  `reject_from_activity_name` varchar(128) DEFAULT NULL COMMENT '驳回源节点名称',
  `reject_to_activity_id` varchar(64) NOT NULL COMMENT '驳回目标节点ID',
  `reject_to_activity_name` varchar(128) DEFAULT NULL COMMENT '驳回目标节点名称',
  `reject_type` varchar(20) NOT NULL COMMENT '驳回类型',
  `reason` text COMMENT '驳回原因',
  `operator_id` varchar(64) NOT NULL COMMENT '操作人ID',
  `operator_name` varchar(64) DEFAULT NULL COMMENT '操作人名称',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_task_id` (`task_id`),
  KEY `idx_process_instance_id` (`process_instance_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务驳回记录表';

-- 驳回配置表
CREATE TABLE `reject_config` (
  `id` varchar(64) NOT NULL,
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `activity_id` varchar(64) NOT NULL COMMENT '活动节点ID',
  `activity_name` varchar(128) DEFAULT NULL COMMENT '活动节点名称',
  `reject_strategy` varchar(20) NOT NULL COMMENT '驳回策略',
  `target_activity_id` varchar(64) DEFAULT NULL COMMENT '目标节点ID',
  `allow_custom_target` tinyint(1) DEFAULT '0' COMMENT '是否允许自定义目标',
  `require_reason` tinyint(1) DEFAULT '1' COMMENT '是否必填原因',
  `notify_starter` tinyint(1) DEFAULT '1' COMMENT '是否通知发起人',
  `notify_participants` tinyint(1) DEFAULT '0' COMMENT '是否通知参与者',
  PRIMARY KEY (`id`),
  KEY `idx_process_definition_id` (`process_definition_id`),
  KEY `idx_activity_id` (`activity_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='驳回配置表';

-- 流程驳回策略表
CREATE TABLE `process_reject_strategy` (
  `id` varchar(64) NOT NULL,
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `default_strategy` varchar(20) NOT NULL COMMENT '默认策略',
  `allow_custom_target` tinyint(1) DEFAULT '0' COMMENT '是否允许自定义目标',
  `require_reason` tinyint(1) DEFAULT '1' COMMENT '是否必填原因',
  `max_reject_count` int DEFAULT NULL COMMENT '最大驳回次数',
  `notify_on_reject` tinyint(1) DEFAULT '1' COMMENT '驳回时是否通知',
  PRIMARY KEY (`id`),
  KEY `idx_process_definition_id` (`process_definition_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='流程驳回策略表';

-- 抄送记录表
CREATE TABLE `cc_record` (
  `id` varchar(64) NOT NULL,
  `process_instance_id` varchar(64) NOT NULL COMMENT '流程实例ID',
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `task_id` varchar(64) DEFAULT NULL COMMENT '任务ID',
  `activity_id` varchar(64) DEFAULT NULL COMMENT '活动节点ID',
  `activity_name` varchar(128) DEFAULT NULL COMMENT '活动节点名称',
  `cc_user_id` varchar(64) NOT NULL COMMENT '抄送用户ID',
  `cc_user_name` varchar(64) DEFAULT NULL COMMENT '抄送用户名称',
  `cc_type` varchar(20) NOT NULL COMMENT '抄送类型',
  `cc_source` varchar(20) NOT NULL COMMENT '抄送来源',
  `sender_id` varchar(64) NOT NULL COMMENT '发送人ID',
  `sender_name` varchar(64) DEFAULT NULL COMMENT '发送人名称',
  `message` text COMMENT '消息内容',
  `status` varchar(20) DEFAULT 'UNREAD' COMMENT '状态',
  `read_time` datetime DEFAULT NULL COMMENT '阅读时间',
  `business_key` varchar(64) DEFAULT NULL COMMENT '业务Key',
  `tenant_id` varchar(64) DEFAULT NULL COMMENT '租户ID',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_process_instance_id` (`process_instance_id`),
  KEY `idx_cc_user_id` (`cc_user_id`),
  KEY `idx_task_id` (`task_id`),
  KEY `idx_business_key` (`business_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抄送记录表';

-- 抄送配置表
CREATE TABLE `cc_config` (
  `id` varchar(64) NOT NULL,
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `activity_id` varchar(64) DEFAULT NULL COMMENT '活动节点ID',
  `activity_name` varchar(128) DEFAULT NULL COMMENT '活动节点名称',
  `cc_type` varchar(20) NOT NULL COMMENT '抄送类型',
  `cc_target` text NOT NULL COMMENT '抄送目标',
  `cc_source` varchar(20) NOT NULL COMMENT '抄送来源',
  `trigger_event` varchar(20) NOT NULL COMMENT '触发事件',
  `message_template` varchar(500) DEFAULT NULL COMMENT '消息模板',
  `is_active` tinyint(1) DEFAULT '1' COMMENT '是否启用',
  PRIMARY KEY (`id`),
  KEY `idx_process_definition_id` (`process_definition_id`),
  KEY `idx_activity_id` (`activity_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抄送配置表';

-- 多实例配置表
CREATE TABLE `multi_instance_config` (
  `id` varchar(64) NOT NULL,
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `activity_id` varchar(64) NOT NULL COMMENT '活动节点ID',
  `is_multi_instance` tinyint(1) DEFAULT '0' COMMENT '是否多实例',
  `is_sequential` tinyint(1) DEFAULT '0' COMMENT '是否顺序执行',
  `completion_condition` varchar(255) DEFAULT NULL COMMENT '完成条件',
  `reject_strategy` varchar(20) NOT NULL COMMENT '退回策略',
  `collection_variable` varchar(64) DEFAULT NULL COMMENT '集合变量名',
  `element_variable` varchar(64) DEFAULT NULL COMMENT '元素变量名',
  `notify_on_reject` tinyint(1) DEFAULT '1' COMMENT '退回时是否通知',
  PRIMARY KEY (`id`),
  KEY `idx_process_definition_id` (`process_definition_id`),
  KEY `idx_activity_id` (`activity_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='多实例配置表';
```

---

## 六、API 接口汇总

### 6.1 驳回相关接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| POST | /api/v1/tasks/:id/reject | 驳回任务 |
| GET | /api/v1/tasks/:id/reject-targets | 获取可退回的节点列表 |
| GET | /api/v1/tasks/:id/reject-history | 获取驳回历史 |

### 6.2 抄送相关接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| POST | /api/v1/cc | 创建抄送 |
| GET | /api/v1/cc/my | 查询我的抄送列表 |
| GET | /api/v1/cc/unread-count | 获取未读数量 |
| POST | /api/v1/cc/:id/read | 标记已读 |
| POST | /api/v1/cc/batch-read | 批量标记已读 |

### 6.3 多人任务退回相关接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| POST | /api/v1/tasks/:id/mi-reject | 多人任务退回 |
| GET | /api/v1/tasks/:id/mi-status | 获取多人任务状态 |

---

## 七、事件定义

### 7.1 驳回事件

| 事件名 | 描述 | 数据 |
|-------|------|------|
| task.rejected | 任务被驳回 | taskId, processInstanceId, rejectType, targetActivityId, reason |
| multi-instance-task.rejected | 多人任务被驳回 | taskId, processInstanceId, strategy, affectedTasks |

### 7.2 抄送事件

| 事件名 | 描述 | 数据 |
|-------|------|------|
| cc.created | 抄送创建 | processInstanceId, ccRecords, senderId |

### 7.3 通知事件

| 事件名 | 描述 | 数据 |
|-------|------|------|
| notification.reject | 驳回通知 | recipientId, type, taskId, processInstanceId, reason |
| notification.task.assigned | 任务分配通知 | recipientId, taskId, processInstanceId, message |

---

## 八、总结

本文档补充设计了以下核心功能：

1. **驳回操作功能**：区分退回、驳回、拒绝三种操作类型，支持多种驳回策略配置
2. **抄送操作功能**：支持手动抄送和自动抄送，支持用户、组、角色三种抄送对象
3. **退回策略设计**：支持退回到上一节点、发起人、指定节点、任意历史节点等多种策略
4. **相同步骤多人的退回策略**：支持全部退回、仅当前退回、多数人退回、保留已完成、重置所有、等待完成、立即退回等七种策略

这些功能设计完善了流程引擎的任务操作能力，满足企业级工作流的各种复杂场景需求。
