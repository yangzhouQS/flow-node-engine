# Flowable 任务操作补充设计文档

## 文档说明

本文档补充设计 Flowable 流程引擎中任务操作的核心功能，包括：
- 驳回操作功能设计
- 抄送操作功能设计
- 退回策略设计
- 相同步骤多人的退回策略设计

---

## 一、驳回操作功能设计

### 1.1 驳回与退回的区别

| 操作类型 | 定义 | 使用场景 | 目标节点 |
|---------|------|---------|---------|
| **退回 (Rollback)** | 将流程退回到指定的历史节点 | 审批不通过，需要重新审批 | 任意已执行过的节点 |
| **驳回 (Reject)** | 将流程直接驳回到流程发起人 | 申请不符合要求，需要重新填写 | 流程发起节点 |
| **拒绝 (Deny)** | 直接终止流程实例 | 申请被完全拒绝 | 流程结束（终止状态） |

### 1.2 驳回操作数据模型

#### 1.2.1 驳回记录实体

```typescript
// task/entities/task-reject.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('task_reject')
export class TaskReject extends BaseEntity {
  @Column({ name: 'task_id', length: 64 })
  @Index()
  taskId: string;

  @Column({ name: 'process_instance_id', length: 64 })
  @Index()
  processInstanceId: string;

  @Column({ name: 'reject_from_activity_id', length: 64 })
  rejectFromActivityId: string;

  @Column({ name: 'reject_from_activity_name', length: 128, nullable: true })
  rejectFromActivityName: string;

  @Column({ name: 'reject_to_activity_id', length: 64 })
  rejectToActivityId: string;

  @Column({ name: 'reject_to_activity_name', length: 128, nullable: true })
  rejectToActivityName: string;

  @Column({ name: 'reject_type', length: 20, type: 'enum', enum: RejectType })
  rejectType: RejectType;

  @Column({ name: 'reason', type: 'text', nullable: true })
  reason: string;

  @Column({ name: 'operator_id', length: 64 })
  operatorId: string;

  @Column({ name: 'operator_name', length: 64, nullable: true })
  operatorName: string;

  @Column({ name: 'create_time', type: 'datetime' })
  createTime: Date;
}

export enum RejectType {
  ROLLBACK = 'ROLLBACK',     // 退回到指定节点
  REJECT = 'REJECT',         // 驳回到发起人
  DENY = 'DENY',             // 拒绝（终止流程）
}
```

#### 1.2.2 驳回配置实体

```typescript
// process-definition/entities/reject-config.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';
import { ProcessDefinition } from './process-definition.entity';

@Entity('reject_config')
export class RejectConfig extends BaseEntity {
  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @ManyToOne(() => ProcessDefinition, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'process_definition_id' })
  processDefinition: ProcessDefinition;

  @Column({ name: 'activity_id', length: 64 })
  @Index()
  activityId: string;

  @Column({ name: 'activity_name', length: 128, nullable: true })
  activityName: string;

  @Column({ name: 'reject_strategy', length: 20, type: 'enum', enum: RejectStrategy })
  rejectStrategy: RejectStrategy;

  @Column({ name: 'target_activity_id', length: 64, nullable: true })
  targetActivityId: string;

  @Column({ name: 'allow_custom_target', type: 'tinyint', width: 1, default: 0 })
  allowCustomTarget: boolean;

  @Column({ name: 'require_reason', type: 'tinyint', width: 1, default: 1 })
  requireReason: boolean;

  @Column({ name: 'notify_starter', type: 'tinyint', width: 1, default: 1 })
  notifyStarter: boolean;

  @Column({ name: 'notify_participants', type: 'tinyint', width: 1, default: 0 })
  notifyParticipants: boolean;
}

export enum RejectStrategy {
  TO_PREVIOUS = 'TO_PREVIOUS',       // 退回到上一节点
  TO_STARTER = 'TO_STARTER',         // 驳回到发起人
  TO_SPECIFIC = 'TO_SPECIFIC',       // 退回到指定节点
  TO_ANY_HISTORY = 'TO_ANY_HISTORY', // 可退回到任意历史节点
  NOT_ALLOWED = 'NOT_ALLOWED',       // 不允许退回
}
```

### 1.3 驳回服务实现

```typescript
// task/services/task-reject.service.ts
import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, QueryRunner } from 'typeorm';

import { Task } from '../entities/task.entity';
import { TaskReject, RejectType } from '../entities/task-reject.entity';
import { RejectConfig, RejectStrategy } from '../../process-definition/entities/reject-config.entity';
import { ProcessInstance } from '../../process-instance/entities/process-instance.entity';
import { Execution } from '../../process-instance/entities/execution.entity';
import { HistoryService } from '../../history/services/history.service';
import { EventBusService } from '../../core/services/event-bus.service';
import { TaskService } from './task.service';

export interface RejectTaskDto {
  taskId: string;
  userId: string;
  rejectType: RejectType;
  targetActivityId?: string;
  reason: string;
}

@Injectable()
export class TaskRejectService {
  constructor(
    @InjectRepository(Task)
    private readonly taskRepository: Repository<Task>,
    @InjectRepository(TaskReject)
    private readonly taskRejectRepository: Repository<TaskReject>,
    @InjectRepository(RejectConfig)
    private readonly rejectConfigRepository: Repository<RejectConfig>,
    @InjectRepository(ProcessInstance)
    private readonly processInstanceRepository: Repository<ProcessInstance>,
    @InjectRepository(Execution)
    private readonly executionRepository: Repository<Execution>,
    private readonly historyService: HistoryService,
    private readonly taskService: TaskService,
    private readonly eventBus: EventBusService,
    private readonly dataSource: DataSource,
  ) {}

  /**
   * 驳回任务
   */
  async rejectTask(dto: RejectTaskDto): Promise<Task> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // 1. 获取当前任务
      const currentTask = await this.taskRepository.findOne({
        where: { id: dto.taskId },
        relations: ['processInstance'],
      });

      if (!currentTask) {
        throw new NotFoundException('任务不存在');
      }

      if (currentTask.status !== 'CREATED' && currentTask.status !== 'CLAIMED') {
        throw new BadRequestException('任务状态不允许驳回');
      }

      // 2. 获取驳回配置
      const rejectConfig = await this.getRejectConfig(
        currentTask.processDefinitionId,
        currentTask.taskDefinitionKey,
      );

      // 3. 确定驳回目标
      const targetActivityId = await this.determineRejectTarget(
        dto,
        rejectConfig,
        currentTask,
      );

      // 4. 执行驳回操作
      let newTask: Task;

      switch (dto.rejectType) {
        case RejectType.ROLLBACK:
          newTask = await this.executeRollback(currentTask, targetActivityId, dto, queryRunner);
          break;
        case RejectType.REJECT:
          newTask = await this.executeReject(currentTask, dto, queryRunner);
          break;
        case RejectType.DENY:
          await this.executeDeny(currentTask, dto, queryRunner);
          return null;
        default:
          throw new BadRequestException('不支持的驳回类型');
      }

      // 5. 记录驳回历史
      await this.recordRejectHistory(currentTask, targetActivityId, dto, queryRunner);

      // 6. 发送通知
      await this.sendRejectNotification(currentTask, newTask, dto, rejectConfig);

      await queryRunner.commitTransaction();

      // 7. 发布事件
      this.eventBus.emit('task.rejected', {
        taskId: dto.taskId,
        processInstanceId: currentTask.processInstanceId,
        rejectType: dto.rejectType,
        targetActivityId,
        reason: dto.reason,
        operatorId: dto.userId,
      });

      return newTask;
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  /**
   * 获取驳回配置
   */
  private async getRejectConfig(
    processDefinitionId: string,
    activityId: string,
  ): Promise<RejectConfig | null> {
    return this.rejectConfigRepository.findOne({
      where: {
        processDefinitionId,
        activityId,
      },
    });
  }

  /**
   * 确定驳回目标节点
   */
  private async determineRejectTarget(
    dto: RejectTaskDto,
    config: RejectConfig | null,
    currentTask: Task,
  ): Promise<string> {
    // 如果指定了目标节点
    if (dto.targetActivityId) {
      // 检查是否允许自定义目标
      if (config && !config.allowCustomTarget && config.rejectStrategy !== RejectStrategy.TO_ANY_HISTORY) {
        throw new BadRequestException('该节点不允许自定义退回目标');
      }

      // 验证目标节点是否在历史中
      const historyActivities = await this.historyService.getHistoricActivities(
        currentTask.processInstanceId,
      );
      const isValidTarget = historyActivities.some(a => a.activityId === dto.targetActivityId);
      
      if (!isValidTarget) {
        throw new BadRequestException('目标节点不在流程历史中');
      }

      return dto.targetActivityId;
    }

    // 根据配置确定目标
    if (!config) {
      // 默认退回到上一节点
      return this.getPreviousActivityId(currentTask);
    }

    switch (config.rejectStrategy) {
      case RejectStrategy.TO_PREVIOUS:
        return this.getPreviousActivityId(currentTask);
      case RejectStrategy.TO_STARTER:
        return this.getStarterActivityId(currentTask);
      case RejectStrategy.TO_SPECIFIC:
        return config.targetActivityId;
      case RejectStrategy.TO_ANY_HISTORY:
        throw new BadRequestException('请指定退回目标节点');
      case RejectStrategy.NOT_ALLOWED:
        throw new BadRequestException('该节点不允许退回');
      default:
        return this.getPreviousActivityId(currentTask);
    }
  }

  /**
   * 执行退回操作
   */
  private async executeRollback(
    currentTask: Task,
    targetActivityId: string,
    dto: RejectTaskDto,
    queryRunner: QueryRunner,
  ): Promise<Task> {
    // 1. 删除当前任务
    await queryRunner.manager.delete(Task, currentTask.id);

    // 2. 删除当前执行实例
    await queryRunner.manager.delete(Execution, currentTask.executionId);

    // 3. 获取目标活动的执行上下文
    const historyExecution = await this.historyService.getHistoricExecution(
      currentTask.processInstanceId,
      targetActivityId,
    );

    // 4. 创建新的执行实例
    const newExecution = queryRunner.manager.create(Execution, {
      id: this.generateUuid(),
      processInstanceId: currentTask.processInstanceId,
      processDefinitionId: currentTask.processDefinitionId,
      activityId: targetActivityId,
      isActive: true,
      isConcurrent: false,
      parentId: historyExecution?.parentId || null,
    });
    await queryRunner.manager.save(newExecution);

    // 5. 创建新任务
    const newTask = queryRunner.manager.create(Task, {
      id: this.generateUuid(),
      processInstanceId: currentTask.processInstanceId,
      processDefinitionId: currentTask.processDefinitionId,
      executionId: newExecution.id,
      taskDefinitionKey: targetActivityId,
      name: currentTask.name,
      status: 'CREATED',
      assignee: historyExecution?.assignee || null,
      variables: currentTask.variables,
      createTime: new Date(),
    });
    await queryRunner.manager.save(newTask);

    return newTask;
  }

  /**
   * 执行驳回操作（驳回到发起人）
   */
  private async executeReject(
    currentTask: Task,
    dto: RejectTaskDto,
    queryRunner: QueryRunner,
  ): Promise<Task> {
    // 获取流程发起人
    const processInstance = await this.processInstanceRepository.findOne({
      where: { id: currentTask.processInstanceId },
    });

    const starterActivityId = await this.getStarterActivityId(currentTask);

    // 调用退回逻辑
    return this.executeRollback(currentTask, starterActivityId, dto, queryRunner);
  }

  /**
   * 执行拒绝操作（终止流程）
   */
  private async executeDeny(
    currentTask: Task,
    dto: RejectTaskDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 删除所有活动任务
    await queryRunner.manager.delete(Task, { processInstanceId: currentTask.processInstanceId });

    // 2. 删除所有执行实例
    await queryRunner.manager.delete(Execution, { processInstanceId: currentTask.processInstanceId });

    // 3. 更新流程实例状态
    await queryRunner.manager.update(
      ProcessInstance,
      currentTask.processInstanceId,
      {
        status: 'TERMINATED',
        endTime: new Date(),
        deleteReason: dto.reason,
      },
    );

    // 4. 归档历史数据
    await this.historyService.archiveProcessInstance(
      currentTask.processInstanceId,
      'TERMINATED',
      dto.reason,
      queryRunner,
    );
  }

  /**
   * 获取上一节点ID
   */
  private async getPreviousActivityId(currentTask: Task): Promise<string> {
    const historyActivities = await this.historyService.getHistoricActivities(
      currentTask.processInstanceId,
    );
    
    const currentIndex = historyActivities.findIndex(
      a => a.activityId === currentTask.taskDefinitionKey,
    );
    
    if (currentIndex > 0) {
      return historyActivities[currentIndex - 1].activityId;
    }
    
    throw new BadRequestException('无法确定上一节点');
  }

  /**
   * 获取发起人节点ID
   */
  private async getStarterActivityId(currentTask: Task): Promise<string> {
    const historyActivities = await this.historyService.getHistoricActivities(
      currentTask.processInstanceId,
    );
    
    // 返回第一个用户任务节点
    const firstUserTask = historyActivities.find(a => a.activityType === 'userTask');
    return firstUserTask?.activityId || historyActivities[0]?.activityId;
  }

  /**
   * 记录驳回历史
   */
  private async recordRejectHistory(
    currentTask: Task,
    targetActivityId: string,
    dto: RejectTaskDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    const rejectRecord = queryRunner.manager.create(TaskReject, {
      id: this.generateUuid(),
      taskId: currentTask.id,
      processInstanceId: currentTask.processInstanceId,
      rejectFromActivityId: currentTask.taskDefinitionKey,
      rejectFromActivityName: currentTask.name,
      rejectToActivityId: targetActivityId,
      rejectType: dto.rejectType,
      reason: dto.reason,
      operatorId: dto.userId,
      createTime: new Date(),
    });
    await queryRunner.manager.save(rejectRecord);
  }

  /**
   * 发送驳回通知
   */
  private async sendRejectNotification(
    currentTask: Task,
    newTask: Task | null,
    dto: RejectTaskDto,
    config: RejectConfig | null,
  ): Promise<void> {
    if (config?.notifyStarter) {
      const processInstance = await this.processInstanceRepository.findOne({
        where: { id: currentTask.processInstanceId },
      });

      this.eventBus.emit('notification.reject', {
        recipientId: processInstance?.startUserId,
        type: 'REJECT',
        taskId: currentTask.id,
        processInstanceId: currentTask.processInstanceId,
        reason: dto.reason,
      });
    }

    if (newTask && newTask.assignee) {
      this.eventBus.emit('notification.task.assigned', {
        recipientId: newTask.assignee,
        taskId: newTask.id,
        processInstanceId: newTask.processInstanceId,
        message: `任务已退回，请重新处理`,
      });
    }
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

### 1.4 驳回 API 设计

```typescript
// task/dto/reject-task.dto.ts
import { IsEnum, IsNotEmpty, IsOptional, IsString, MaxLength } from 'class-validator';
import { RejectType } from '../entities/task-reject.entity';

export class RejectTaskDto {
  @IsString()
  @IsNotEmpty()
  userId: string;

  @IsEnum(RejectType)
  rejectType: RejectType;

  @IsString()
  @IsOptional()
  targetActivityId?: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(2000)
  reason: string;
}

// task/controllers/task.controller.ts
@Controller('api/v1/tasks')
export class TaskController {
  constructor(
    private readonly taskRejectService: TaskRejectService,
  ) {}

  /**
   * 驳回任务
   * POST /api/v1/tasks/:id/reject
   */
  @Post(':id/reject')
  async rejectTask(
    @Param('id') taskId: string,
    @Body() dto: RejectTaskDto,
  ) {
    return this.taskRejectService.rejectTask({
      taskId,
      ...dto,
    });
  }

  /**
   * 获取可退回的节点列表
   * GET /api/v1/tasks/:id/reject-targets
   */
  @Get(':id/reject-targets')
  async getRejectTargets(@Param('id') taskId: string) {
    return this.taskRejectService.getRejectTargets(taskId);
  }

  /**
   * 获取驳回历史
   * GET /api/v1/tasks/:id/reject-history
   */
  @Get(':id/reject-history')
  async getRejectHistory(@Param('id') taskId: string) {
    return this.taskRejectService.getRejectHistory(taskId);
  }
}
```

---

## 二、抄送操作功能设计

### 2.1 抄送概念定义

**抄送 (CC - Carbon Copy)**：在流程流转过程中，将流程信息同步发送给非流程参与者，抄送对象无需对流程进行审批，仅作信息通知。

**使用场景**：
- 知会相关人员流程进展
- 备案存档
- 信息共享

### 2.2 抄送数据模型

#### 2.2.1 抄送记录实体

```typescript
// cc/entities/cc-record.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('cc_record')
export class CcRecord extends BaseEntity {
  @Column({ name: 'process_instance_id', length: 64 })
  @Index()
  processInstanceId: string;

  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @Column({ name: 'task_id', length: 64, nullable: true })
  @Index()
  taskId: string;

  @Column({ name: 'activity_id', length: 64, nullable: true })
  activityId: string;

  @Column({ name: 'activity_name', length: 128, nullable: true })
  activityName: string;

  @Column({ name: 'cc_user_id', length: 64 })
  @Index()
  ccUserId: string;

  @Column({ name: 'cc_user_name', length: 64, nullable: true })
  ccUserName: string;

  @Column({ name: 'cc_type', length: 20, type: 'enum', enum: CcType })
  ccType: CcType;

  @Column({ name: 'cc_source', length: 20, type: 'enum', enum: CcSource })
  ccSource: CcSource;

  @Column({ name: 'sender_id', length: 64 })
  senderId: string;

  @Column({ name: 'sender_name', length: 64, nullable: true })
  senderName: string;

  @Column({ name: 'message', type: 'text', nullable: true })
  message: string;

  @Column({ name: 'status', length: 20, type: 'enum', enum: CcStatus, default: CcStatus.UNREAD })
  status: CcStatus;

  @Column({ name: 'read_time', type: 'datetime', nullable: true })
  readTime: Date;

  @Column({ name: 'business_key', length: 64, nullable: true })
  @Index()
  businessKey: string;

  @Column({ name: 'tenant_id', length: 64, nullable: true })
  tenantId: string;

  @Column({ name: 'create_time', type: 'datetime' })
  createTime: Date;
}

export enum CcType {
  USER = 'USER',       // 抄送给用户
  GROUP = 'GROUP',     // 抄送给组
  ROLE = 'ROLE',       // 抄送给角色
}

export enum CcSource {
  MANUAL = 'MANUAL',           // 手动抄送
  AUTO_TASK = 'AUTO_TASK',     // 任务节点自动抄送
  AUTO_PROCESS = 'AUTO_PROCESS', // 流程启动自动抄送
}

export enum CcStatus {
  UNREAD = 'UNREAD',   // 未读
  READ = 'READ',       // 已读
}
```

#### 2.2.2 抄送配置实体

```typescript
// process-definition/entities/cc-config.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';
import { ProcessDefinition } from './process-definition.entity';

@Entity('cc_config')
export class CcConfig extends BaseEntity {
  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @ManyToOne(() => ProcessDefinition, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'process_definition_id' })
  processDefinition: ProcessDefinition;

  @Column({ name: 'activity_id', length: 64, nullable: true })
  @Index()
  activityId: string;

  @Column({ name: 'activity_name', length: 128, nullable: true })
  activityName: string;

  @Column({ name: 'cc_type', length: 20, type: 'enum', enum: CcType })
  ccType: CcType;

  @Column({ name: 'cc_target', type: 'text' })
  ccTarget: string; // JSON 数组，存储用户ID/组ID/角色ID

  @Column({ name: 'cc_source', length: 20, type: 'enum', enum: CcSource })
  ccSource: CcSource;

  @Column({ name: 'trigger_event', length: 20, type: 'enum', enum: CcTriggerEvent })
  triggerEvent: CcTriggerEvent;

  @Column({ name: 'message_template', length: 500, nullable: true })
  messageTemplate: string;

  @Column({ name: 'is_active', type: 'tinyint', width: 1, default: 1 })
  isActive: boolean;
}

export enum CcTriggerEvent {
  TASK_CREATED = 'TASK_CREATED',     // 任务创建时
  TASK_COMPLETED = 'TASK_COMPLETED', // 任务完成时
  PROCESS_STARTED = 'PROCESS_STARTED', // 流程启动时
  PROCESS_ENDED = 'PROCESS_ENDED',   // 流程结束时
}
```

### 2.3 抄送服务实现

```typescript
// cc/services/cc.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';

import { CcRecord, CcType, CcSource, CcStatus } from '../entities/cc-record.entity';
import { CcConfig, CcTriggerEvent } from '../../process-definition/entities/cc-config.entity';
import { ProcessInstance } from '../../process-instance/entities/process-instance.entity';
import { Task } from '../../task/entities/task.entity';
import { EventBusService } from '../../core/services/event-bus.service';
import { IdentityService } from '../../identity/services/identity.service';

export interface CreateCcDto {
  processInstanceId: string;
  taskId?: string;
  activityId?: string;
  activityName?: string;
  ccType: CcType;
  ccTarget: string | string[];
  ccSource: CcSource;
  senderId: string;
  senderName?: string;
  message?: string;
}

export interface CcQueryDto {
  userId?: string;
  processInstanceId?: string;
  taskId?: string;
  status?: CcStatus;
  page?: number;
  pageSize?: number;
}

@Injectable()
export class CcService {
  constructor(
    @InjectRepository(CcRecord)
    private readonly ccRecordRepository: Repository<CcRecord>,
    @InjectRepository(CcConfig)
    private readonly ccConfigRepository: Repository<CcConfig>,
    @InjectRepository(ProcessInstance)
    private readonly processInstanceRepository: Repository<ProcessInstance>,
    @InjectRepository(Task)
    private readonly taskRepository: Repository<Task>,
    private readonly identityService: IdentityService,
    private readonly eventBus: EventBusService,
  ) {}

  /**
   * 创建抄送记录
   */
  async createCc(dto: CreateCcDto): Promise<CcRecord[]> {
    const processInstance = await this.processInstanceRepository.findOne({
      where: { id: dto.processInstanceId },
    });

    if (!processInstance) {
      throw new NotFoundException('流程实例不存在');
    }

    // 解析抄送目标
    const targets = Array.isArray(dto.ccTarget) ? dto.ccTarget : [dto.ccTarget];
    const ccRecords: CcRecord[] = [];

    for (const target of targets) {
      // 获取目标用户列表
      const userIds = await this.resolveCcTargets(dto.ccType, target);

      for (const userId of userIds) {
        const user = await this.identityService.findUserById(userId);
        
        const ccRecord = this.ccRecordRepository.create({
          id: this.generateUuid(),
          processInstanceId: dto.processInstanceId,
          processDefinitionId: processInstance.processDefinitionId,
          taskId: dto.taskId || null,
          activityId: dto.activityId || null,
          activityName: dto.activityName || null,
          ccUserId: userId,
          ccUserName: user?.realName || user?.username || null,
          ccType: dto.ccType,
          ccSource: dto.ccSource,
          senderId: dto.senderId,
          senderName: dto.senderName || null,
          message: dto.message || null,
          status: CcStatus.UNREAD,
          businessKey: processInstance.businessKey || null,
          createTime: new Date(),
        });

        ccRecords.push(await this.ccRecordRepository.save(ccRecord));
      }
    }

    // 发送通知
    this.eventBus.emit('cc.created', {
      processInstanceId: dto.processInstanceId,
      ccRecords,
      senderId: dto.senderId,
    });

    return ccRecords;
  }

  /**
   * 解析抄送目标为用户ID列表
   */
  private async resolveCcTargets(ccType: CcType, target: string): Promise<string[]> {
    switch (ccType) {
      case CcType.USER:
        return [target];
      case CcType.GROUP:
        const groupUsers = await this.identityService.findUsersByGroup(target);
        return groupUsers.map(u => u.id);
      case CcType.ROLE:
        const roleUsers = await this.identityService.findUsersByRole(target);
        return roleUsers.map(u => u.id);
      default:
        return [];
    }
  }

  /**
   * 处理自动抄送
   */
  async processAutoCc(
    processInstanceId: string,
    triggerEvent: CcTriggerEvent,
    taskId?: string,
  ): Promise<void> {
    const processInstance = await this.processInstanceRepository.findOne({
      where: { id: processInstanceId },
    });

    if (!processInstance) return;

    // 查找适用的抄送配置
    const configs = await this.ccConfigRepository.find({
      where: {
        processDefinitionId: processInstance.processDefinitionId,
        triggerEvent,
        isActive: true,
      },
    });

    for (const config of configs) {
      const targets = JSON.parse(config.ccTarget);
      
      await this.createCc({
        processInstanceId,
        taskId,
        activityId: config.activityId || undefined,
        activityName: config.activityName || undefined,
        ccType: config.ccType,
        ccTarget: targets,
        ccSource: config.ccSource,
        senderId: 'SYSTEM',
        senderName: '系统',
        message: this.renderMessageTemplate(config.messageTemplate, processInstance),
      });
    }
  }

  /**
   * 渲染消息模板
   */
  private renderMessageTemplate(
    template: string | null,
    processInstance: ProcessInstance,
  ): string | null {
    if (!template) return null;

    return template
      .replace('${processName}', processInstance.name || '')
      .replace('${businessKey}', processInstance.businessKey || '')
      .replace('${startTime}', processInstance.startTime?.toISOString() || '');
  }

  /**
   * 查询我的抄送列表
   */
  async findMyCcList(dto: CcQueryDto): Promise<[CcRecord[], number]> {
    const queryBuilder = this.ccRecordRepository.createQueryBuilder('cc');

    if (dto.userId) {
      queryBuilder.andWhere('cc.cc_user_id = :userId', { userId: dto.userId });
    }

    if (dto.processInstanceId) {
      queryBuilder.andWhere('cc.process_instance_id = :processInstanceId', {
        processInstanceId: dto.processInstanceId,
      });
    }

    if (dto.taskId) {
      queryBuilder.andWhere('cc.task_id = :taskId', { taskId: dto.taskId });
    }

    if (dto.status) {
      queryBuilder.andWhere('cc.status = :status', { status: dto.status });
    }

    const page = dto.page || 1;
    const pageSize = dto.pageSize || 20;

    queryBuilder
      .skip((page - 1) * pageSize)
      .take(pageSize)
      .orderBy('cc.create_time', 'DESC');

    return queryBuilder.getManyAndCount();
  }

  /**
   * 标记抄送为已读
   */
  async markAsRead(ccId: string, userId: string): Promise<void> {
    const ccRecord = await this.ccRecordRepository.findOne({
      where: { id: ccId },
    });

    if (!ccRecord) {
      throw new NotFoundException('抄送记录不存在');
    }

    if (ccRecord.ccUserId !== userId) {
      throw new Error('无权操作此抄送记录');
    }

    await this.ccRecordRepository.update(ccId, {
      status: CcStatus.READ,
      readTime: new Date(),
    });
  }

  /**
   * 批量标记已读
   */
  async markBatchAsRead(ccIds: string[], userId: string): Promise<void> {
    await this.ccRecordRepository.update(
      {
        id: In(ccIds),
        ccUserId: userId,
      },
      {
        status: CcStatus.READ,
        readTime: new Date(),
      },
    );
  }

  /**
   * 获取未读数量
   */
  async getUnreadCount(userId: string): Promise<number> {
    return this.ccRecordRepository.count({
      where: {
        ccUserId: userId,
        status: CcStatus.UNREAD,
      },
    });
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

### 2.4 抄送 API 设计

```typescript
// cc/controllers/cc.controller.ts
import { Controller, Get, Post, Body, Param, Query } from '@nestjs/common';
import { CcService, CreateCcDto, CcQueryDto } from '../services/cc.service';
import { CcType, CcSource } from '../entities/cc-record.entity';

@Controller('api/v1/cc')
export class CcController {
  constructor(private readonly ccService: CcService) {}

  /**
   * 手动抄送
   * POST /api/v1/cc
   */
  @Post()
  async createCc(@Body() dto: CreateCcDto) {
    return this.ccService.createCc(dto);
  }

  /**
   * 查询我的抄送列表
   * GET /api/v1/cc/my
   */
  @Get('my')
  async findMyCcList(@Query() query: CcQueryDto) {
    return this.ccService.findMyCcList(query);
  }

  /**
   * 获取未读数量
   * GET /api/v1/cc/unread-count
   */
  @Get('unread-count')
  async getUnreadCount(@Query('userId') userId: string) {
    return {
      count: await this.ccService.getUnreadCount(userId),
    };
  }

  /**
   * 标记已读
   * POST /api/v1/cc/:id/read
   */
  @Post(':id/read')
  async markAsRead(
    @Param('id') ccId: string,
    @Body('userId') userId: string,
  ) {
    await this.ccService.markAsRead(ccId, userId);
    return { success: true };
  }

  /**
   * 批量标记已读
   * POST /api/v1/cc/batch-read
   */
  @Post('batch-read')
  async markBatchAsRead(
    @Body('ccIds') ccIds: string[],
    @Body('userId') userId: string,
  ) {
    await this.ccService.markBatchAsRead(ccIds, userId);
    return { success: true };
  }
}
```

---

## 三、退回策略设计

### 3.1 退回策略类型

| 策略类型 | 描述 | 使用场景 |
|---------|------|---------|
| **TO_PREVIOUS** | 退回到上一节点 | 简单的审批不通过场景 |
| **TO_STARTER** | 驳回到发起人 | 需要重新填写申请 |
| **TO_SPECIFIC** | 退回到指定节点 | 固定退回点 |
| **TO_ANY_HISTORY** | 可退回到任意历史节点 | 灵活的退回需求 |
| **NOT_ALLOWED** | 不允许退回 | 关键节点不允许退回 |

### 3.2 退回策略配置

#### 3.2.1 流程级别配置

```typescript
// process-definition/entities/process-reject-strategy.entity.ts
import { Entity, Column, ManyToOne, JoinColumn, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';
import { ProcessDefinition } from './process-definition.entity';

@Entity('process_reject_strategy')
export class ProcessRejectStrategy extends BaseEntity {
  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @ManyToOne(() => ProcessDefinition, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'process_definition_id' })
  processDefinition: ProcessDefinition;

  @Column({ name: 'default_strategy', length: 20, type: 'enum', enum: RejectStrategy })
  defaultStrategy: RejectStrategy;

  @Column({ name: 'allow_custom_target', type: 'tinyint', width: 1, default: false })
  allowCustomTarget: boolean;

  @Column({ name: 'require_reason', type: 'tinyint', width: 1, default: true })
  requireReason: boolean;

  @Column({ name: 'max_reject_count', type: 'int', nullable: true })
  maxRejectCount: number;

  @Column({ name: 'notify_on_reject', type: 'tinyint', width: 1, default: true })
  notifyOnReject: boolean;
}
```

#### 3.2.2 节点级别配置

```typescript
// 在 BPMN XML 中扩展退回策略配置
<userTask id="approveTask" name="审批">
  <extensionElements>
    <flowable:rejectStrategy 
      strategy="TO_PREVIOUS"
      allowCustomTarget="false"
      requireReason="true"
      targetActivityId=""
      notifyStarter="true"
      notifyParticipants="false" />
  </extensionElements>
</userTask>
```

### 3.3 退回策略服务

```typescript
// task/services/reject-strategy.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';

import { RejectConfig, RejectStrategy } from '../../process-definition/entities/reject-config.entity';
import { ProcessRejectStrategy } from '../../process-definition/entities/process-reject-strategy.entity';
import { HistoryService } from '../../history/services/history.service';
import { Task } from '../entities/task.entity';

export interface RejectTarget {
  activityId: string;
  activityName: string;
  activityType: string;
  assignee?: string;
  isAllowed: boolean;
}

@Injectable()
export class RejectStrategyService {
  constructor(
    @InjectRepository(RejectConfig)
    private readonly rejectConfigRepository: Repository<RejectConfig>,
    @InjectRepository(ProcessRejectStrategy)
    private readonly processStrategyRepository: Repository<ProcessRejectStrategy>,
    private readonly historyService: HistoryService,
  ) {}

  /**
   * 获取可退回的节点列表
   */
  async getRejectTargets(task: Task): Promise<RejectTarget[]> {
    const config = await this.getNodeConfig(task.processDefinitionId, task.taskDefinitionKey);
    const processStrategy = await this.getProcessStrategy(task.processDefinitionId);
    const historyActivities = await this.historyService.getHistoricActivities(task.processInstanceId);

    const targets: RejectTarget[] = [];

    for (const activity of historyActivities) {
      // 跳过当前节点
      if (activity.activityId === task.taskDefinitionKey) {
        continue;
      }

      // 跳过非用户任务节点
      if (activity.activityType !== 'userTask') {
        continue;
      }

      const isAllowed = this.isRejectAllowed(config, processStrategy, activity.activityId);

      targets.push({
        activityId: activity.activityId,
        activityName: activity.activityName,
        activityType: activity.activityType,
        assignee: activity.assignee,
        isAllowed,
      });
    }

    return targets;
  }

  /**
   * 获取节点退回配置
   */
  private async getNodeConfig(
    processDefinitionId: string,
    activityId: string,
  ): Promise<RejectConfig | null> {
    return this.rejectConfigRepository.findOne({
      where: {
        processDefinitionId,
        activityId,
      },
    });
  }

  /**
   * 获取流程退回策略
   */
  private async getProcessStrategy(
    processDefinitionId: string,
  ): Promise<ProcessRejectStrategy | null> {
    return this.processStrategyRepository.findOne({
      where: { processDefinitionId },
    });
  }

  /**
   * 判断是否允许退回到指定节点
   */
  private isRejectAllowed(
    nodeConfig: RejectConfig | null,
    processStrategy: ProcessRejectStrategy | null,
    targetActivityId: string,
  ): boolean {
    // 节点级别配置优先
    if (nodeConfig) {
      switch (nodeConfig.rejectStrategy) {
        case RejectStrategy.NOT_ALLOWED:
          return false;
        case RejectStrategy.TO_SPECIFIC:
          return targetActivityId === nodeConfig.targetActivityId;
        case RejectStrategy.TO_ANY_HISTORY:
          return true;
        case RejectStrategy.TO_PREVIOUS:
        case RejectStrategy.TO_STARTER:
          return true;
        default:
          return true;
      }
    }

    // 流程级别配置
    if (processStrategy) {
      return processStrategy.allowCustomTarget;
    }

    // 默认允许
    return true;
  }

  /**
   * 验证退回操作
   */
  async validateReject(
    task: Task,
    targetActivityId: string,
  ): Promise<{ valid: boolean; message?: string }> {
    const config = await this.getNodeConfig(task.processDefinitionId, task.taskDefinitionKey);
    const processStrategy = await this.getProcessStrategy(task.processDefinitionId);

    // 检查是否允许退回
    if (config?.rejectStrategy === RejectStrategy.NOT_ALLOWED) {
      return { valid: false, message: '该节点不允许退回' };
    }

    // 检查退回次数限制
    if (processStrategy?.maxRejectCount) {
      const rejectCount = await this.historyService.getRejectCount(task.processInstanceId);
      if (rejectCount >= processStrategy.maxRejectCount) {
        return { valid: false, message: `已达到最大退回次数限制 (${processStrategy.maxRejectCount})` };
      }
    }

    // 检查目标节点是否在历史中
    const historyActivities = await this.historyService.getHistoricActivities(task.processInstanceId);
    const targetExists = historyActivities.some(a => a.activityId === targetActivityId);
    
    if (!targetExists) {
      return { valid: false, message: '目标节点不在流程历史中' };
    }

    // 检查是否允许退回到指定节点
    if (config?.rejectStrategy === RejectStrategy.TO_SPECIFIC) {
      if (targetActivityId !== config.targetActivityId) {
        return { valid: false, message: '只能退回到指定节点' };
      }
    }

    return { valid: true };
  }
}
```

---

## 四、相同步骤多人的退回策略设计

### 4.1 多人任务类型

| 任务类型 | 描述 | 完成条件 |
|---------|------|---------|
| **单人任务** | 只有一个处理人 | 一人完成即流转 |
| **会签任务 (Parallel)** | 多人并行处理 | 按比例或全部完成 |
| **或签任务 (Sequential)** | 多人顺序处理 | 一人完成即流转 |
| **竞争任务** | 多人竞争认领 | 一人认领后其他人不可处理 |

### 4.2 多人退回策略类型

```typescript
// common/enums/multi-instance-reject-strategy.enum.ts
export enum MultiInstanceRejectStrategy {
  // 退回策略
  ALL_BACK = 'ALL_BACK',               // 所有人任务都退回
  ONLY_CURRENT = 'ONLY_CURRENT',       // 仅退回当前操作人的任务
  MAJORITY_BACK = 'MAJORITY_BACK',     // 多数人退回则全部退回
  
  // 完成后退回策略
  KEEP_COMPLETED = 'KEEP_COMPLETED',   // 保留已完成状态，仅重置未完成任务
  RESET_ALL = 'RESET_ALL',             // 重置所有任务，需要重新审批
  
  // 部分完成时的退回策略
  WAIT_COMPLETION = 'WAIT_COMPLETION', // 等待其他人完成后再退回
  IMMEDIATE = 'IMMEDIATE',             // 立即退回，取消其他人的任务
}
```

### 4.3 多人任务退回数据模型

```typescript
// task/entities/multi-instance-config.entity.ts
import { Entity, Column, Index } from 'typeorm';
import { BaseEntity } from '../../common/entities/base.entity';

@Entity('multi_instance_config')
export class MultiInstanceConfig extends BaseEntity {
  @Column({ name: 'process_definition_id', length: 64 })
  @Index()
  processDefinitionId: string;

  @Column({ name: 'activity_id', length: 64 })
  @Index()
  activityId: string;

  @Column({ name: 'is_multi_instance', type: 'tinyint', width: 1, default: 0 })
  isMultiInstance: boolean;

  @Column({ name: 'is_sequential', type: 'tinyint', width: 1, default: 0 })
  isSequential: boolean;

  @Column({ name: 'completion_condition', length: 255, nullable: true })
  completionCondition: string; // 完成条件表达式，如 "nrOfCompletedInstances/nrOfInstances >= 0.6"

  @Column({ name: 'reject_strategy', length: 20, type: 'enum', enum: MultiInstanceRejectStrategy })
  rejectStrategy: MultiInstanceRejectStrategy;

  @Column({ name: 'collection_variable', length: 64, nullable: true })
  collectionVariable: string; // 集合变量名

  @Column({ name: 'element_variable', length: 64, nullable: true })
  elementVariable: string; // 元素变量名

  @Column({ name: 'notify_on_reject', type: 'tinyint', width: 1, default: 1 })
  notifyOnReject: boolean;
}
```

### 4.4 多人任务退回服务

```typescript
// task/services/multi-instance-reject.service.ts
import { Injectable, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, QueryRunner, In } from 'typeorm';

import { Task } from '../entities/task.entity';
import { MultiInstanceConfig, MultiInstanceRejectStrategy } from '../entities/multi-instance-config.entity';
import { Execution } from '../../process-instance/entities/execution.entity';
import { HistoryService } from '../../history/services/history.service';
import { EventBusService } from '../../core/services/event-bus.service';
import { TaskRejectService } from './task-reject.service';

export interface MultiInstanceRejectDto {
  taskId: string;
  userId: string;
  targetActivityId: string;
  reason: string;
}

@Injectable()
export class MultiInstanceRejectService {
  constructor(
    @InjectRepository(Task)
    private readonly taskRepository: Repository<Task>,
    @InjectRepository(MultiInstanceConfig)
    private readonly miConfigRepository: Repository<MultiInstanceConfig>,
    @InjectRepository(Execution)
    private readonly executionRepository: Repository<Execution>,
    private readonly historyService: HistoryService,
    private readonly taskRejectService: TaskRejectService,
    private readonly eventBus: EventBusService,
    private readonly dataSource: DataSource,
  ) {}

  /**
   * 处理多人任务退回
   */
  async rejectMultiInstanceTask(dto: MultiInstanceRejectDto): Promise<void> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // 1. 获取当前任务
      const currentTask = await this.taskRepository.findOne({
        where: { id: dto.taskId },
        relations: ['execution'],
      });

      if (!currentTask) {
        throw new BadRequestException('任务不存在');
      }

      // 2. 获取多人任务配置
      const miConfig = await this.getMiConfig(
        currentTask.processDefinitionId,
        currentTask.taskDefinitionKey,
      );

      if (!miConfig || !miConfig.isMultiInstance) {
        // 非多人任务，走普通退回逻辑
        await this.taskRejectService.rejectTask({
          taskId: dto.taskId,
          userId: dto.userId,
          rejectType: 'ROLLBACK' as any,
          targetActivityId: dto.targetActivityId,
          reason: dto.reason,
        });
        return;
      }

      // 3. 获取同一节点的所有任务
      const siblingTasks = await this.getSiblingTasks(currentTask, queryRunner);

      // 4. 根据策略执行退回
      await this.executeRejectByStrategy(
        currentTask,
        siblingTasks,
        miConfig,
        dto,
        queryRunner,
      );

      await queryRunner.commitTransaction();

      // 5. 发布事件
      this.eventBus.emit('multi-instance-task.rejected', {
        taskId: dto.taskId,
        processInstanceId: currentTask.processInstanceId,
        activityId: currentTask.taskDefinitionKey,
        strategy: miConfig.rejectStrategy,
        affectedTasks: siblingTasks.length,
        operatorId: dto.userId,
      });
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  /**
   * 获取多人任务配置
   */
  private async getMiConfig(
    processDefinitionId: string,
    activityId: string,
  ): Promise<MultiInstanceConfig | null> {
    return this.miConfigRepository.findOne({
      where: {
        processDefinitionId,
        activityId,
      },
    });
  }

  /**
   * 获取同一节点的所有任务
   */
  private async getSiblingTasks(
    currentTask: Task,
    queryRunner: QueryRunner,
  ): Promise<Task[]> {
    // 获取父执行实例
    const execution = await queryRunner.manager.findOne(Execution, {
      where: { id: currentTask.executionId },
    });

    if (!execution || !execution.parentId) {
      return [currentTask];
    }

    // 获取同一父执行下的所有任务
    const siblingExecutions = await queryRunner.manager.find(Execution, {
      where: { parentId: execution.parentId },
    });

    const executionIds = siblingExecutions.map(e => e.id);

    return queryRunner.manager.find(Task, {
      where: {
        executionId: In(executionIds),
        taskDefinitionKey: currentTask.taskDefinitionKey,
      },
    });
  }

  /**
   * 根据策略执行退回
   */
  private async executeRejectByStrategy(
    currentTask: Task,
    siblingTasks: Task[],
    miConfig: MultiInstanceConfig,
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    switch (miConfig.rejectStrategy) {
      case MultiInstanceRejectStrategy.ALL_BACK:
        await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.ONLY_CURRENT:
        await this.executeOnlyCurrent(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.MAJORITY_BACK:
        await this.executeMajorityBack(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.KEEP_COMPLETED:
        await this.executeKeepCompleted(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.RESET_ALL:
        await this.executeResetAll(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.WAIT_COMPLETION:
        await this.executeWaitCompletion(currentTask, siblingTasks, dto, queryRunner);
        break;

      case MultiInstanceRejectStrategy.IMMEDIATE:
        await this.executeImmediate(currentTask, siblingTasks, dto, queryRunner);
        break;

      default:
        await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
    }
  }

  /**
   * 策略：所有人任务都退回
   */
  private async executeAllBack(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 取消所有同级任务
    for (const task of siblingTasks) {
      await queryRunner.manager.update(Task, task.id, {
        status: 'DELETED',
        deleteReason: `退回取消: ${dto.reason}`,
      });
    }

    // 2. 删除所有执行实例
    for (const task of siblingTasks) {
      if (task.executionId) {
        await queryRunner.manager.delete(Execution, task.executionId);
      }
    }

    // 3. 创建目标节点任务
    await this.createTargetTask(currentTask, dto, queryRunner);
  }

  /**
   * 策略：仅退回当前操作人的任务
   */
  private async executeOnlyCurrent(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 仅取消当前任务
    await queryRunner.manager.update(Task, currentTask.id, {
      status: 'DELETED',
      deleteReason: `退回取消: ${dto.reason}`,
    });

    // 2. 删除当前执行实例
    if (currentTask.executionId) {
      await queryRunner.manager.delete(Execution, currentTask.executionId);
    }

    // 3. 检查是否还有未完成的任务
    const remainingTasks = siblingTasks.filter(t => 
      t.id !== currentTask.id && t.status !== 'COMPLETED'
    );

    // 4. 如果没有剩余任务，创建目标节点任务
    if (remainingTasks.length === 0) {
      await this.createTargetTask(currentTask, dto, queryRunner);
    }
  }

  /**
   * 策略：多数人退回则全部退回
   */
  private async executeMajorityBack(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 计算退回比例
    const totalTasks = siblingTasks.length;
    const rejectTasks = siblingTasks.filter(t => 
      t.status === 'DELETED' || t.id === currentTask.id
    ).length;

    const rejectRatio = rejectTasks / totalTasks;

    // 如果超过50%，则全部退回
    if (rejectRatio > 0.5) {
      await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
    } else {
      // 否则仅退回当前任务
      await this.executeOnlyCurrent(currentTask, siblingTasks, dto, queryRunner);
    }
  }

  /**
   * 策略：保留已完成状态
   */
  private async executeKeepCompleted(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 仅取消未完成的任务
    for (const task of siblingTasks) {
      if (task.status !== 'COMPLETED') {
        await queryRunner.manager.update(Task, task.id, {
          status: 'DELETED',
          deleteReason: `退回取消: ${dto.reason}`,
        });

        if (task.executionId) {
          await queryRunner.manager.delete(Execution, task.executionId);
        }
      }
    }

    // 2. 创建目标节点任务（仅针对未完成的人员）
    await this.createTargetTask(currentTask, dto, queryRunner);
  }

  /**
   * 策略：重置所有任务
   */
  private async executeResetAll(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 取消所有任务（包括已完成的）
    for (const task of siblingTasks) {
      await queryRunner.manager.update(Task, task.id, {
        status: 'DELETED',
        deleteReason: `退回重置: ${dto.reason}`,
      });

      if (task.executionId) {
        await queryRunner.manager.delete(Execution, task.executionId);
      }
    }

    // 2. 清除完成记录
    await this.historyService.deleteHistoricTasks(
      siblingTasks.map(t => t.id),
      queryRunner,
    );

    // 3. 创建目标节点任务
    await this.createTargetTask(currentTask, dto, queryRunner);
  }

  /**
   * 策略：等待其他人完成后再退回
   */
  private async executeWaitCompletion(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 1. 标记当前任务为待退回状态
    await queryRunner.manager.update(Task, currentTask.id, {
      status: 'PENDING_REJECT',
      variables: {
        ...currentTask.variables,
        pendingRejectTarget: dto.targetActivityId,
        pendingRejectReason: dto.reason,
      },
    });

    // 2. 检查是否所有任务都已完成或待退回
    const pendingTasks = siblingTasks.filter(t => 
      t.status !== 'COMPLETED' && t.status !== 'PENDING_REJECT'
    );

    // 3. 如果所有任务都已完成或待退回，执行退回
    if (pendingTasks.length === 0) {
      await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
    }
  }

  /**
   * 策略：立即退回
   */
  private async executeImmediate(
    currentTask: Task,
    siblingTasks: Task[],
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 立即取消所有任务并退回
    await this.executeAllBack(currentTask, siblingTasks, dto, queryRunner);
  }

  /**
   * 创建目标节点任务
   */
  private async createTargetTask(
    currentTask: Task,
    dto: MultiInstanceRejectDto,
    queryRunner: QueryRunner,
  ): Promise<Task> {
    // 获取目标活动的历史执行信息
    const historyExecution = await this.historyService.getHistoricExecution(
      currentTask.processInstanceId,
      dto.targetActivityId,
    );

    // 创建新的执行实例
    const newExecution = queryRunner.manager.create(Execution, {
      id: this.generateUuid(),
      processInstanceId: currentTask.processInstanceId,
      processDefinitionId: currentTask.processDefinitionId,
      activityId: dto.targetActivityId,
      isActive: true,
      isConcurrent: false,
    });
    await queryRunner.manager.save(newExecution);

    // 创建新任务
    const newTask = queryRunner.manager.create(Task, {
      id: this.generateUuid(),
      processInstanceId: currentTask.processInstanceId,
      processDefinitionId: currentTask.processDefinitionId,
      executionId: newExecution.id,
      taskDefinitionKey: dto.targetActivityId,
      name: historyExecution?.activityName || '退回任务',
      status: 'CREATED',
      assignee: historyExecution?.assignee || null,
      variables: {
        ...currentTask.variables,
        rejectReason: dto.reason,
        rejectFrom: currentTask.taskDefinitionKey,
      },
      createTime: new Date(),
    });
    await queryRunner.manager.save(newTask);

    return newTask;
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

### 4.5 多人退回 API 设计

```typescript
// task/dto/multi-instance-reject.dto.ts
import { IsNotEmpty, IsString, MaxLength, IsOptional } from 'class-validator';

export class MultiInstanceRejectDto {
  @IsString()
  @IsNotEmpty()
  userId: string;

  @IsString()
  @IsNotEmpty()
  targetActivityId: string;

  @IsString()
  @IsNotEmpty()
  @MaxLength(2000)
  reason: string;
}

// task/controllers/task.controller.ts 扩展
@Controller('api/v1/tasks')
export class TaskController {
  constructor(
    private readonly multiInstanceRejectService: MultiInstanceRejectService,
  ) {}

  /**
   * 多人任务退回
   * POST /api/v1/tasks/:id/mi-reject
   */
  @Post(':id/mi-reject')
  async multiInstanceReject(
    @Param('id') taskId: string,
    @Body() dto: MultiInstanceRejectDto,
  ) {
    return this.multiInstanceRejectService.rejectMultiInstanceTask({
      taskId,
      ...dto,
    });
  }

  /**
   * 获取多人任务状态
   * GET /api/v1/tasks/:id/mi-status
   */
  @Get(':id/mi-status')
  async getMultiInstanceStatus(@Param('id') taskId: string) {
    return this.multiInstanceRejectService.getMultiInstanceStatus(taskId);
  }
}
```

---

## 五、数据库表结构汇总

### 5.1 新增表结构

```sql
-- 任务驳回记录表
CREATE TABLE `task_reject` (
  `id` varchar(64) NOT NULL,
  `task_id` varchar(64) NOT NULL COMMENT '任务ID',
  `process_instance_id` varchar(64) NOT NULL COMMENT '流程实例ID',
  `reject_from_activity_id` varchar(64) NOT NULL COMMENT '驳回源节点ID',
  `reject_from_activity_name` varchar(128) DEFAULT NULL COMMENT '驳回源节点名称',
  `reject_to_activity_id` varchar(64) NOT NULL COMMENT '驳回目标节点ID',
  `reject_to_activity_name` varchar(128) DEFAULT NULL COMMENT '驳回目标节点名称',
  `reject_type` varchar(20) NOT NULL COMMENT '驳回类型',
  `reason` text COMMENT '驳回原因',
  `operator_id` varchar(64) NOT NULL COMMENT '操作人ID',
  `operator_name` varchar(64) DEFAULT NULL COMMENT '操作人名称',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_task_id` (`task_id`),
  KEY `idx_process_instance_id` (`process_instance_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='任务驳回记录表';

-- 驳回配置表
CREATE TABLE `reject_config` (
  `id` varchar(64) NOT NULL,
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `activity_id` varchar(64) NOT NULL COMMENT '活动节点ID',
  `activity_name` varchar(128) DEFAULT NULL COMMENT '活动节点名称',
  `reject_strategy` varchar(20) NOT NULL COMMENT '驳回策略',
  `target_activity_id` varchar(64) DEFAULT NULL COMMENT '目标节点ID',
  `allow_custom_target` tinyint(1) DEFAULT '0' COMMENT '是否允许自定义目标',
  `require_reason` tinyint(1) DEFAULT '1' COMMENT '是否必填原因',
  `notify_starter` tinyint(1) DEFAULT '1' COMMENT '是否通知发起人',
  `notify_participants` tinyint(1) DEFAULT '0' COMMENT '是否通知参与者',
  PRIMARY KEY (`id`),
  KEY `idx_process_definition_id` (`process_definition_id`),
  KEY `idx_activity_id` (`activity_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='驳回配置表';

-- 流程驳回策略表
CREATE TABLE `process_reject_strategy` (
  `id` varchar(64) NOT NULL,
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `default_strategy` varchar(20) NOT NULL COMMENT '默认策略',
  `allow_custom_target` tinyint(1) DEFAULT '0' COMMENT '是否允许自定义目标',
  `require_reason` tinyint(1) DEFAULT '1' COMMENT '是否必填原因',
  `max_reject_count` int DEFAULT NULL COMMENT '最大驳回次数',
  `notify_on_reject` tinyint(1) DEFAULT '1' COMMENT '驳回时是否通知',
  PRIMARY KEY (`id`),
  KEY `idx_process_definition_id` (`process_definition_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='流程驳回策略表';

-- 抄送记录表
CREATE TABLE `cc_record` (
  `id` varchar(64) NOT NULL,
  `process_instance_id` varchar(64) NOT NULL COMMENT '流程实例ID',
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `task_id` varchar(64) DEFAULT NULL COMMENT '任务ID',
  `activity_id` varchar(64) DEFAULT NULL COMMENT '活动节点ID',
  `activity_name` varchar(128) DEFAULT NULL COMMENT '活动节点名称',
  `cc_user_id` varchar(64) NOT NULL COMMENT '抄送用户ID',
  `cc_user_name` varchar(64) DEFAULT NULL COMMENT '抄送用户名称',
  `cc_type` varchar(20) NOT NULL COMMENT '抄送类型',
  `cc_source` varchar(20) NOT NULL COMMENT '抄送来源',
  `sender_id` varchar(64) NOT NULL COMMENT '发送人ID',
  `sender_name` varchar(64) DEFAULT NULL COMMENT '发送人名称',
  `message` text COMMENT '消息内容',
  `status` varchar(20) DEFAULT 'UNREAD' COMMENT '状态',
  `read_time` datetime DEFAULT NULL COMMENT '阅读时间',
  `business_key` varchar(64) DEFAULT NULL COMMENT '业务Key',
  `tenant_id` varchar(64) DEFAULT NULL COMMENT '租户ID',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_process_instance_id` (`process_instance_id`),
  KEY `idx_cc_user_id` (`cc_user_id`),
  KEY `idx_task_id` (`task_id`),
  KEY `idx_business_key` (`business_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抄送记录表';

-- 抄送配置表
CREATE TABLE `cc_config` (
  `id` varchar(64) NOT NULL,
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `activity_id` varchar(64) DEFAULT NULL COMMENT '活动节点ID',
  `activity_name` varchar(128) DEFAULT NULL COMMENT '活动节点名称',
  `cc_type` varchar(20) NOT NULL COMMENT '抄送类型',
  `cc_target` text NOT NULL COMMENT '抄送目标',
  `cc_source` varchar(20) NOT NULL COMMENT '抄送来源',
  `trigger_event` varchar(20) NOT NULL COMMENT '触发事件',
  `message_template` varchar(500) DEFAULT NULL COMMENT '消息模板',
  `is_active` tinyint(1) DEFAULT '1' COMMENT '是否启用',
  PRIMARY KEY (`id`),
  KEY `idx_process_definition_id` (`process_definition_id`),
  KEY `idx_activity_id` (`activity_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抄送配置表';

-- 多实例配置表
CREATE TABLE `multi_instance_config` (
  `id` varchar(64) NOT NULL,
  `process_definition_id` varchar(64) NOT NULL COMMENT '流程定义ID',
  `activity_id` varchar(64) NOT NULL COMMENT '活动节点ID',
  `is_multi_instance` tinyint(1) DEFAULT '0' COMMENT '是否多实例',
  `is_sequential` tinyint(1) DEFAULT '0' COMMENT '是否顺序执行',
  `completion_condition` varchar(255) DEFAULT NULL COMMENT '完成条件',
  `reject_strategy` varchar(20) NOT NULL COMMENT '退回策略',
  `collection_variable` varchar(64) DEFAULT NULL COMMENT '集合变量名',
  `element_variable` varchar(64) DEFAULT NULL COMMENT '元素变量名',
  `notify_on_reject` tinyint(1) DEFAULT '1' COMMENT '退回时是否通知',
  PRIMARY KEY (`id`),
  KEY `idx_process_definition_id` (`process_definition_id`),
  KEY `idx_activity_id` (`activity_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='多实例配置表';
```

---

## 六、API 接口汇总

### 6.1 驳回相关接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| POST | /api/v1/tasks/:id/reject | 驳回任务 |
| GET | /api/v1/tasks/:id/reject-targets | 获取可退回的节点列表 |
| GET | /api/v1/tasks/:id/reject-history | 获取驳回历史 |

### 6.2 抄送相关接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| POST | /api/v1/cc | 创建抄送 |
| GET | /api/v1/cc/my | 查询我的抄送列表 |
| GET | /api/v1/cc/unread-count | 获取未读数量 |
| POST | /api/v1/cc/:id/read | 标记已读 |
| POST | /api/v1/cc/batch-read | 批量标记已读 |

### 6.3 多人任务退回相关接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| POST | /api/v1/tasks/:id/mi-reject | 多人任务退回 |
| GET | /api/v1/tasks/:id/mi-status | 获取多人任务状态 |

---

## 七、事件定义

### 7.1 驳回事件

| 事件名 | 描述 | 数据 |
|-------|------|------|
| task.rejected | 任务被驳回 | taskId, processInstanceId, rejectType, targetActivityId, reason |
| multi-instance-task.rejected | 多人任务被驳回 | taskId, processInstanceId, strategy, affectedTasks |

### 7.2 抄送事件

| 事件名 | 描述 | 数据 |
|-------|------|------|
| cc.created | 抄送创建 | processInstanceId, ccRecords, senderId |

### 7.3 通知事件

| 事件名 | 描述 | 数据 |
|-------|------|------|
| notification.reject | 驳回通知 | recipientId, type, taskId, processInstanceId, reason |
| notification.task.assigned | 任务分配通知 | recipientId, taskId, processInstanceId, message |

---

## 八、高级场景设计

### 8.1 驳回后重新提交的处理流程

#### 8.1.1 重新提交流程设计

当任务被驳回后，需要支持发起人或被驳回节点重新提交流程。

```typescript
// task/services/resubmit.service.ts
import { Injectable, BadRequestException, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, QueryRunner } from 'typeorm';

import { Task } from '../entities/task.entity';
import { TaskReject, RejectType } from '../entities/task-reject.entity';
import { ProcessInstance, ProcessInstanceStatus } from '../../process-instance/entities/process-instance.entity';
import { Execution } from '../../process-instance/entities/execution.entity';
import { HistoryService } from '../../history/services/history.service';
import { EventBusService } from '../../core/services/event-bus.service';

export interface ResubmitTaskDto {
  taskId: string;
  userId: string;
  variables?: Record<string, any>;
  comment?: string;
}

@Injectable()
export class ResubmitService {
  constructor(
    @InjectRepository(Task)
    private readonly taskRepository: Repository<Task>,
    @InjectRepository(TaskReject)
    private readonly taskRejectRepository: Repository<TaskReject>,
    @InjectRepository(ProcessInstance)
    private readonly processInstanceRepository: Repository<ProcessInstance>,
    @InjectRepository(Execution)
    private readonly executionRepository: Repository<Execution>,
    private readonly historyService: HistoryService,
    private readonly eventBus: EventBusService,
    private readonly dataSource: DataSource,
  ) {}

  /**
   * 重新提交被驳回的任务
   */
  async resubmitTask(dto: ResubmitTaskDto): Promise<Task> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // 1. 获取当前任务
      const currentTask = await this.taskRepository.findOne({
        where: { id: dto.taskId },
        relations: ['processInstance'],
      });

      if (!currentTask) {
        throw new NotFoundException('任务不存在');
      }

      // 2. 验证任务是否可以被重新提交
      await this.validateResubmit(currentTask, dto.userId);

      // 3. 获取最近的驳回记录
      const lastReject = await this.getLastRejectRecord(
        currentTask.processInstanceId,
        currentTask.taskDefinitionKey,
      );

      if (!lastReject) {
        throw new BadRequestException('未找到驳回记录，无法重新提交');
      }

      // 4. 更新任务变量
      if (dto.variables) {
        await queryRunner.manager.update(Task, currentTask.id, {
          variables: {
            ...currentTask.variables,
            ...dto.variables,
            resubmitTime: new Date().toISOString(),
            resubmitBy: dto.userId,
            resubmitComment: dto.comment || null,
          },
        });
      }

      // 5. 完成当前任务，触发流程继续
      const completedTask = await this.completeResubmitTask(
        currentTask,
        dto,
        lastReject,
        queryRunner,
      );

      // 6. 记录重新提交历史
      await this.recordResubmitHistory(currentTask, dto, lastReject, queryRunner);

      await queryRunner.commitTransaction();

      // 7. 发布事件
      this.eventBus.emit('task.resubmitted', {
        taskId: dto.taskId,
        processInstanceId: currentTask.processInstanceId,
        userId: dto.userId,
        originalRejectType: lastReject.rejectType,
        variables: dto.variables,
      });

      return completedTask;
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }

  /**
   * 验证是否可以重新提交
   */
  private async validateResubmit(task: Task, userId: string): Promise<void> {
    // 检查任务状态
    if (task.status !== 'CREATED' && task.status !== 'CLAIMED') {
      throw new BadRequestException('任务状态不允许重新提交');
    }

    // 检查流程实例状态
    const processInstance = await this.processInstanceRepository.findOne({
      where: { id: task.processInstanceId },
    });

    if (!processInstance || processInstance.status !== ProcessInstanceStatus.RUNNING) {
      throw new BadRequestException('流程实例不在运行状态');
    }

    // 检查是否是被驳回的任务
    const rejectCount = await this.taskRejectRepository.count({
      where: {
        processInstanceId: task.processInstanceId,
        rejectToActivityId: task.taskDefinitionKey,
      },
    });

    if (rejectCount === 0) {
      throw new BadRequestException('该任务不是被驳回的任务');
    }

    // 检查操作人权限（必须是任务受派人或发起人）
    if (task.assignee && task.assignee !== userId) {
      const processInstance = await this.processInstanceRepository.findOne({
        where: { id: task.processInstanceId },
      });
      if (processInstance?.startUserId !== userId) {
        throw new BadRequestException('只有任务受派人或流程发起人可以重新提交');
      }
    }
  }

  /**
   * 获取最近的驳回记录
   */
  private async getLastRejectRecord(
    processInstanceId: string,
    activityId: string,
  ): Promise<TaskReject | null> {
    return this.taskRejectRepository.findOne({
      where: {
        processInstanceId,
        rejectToActivityId: activityId,
      },
      order: {
        createTime: 'DESC',
      },
    });
  }

  /**
   * 完成重新提交任务
   */
  private async completeResubmitTask(
    task: Task,
    dto: ResubmitTaskDto,
    lastReject: TaskReject,
    queryRunner: QueryRunner,
  ): Promise<Task> {
    // 更新任务状态为已完成
    await queryRunner.manager.update(Task, task.id, {
      status: 'COMPLETED',
      endTime: new Date(),
    });

    // 创建历史任务记录
    await this.historyService.createHistoricTask(
      {
        ...task,
        status: 'COMPLETED',
        endTime: new Date(),
        deleteReason: 'RESUBMITTED',
      },
      queryRunner,
    );

    return task;
  }

  /**
   * 记录重新提交历史
   */
  private async recordResubmitHistory(
    task: Task,
    dto: ResubmitTaskDto,
    lastReject: TaskReject,
    queryRunner: QueryRunner,
  ): Promise<void> {
    // 创建重新提交记录
    const resubmitRecord = queryRunner.manager.create(TaskReject, {
      id: this.generateUuid(),
      taskId: task.id,
      processInstanceId: task.processInstanceId,
      rejectFromActivityId: task.taskDefinitionKey,
      rejectFromActivityName: task.name,
      rejectToActivityId: lastReject.rejectFromActivityId,
      rejectToActivityName: lastReject.rejectFromActivityName,
      rejectType: 'RESUBMIT' as any,
      reason: dto.comment || '重新提交',
      operatorId: dto.userId,
      createTime: new Date(),
    });
    await queryRunner.manager.save(resubmitRecord);
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

#### 8.1.2 重新提交 API 设计

```typescript
// task/dto/resubmit.dto.ts
import { IsNotEmpty, IsString, IsOptional, IsObject, MaxLength } from 'class-validator';

export class ResubmitTaskDto {
  @IsString()
  @IsNotEmpty()
  userId: string;

  @IsObject()
  @IsOptional()
  variables?: Record<string, any>;

  @IsString()
  @IsOptional()
  @MaxLength(2000)
  comment?: string;
}

// task/controllers/task.controller.ts 扩展
@Controller('api/v1/tasks')
export class TaskController {
  constructor(
    private readonly resubmitService: ResubmitService,
  ) {}

  /**
   * 重新提交被驳回的任务
   * POST /api/v1/tasks/:id/resubmit
   */
  @Post(':id/resubmit')
  async resubmitTask(
    @Param('id') taskId: string,
    @Body() dto: ResubmitTaskDto,
  ) {
    return this.resubmitService.resubmitTask({
      taskId,
      ...dto,
    });
  }
}
```

---

### 8.2 并发控制机制

#### 8.2.1 任务锁服务设计

当多人同时操作同一任务时，需要通过锁机制保证数据一致性。

```typescript
// task/services/task-lock.service.ts
import { Injectable, BadRequestException, ConflictException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, QueryRunner } from 'typeorm';
import { Redis } from 'ioredis';
import { Inject } from '@nestjs/common';

import { Task } from '../entities/task.entity';

export interface TaskLock {
  taskId: string;
  userId: string;
  lockedAt: Date;
  expiresAt: Date;
}

@Injectable()
export class TaskLockService {
  private readonly LOCK_PREFIX = 'task:lock:';
  private readonly LOCK_TTL = 30000; // 30秒锁过期时间

  constructor(
    @Inject('REDIS_CLIENT')
    private readonly redis: Redis,
    @InjectRepository(Task)
    private readonly taskRepository: Repository<Task>,
    private readonly dataSource: DataSource,
  ) {}

  /**
   * 尝试获取任务锁
   */
  async acquireLock(taskId: string, userId: string): Promise<boolean> {
    const lockKey = `${this.LOCK_PREFIX}${taskId}`;
    const lockData = JSON.stringify({
      taskId,
      userId,
      lockedAt: new Date().toISOString(),
      expiresAt: new Date(Date.now() + this.LOCK_TTL).toISOString(),
    });

    // 使用 SET NX EX 原子操作
    const result = await this.redis.set(
      lockKey,
      lockData,
      'PX',
      this.LOCK_TTL,
      'NX',
    );

    return result === 'OK';
  }

  /**
   * 释放任务锁
   */
  async releaseLock(taskId: string, userId: string): Promise<boolean> {
    const lockKey = `${this.LOCK_PREFIX}${taskId}`;

    // 获取当前锁信息
    const lockData = await this.redis.get(lockKey);

    if (!lockData) {
      return true; // 锁不存在，视为已释放
    }

    const lock: TaskLock = JSON.parse(lockData);

    // 只有锁的持有者才能释放锁
    if (lock.userId !== userId) {
      return false;
    }

    await this.redis.del(lockKey);
    return true;
  }

  /**
   * 获取任务锁信息
   */
  async getLockInfo(taskId: string): Promise<TaskLock | null> {
    const lockKey = `${this.LOCK_PREFIX}${taskId}`;
    const lockData = await this.redis.get(lockKey);

    if (!lockData) {
      return null;
    }

    return JSON.parse(lockData);
  }

  /**
   * 续期任务锁
   */
  async renewLock(taskId: string, userId: string): Promise<boolean> {
    const lockKey = `${this.LOCK_PREFIX}${taskId}`;
    const lockData = await this.redis.get(lockKey);

    if (!lockData) {
      return false;
    }

    const lock: TaskLock = JSON.parse(lockData);

    if (lock.userId !== userId) {
      return false;
    }

    // 续期
    const newLockData = JSON.stringify({
      ...lock,
      expiresAt: new Date(Date.now() + this.LOCK_TTL).toISOString(),
    });

    await this.redis.set(lockKey, newLockData, 'PX', this.LOCK_TTL);
    return true;
  }

  /**
   * 强制释放锁（管理员操作）
   */
  async forceReleaseLock(taskId: string): Promise<void> {
    const lockKey = `${this.LOCK_PREFIX}${taskId}`;
    await this.redis.del(lockKey);
  }

  /**
   * 使用锁执行任务操作
   */
  async withLock<T>(
    taskId: string,
    userId: string,
    operation: () => Promise<T>,
  ): Promise<T> {
    // 1. 尝试获取锁
    const acquired = await this.acquireLock(taskId, userId);

    if (!acquired) {
      const lockInfo = await this.getLockInfo(taskId);
      throw new ConflictException(
        `任务正在被用户 ${lockInfo?.userId} 操作中，请稍后重试`,
      );
    }

    try {
      // 2. 执行操作
      return await operation();
    } finally {
      // 3. 释放锁
      await this.releaseLock(taskId, userId);
    }
  }
}
```

#### 8.2.2 乐观锁实现

```typescript
// task/entities/task.entity.ts 扩展
import { VersionColumn } from 'typeorm';

@Entity('task')
export class Task extends BaseEntity {
  // ... 其他字段

  @VersionColumn({ name: 'version' })
  version: number; // 乐观锁版本号
}

// task/services/task.service.ts 扩展
@Injectable()
export class TaskService {
  constructor(
    @InjectRepository(Task)
    private readonly taskRepository: Repository<Task>,
  ) {}

  /**
   * 使用乐观锁完成任务
   */
  async completeTaskWithOptimisticLock(
    taskId: string,
    userId: string,
    expectedVersion: number,
    variables?: Record<string, any>,
  ): Promise<Task> {
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();
    await queryRunner.startTransaction();

    try {
      // 1. 查询任务并检查版本
      const task = await queryRunner.manager.findOne(Task, {
        where: { id: taskId },
        lock: { mode: 'pessimistic_write' }, // 悲观锁配合乐观锁
      });

      if (!task) {
        throw new NotFoundException('任务不存在');
      }

      // 2. 版本检查
      if (task.version !== expectedVersion) {
        throw new ConflictException(
          `任务已被其他用户修改，请刷新后重试。当前版本: ${task.version}，期望版本: ${expectedVersion}`,
        );
      }

      // 3. 执行完成操作
      task.status = 'COMPLETED';
      task.endTime = new Date();
      if (variables) {
        task.variables = { ...task.variables, ...variables };
      }

      const savedTask = await queryRunner.manager.save(task);

      await queryRunner.commitTransaction();
      return savedTask;
    } catch (error) {
      await queryRunner.rollbackTransaction();
      throw error;
    } finally {
      await queryRunner.release();
    }
  }
}
```

#### 8.2.3 并发控制 API 设计

```typescript
// task/dto/task-lock.dto.ts
import { IsNotEmpty, IsString } from 'class-validator';

export class AcquireLockDto {
  @IsString()
  @IsNotEmpty()
  userId: string;
}

export class ReleaseLockDto {
  @IsString()
  @IsNotEmpty()
  userId: string;
}

// task/controllers/task-lock.controller.ts
@Controller('api/v1/tasks')
export class TaskLockController {
  constructor(private readonly taskLockService: TaskLockService) {}

  /**
   * 获取任务锁
   * POST /api/v1/tasks/:id/lock
   */
  @Post(':id/lock')
  async acquireLock(
    @Param('id') taskId: string,
    @Body() dto: AcquireLockDto,
  ) {
    const acquired = await this.taskLockService.acquireLock(taskId, dto.userId);
    
    if (!acquired) {
      const lockInfo = await this.taskLockService.getLockInfo(taskId);
      return {
        success: false,
        message: '任务正在被其他用户操作中',
        lockInfo,
      };
    }

    return {
      success: true,
      message: '锁获取成功',
    };
  }

  /**
   * 释放任务锁
   * DELETE /api/v1/tasks/:id/lock
   */
  @Delete(':id/lock')
  async releaseLock(
    @Param('id') taskId: string,
    @Body() dto: ReleaseLockDto,
  ) {
    const released = await this.taskLockService.releaseLock(taskId, dto.userId);
    
    return {
      success: released,
      message: released ? '锁释放成功' : '无权释放锁',
    };
  }

  /**
   * 获取锁状态
   * GET /api/v1/tasks/:id/lock
   */
  @Get(':id/lock')
  async getLockStatus(@Param('id') taskId: string) {
    const lockInfo = await this.taskLockService.getLockInfo(taskId);
    
    return {
      locked: !!lockInfo,
      lockInfo,
    };
  }

  /**
   * 续期锁
   * PUT /api/v1/tasks/:id/lock/renew
   */
  @Put(':id/lock/renew')
  async renewLock(
    @Param('id') taskId: string,
    @Body() dto: AcquireLockDto,
  ) {
    const renewed = await this.taskLockService.renewLock(taskId, dto.userId);
    
    return {
      success: renewed,
      message: renewed ? '锁续期成功' : '锁续期失败，请重新获取锁',
    };
  }
}
```

---

### 8.3 历史记录归档策略

#### 8.3.1 归档服务设计

```typescript
// history/services/history-archive.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, DataSource, QueryRunner, Between, MoreThan } from 'typeorm';
import { Cron, CronExpression } from '@nestjs/schedule';

import { HistoricProcessInstance } from '../entities/historic-process-instance.entity';
import { HistoricTask } from '../entities/historic-task.entity';
import { HistoricVariable } from '../entities/historic-variable.entity';
import { TaskReject } from '../../task/entities/task-reject.entity';
import { CcRecord } from '../../task/entities/cc-record.entity';

export interface ArchiveConfig {
  archiveAfterDays: number; // 归档阈值（天）
  batchSize: number; // 批量处理大小
  archiveTablePrefix: string; // 归档表前缀
}

@Injectable()
export class HistoryArchiveService {
  private readonly logger = new Logger(HistoryArchiveService.name);
  private readonly defaultConfig: ArchiveConfig = {
    archiveAfterDays: 90,
    batchSize: 1000,
    archiveTablePrefix: 'archive_',
  };

  constructor(
    @InjectRepository(HistoricProcessInstance)
    private readonly historicProcessInstanceRepository: Repository<HistoricProcessInstance>,
    @InjectRepository(HistoricTask)
    private readonly historicTaskRepository: Repository<HistoricTask>,
    @InjectRepository(HistoricVariable)
    private readonly historicVariableRepository: Repository<HistoricVariable>,
    @InjectRepository(TaskReject)
    private readonly taskRejectRepository: Repository<TaskReject>,
    @InjectRepository(CcRecord)
    private readonly ccRecordRepository: Repository<CcRecord>,
    private readonly dataSource: DataSource,
  ) {}

  /**
   * 定时归档任务（每天凌晨2点执行）
   */
  @Cron(CronExpression.EVERY_DAY_AT_2AM)
  async scheduledArchive(): Promise<void> {
    this.logger.log('开始执行历史数据归档任务...');
    
    try {
      const result = await this.archiveOldData(this.defaultConfig);
      this.logger.log(`归档任务完成: ${JSON.stringify(result)}`);
    } catch (error) {
      this.logger.error('归档任务失败', error);
    }
  }

  /**
   * 归档旧数据
   */
  async archiveOldData(config: ArchiveConfig): Promise<{
    archivedProcesses: number;
    archivedTasks: number;
    archivedVariables: number;
    archivedRejects: number;
    archivedCcRecords: number;
  }> {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - config.archiveAfterDays);

    const result = {
      archivedProcesses: 0,
      archivedTasks: 0,
      archivedVariables: 0,
      archivedRejects: 0,
      archivedCcRecords: 0,
    };

    // 1. 归档已完成的流程实例
    result.archivedProcesses = await this.archiveHistoricProcessInstances(
      cutoffDate,
      config.batchSize,
    );

    // 2. 归档历史任务
    result.archivedTasks = await this.archiveHistoricTasks(
      cutoffDate,
      config.batchSize,
    );

    // 3. 归档历史变量
    result.archivedVariables = await this.archiveHistoricVariables(
      cutoffDate,
      config.batchSize,
    );

    // 4. 归档驳回记录
    result.archivedRejects = await this.archiveTaskRejects(
      cutoffDate,
      config.batchSize,
    );

    // 5. 归档抄送记录
    result.archivedCcRecords = await this.archiveCcRecords(
      cutoffDate,
      config.batchSize,
    );

    return result;
  }

  /**
   * 归档历史流程实例
   */
  private async archiveHistoricProcessInstances(
    cutoffDate: Date,
    batchSize: number,
  ): Promise<number> {
    let totalArchived = 0;
    let hasMore = true;

    while (hasMore) {
      const instances = await this.historicProcessInstanceRepository.find({
        where: {
          endTime: Between(new Date(0), cutoffDate),
        },
        take: batchSize,
      });

      if (instances.length === 0) {
        hasMore = false;
        break;
      }

      // 插入归档表
      await this.insertIntoArchiveTable(
        'historic_process_instance',
        instances,
      );

      // 删除原表数据
      const ids = instances.map(i => i.id);
      await this.historicProcessInstanceRepository.delete(ids);

      totalArchived += instances.length;

      if (instances.length < batchSize) {
        hasMore = false;
      }
    }

    return totalArchived;
  }

  /**
   * 归档历史任务
   */
  private async archiveHistoricTasks(
    cutoffDate: Date,
    batchSize: number,
  ): Promise<number> {
    let totalArchived = 0;
    let hasMore = true;

    while (hasMore) {
      const tasks = await this.historicTaskRepository.find({
        where: {
          endTime: Between(new Date(0), cutoffDate),
        },
        take: batchSize,
      });

      if (tasks.length === 0) {
        hasMore = false;
        break;
      }

      await this.insertIntoArchiveTable('historic_task', tasks);

      const ids = tasks.map(t => t.id);
      await this.historicTaskRepository.delete(ids);

      totalArchived += tasks.length;

      if (tasks.length < batchSize) {
        hasMore = false;
      }
    }

    return totalArchived;
  }

  /**
   * 归档历史变量
   */
  private async archiveHistoricVariables(
    cutoffDate: Date,
    batchSize: number,
  ): Promise<number> {
    let totalArchived = 0;
    let hasMore = true;

    while (hasMore) {
      const variables = await this.historicVariableRepository.find({
        where: {
          createTime: Between(new Date(0), cutoffDate),
        },
        take: batchSize,
      });

      if (variables.length === 0) {
        hasMore = false;
        break;
      }

      await this.insertIntoArchiveTable('historic_variable', variables);

      const ids = variables.map(v => v.id);
      await this.historicVariableRepository.delete(ids);

      totalArchived += variables.length;

      if (variables.length < batchSize) {
        hasMore = false;
      }
    }

    return totalArchived;
  }

  /**
   * 归档驳回记录
   */
  private async archiveTaskRejects(
    cutoffDate: Date,
    batchSize: number,
  ): Promise<number> {
    let totalArchived = 0;
    let hasMore = true;

    while (hasMore) {
      const rejects = await this.taskRejectRepository.find({
        where: {
          createTime: Between(new Date(0), cutoffDate),
        },
        take: batchSize,
      });

      if (rejects.length === 0) {
        hasMore = false;
        break;
      }

      await this.insertIntoArchiveTable('task_reject', rejects);

      const ids = rejects.map(r => r.id);
      await this.taskRejectRepository.delete(ids);

      totalArchived += rejects.length;

      if (rejects.length < batchSize) {
        hasMore = false;
      }
    }

    return totalArchived;
  }

  /**
   * 归档抄送记录
   */
  private async archiveCcRecords(
    cutoffDate: Date,
    batchSize: number,
  ): Promise<number> {
    let totalArchived = 0;
    let hasMore = true;

    while (hasMore) {
      const ccRecords = await this.ccRecordRepository.find({
        where: {
          createTime: Between(new Date(0), cutoffDate),
          status: 'READ', // 只归档已读的抄送
        },
        take: batchSize,
      });

      if (ccRecords.length === 0) {
        hasMore = false;
        break;
      }

      await this.insertIntoArchiveTable('cc_record', ccRecords);

      const ids = ccRecords.map(c => c.id);
      await this.ccRecordRepository.delete(ids);

      totalArchived += ccRecords.length;

      if (ccRecords.length < batchSize) {
        hasMore = false;
      }
    }

    return totalArchived;
  }

  /**
   * 插入数据到归档表
   */
  private async insertIntoArchiveTable(
    tableName: string,
    data: any[],
  ): Promise<void> {
    if (data.length === 0) return;

    const archiveTableName = `archive_${tableName}`;
    
    // 使用原生 SQL 插入归档表
    const queryRunner = this.dataSource.createQueryRunner();
    await queryRunner.connect();

    try {
      for (const item of data) {
        const columns = Object.keys(item);
        const values = Object.values(item);
        const placeholders = columns.map(() => '?').join(', ');
        const columnNames = columns.map(c => `\`${c}\``).join(', ');

        await queryRunner.query(
          `INSERT INTO ${archiveTableName} (${columnNames}) VALUES (${placeholders})`,
          values,
        );
      }
    } finally {
      await queryRunner.release();
    }
  }

  /**
   * 手动触发归档
   */
  async manualArchive(archiveAfterDays: number): Promise<{
    success: boolean;
    result?: any;
    message?: string;
  }> {
    try {
      const config = {
        ...this.defaultConfig,
        archiveAfterDays,
      };

      const result = await this.archiveOldData(config);
      return {
        success: true,
        result,
      };
    } catch (error) {
      return {
        success: false,
        message: error.message,
      };
    }
  }
}
```

#### 8.3.2 归档 API 设计

```typescript
// history/controllers/history-archive.controller.ts
import { Controller, Post, Get, Body, Query } from '@nestjs/common';
import { HistoryArchiveService } from '../services/history-archive.service';

@Controller('api/v1/history/archive')
export class HistoryArchiveController {
  constructor(private readonly archiveService: HistoryArchiveService) {}

  /**
   * 手动触发归档
   * POST /api/v1/history/archive
   */
  @Post()
  async triggerArchive(@Body('archiveAfterDays') archiveAfterDays: number = 90) {
    return this.archiveService.manualArchive(archiveAfterDays);
  }

  /**
   * 获取归档状态
   * GET /api/v1/history/archive/status
   */
  @Get('status')
  async getArchiveStatus() {
    // 返回归档统计信息
    return {
      lastArchiveTime: null, // 从配置或数据库获取
      totalArchived: 0,
      nextScheduledTime: '02:00:00',
    };
  }
}
```

---

### 8.4 通知机制与消息队列集成

#### 8.4.1 通知服务设计

```typescript
// notification/services/notification.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue, Job } from 'bull';
import { EventBusService } from '../../core/services/event-bus.service';

export interface NotificationPayload {
  type: NotificationType;
  recipientId: string;
  recipientEmail?: string;
  recipientPhone?: string;
  title: string;
  content: string;
  data?: Record<string, any>;
  priority: 'high' | 'normal' | 'low';
  channels: NotificationChannel[];
}

export enum NotificationType {
  TASK_ASSIGNED = 'TASK_ASSIGNED',
  TASK_COMPLETED = 'TASK_COMPLETED',
  TASK_REJECTED = 'TASK_REJECTED',
  TASK_RESUBMITTED = 'TASK_RESUBMITTED',
  CC_RECEIVED = 'CC_RECEIVED',
  PROCESS_STARTED = 'PROCESS_STARTED',
  PROCESS_ENDED = 'PROCESS_ENDED',
  DEADLINE_REMINDER = 'DEADLINE_REMINDER',
}

export enum NotificationChannel {
  IN_APP = 'IN_APP',
  EMAIL = 'EMAIL',
  SMS = 'SMS',
  WECHAT = 'WECHAT',
  DINGTALK = 'DINGTALK',
  WEBHOOK = 'WEBHOOK',
}

@Injectable()
export class NotificationService {
  private readonly logger = new Logger(NotificationService.name);

  constructor(
    @InjectQueue('notification')
    private readonly notificationQueue: Queue,
    private readonly eventBus: EventBusService,
  ) {
    this.setupEventListeners();
  }

  /**
   * 设置事件监听
   */
  private setupEventListeners(): void {
    // 任务分配通知
    this.eventBus.on('task.assigned', async (data) => {
      await this.sendNotification({
        type: NotificationType.TASK_ASSIGNED,
        recipientId: data.assignee,
        title: '新任务分配',
        content: `您有一个新的任务需要处理: ${data.taskName}`,
        data: {
          taskId: data.taskId,
          processInstanceId: data.processInstanceId,
        },
        priority: 'high',
        channels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL],
      });
    });

    // 任务驳回通知
    this.eventBus.on('task.rejected', async (data) => {
      await this.sendNotification({
        type: NotificationType.TASK_REJECTED,
        recipientId: data.recipientId,
        title: '任务被驳回',
        content: `您的任务被驳回，原因: ${data.reason}`,
        data: {
          taskId: data.taskId,
          processInstanceId: data.processInstanceId,
          rejectType: data.rejectType,
        },
        priority: 'high',
        channels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL],
      });
    });

    // 抄送通知
    this.eventBus.on('cc.created', async (data) => {
      for (const record of data.ccRecords) {
        await this.sendNotification({
          type: NotificationType.CC_RECEIVED,
          recipientId: record.ccUserId,
          title: '您收到一份抄送',
          content: record.message || '您有一条新的抄送消息',
          data: {
            ccId: record.id,
            processInstanceId: data.processInstanceId,
          },
          priority: 'low',
          channels: [NotificationChannel.IN_APP],
        });
      }
    });

    // 任务重新提交通知
    this.eventBus.on('task.resubmitted', async (data) => {
      await this.sendNotification({
        type: NotificationType.TASK_RESUBMITTED,
        recipientId: data.nextAssignee,
        title: '任务已重新提交',
        content: `任务已重新提交，请审批`,
        data: {
          taskId: data.taskId,
          processInstanceId: data.processInstanceId,
        },
        priority: 'normal',
        channels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL],
      });
    });
  }

  /**
   * 发送通知
   */
  async sendNotification(payload: NotificationPayload): Promise<Job> {
    this.logger.log(`发送通知: ${payload.type} -> ${payload.recipientId}`);

    // 将通知任务加入队列
    return this.notificationQueue.add(
      'send',
      payload,
      {
        priority: this.getPriority(payload.priority),
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 1000,
        },
        removeOnComplete: 100,
        removeOnFail: 50,
      },
    );
  }

  /**
   * 批量发送通知
   */
  async sendBatchNotifications(payloads: NotificationPayload[]): Promise<Job[]> {
    const jobs = payloads.map(payload =>
      this.notificationQueue.add('send', payload, {
        priority: this.getPriority(payload.priority),
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 1000,
        },
      }),
    );

    return Promise.all(jobs);
  }

  /**
   * 发送定时提醒
   */
  async scheduleReminder(
    payload: NotificationPayload,
    delay: number,
  ): Promise<Job> {
    return this.notificationQueue.add(
      'send',
      payload,
      {
        delay,
        priority: this.getPriority(payload.priority),
      },
    );
  }

  /**
   * 获取优先级数值
   */
  private getPriority(priority: 'high' | 'normal' | 'low'): number {
    switch (priority) {
      case 'high':
        return 1;
      case 'normal':
        return 5;
      case 'low':
        return 10;
      default:
        return 5;
    }
  }
}
```

#### 8.4.2 通知处理器设计

```typescript
// notification/processors/notification.processor.ts
import { Processor, Process, OnQueueFailed, OnQueueCompleted } from '@nestjs/bull';
import { Job } from 'bull';
import { Logger } from '@nestjs/common';
import { Inject } from '@nestjs/common';

import { NotificationPayload, NotificationChannel } from '../services/notification.service';

@Processor('notification')
export class NotificationProcessor {
  private readonly logger = new Logger(NotificationProcessor.name);

  constructor(
    // 注入各种通知渠道的发送服务
    @Inject('EMAIL_SENDER')
    private readonly emailSender: EmailSender,
    @Inject('SMS_SENDER')
    private readonly smsSender: SmsSender,
    @Inject('IN_APP_SENDER')
    private readonly inAppSender: InAppSender,
    @Inject('WECHAT_SENDER')
    private readonly wechatSender: WechatSender,
    @Inject('DINGTALK_SENDER')
    private readonly dingtalkSender: DingtalkSender,
  ) {}

  @Process('send')
  async handleSend(job: Job<NotificationPayload>): Promise<void> {
    const payload = job.data;
    this.logger.log(`处理通知任务: ${job.id}, 类型: ${payload.type}`);

    // 并行发送到多个渠道
    const sendPromises = payload.channels.map(channel =>
      this.sendToChannel(channel, payload),
    );

    await Promise.allSettled(sendPromises);
  }

  /**
   * 发送到指定渠道
   */
  private async sendToChannel(
    channel: NotificationChannel,
    payload: NotificationPayload,
  ): Promise<void> {
    try {
      switch (channel) {
        case NotificationChannel.IN_APP:
          await this.inAppSender.send(payload);
          break;

        case NotificationChannel.EMAIL:
          if (payload.recipientEmail) {
            await this.emailSender.send(payload);
          }
          break;

        case NotificationChannel.SMS:
          if (payload.recipientPhone) {
            await this.smsSender.send(payload);
          }
          break;

        case NotificationChannel.WECHAT:
          await this.wechatSender.send(payload);
          break;

        case NotificationChannel.DINGTALK:
          await this.dingtalkSender.send(payload);
          break;

        case NotificationChannel.WEBHOOK:
          await this.sendWebhook(payload);
          break;

        default:
          this.logger.warn(`未知的通知渠道: ${channel}`);
      }
    } catch (error) {
      this.logger.error(`发送到渠道 ${channel} 失败: ${error.message}`);
      throw error;
    }
  }

  /**
   * 发送 Webhook
   */
  private async sendWebhook(payload: NotificationPayload): Promise<void> {
    // 实现 Webhook 发送逻辑
    const webhookUrl = process.env.WEBHOOK_URL;
    if (!webhookUrl) return;

    // 使用 HTTP 客户端发送
    // await this.httpService.post(webhookUrl, payload).toPromise();
  }

  @OnQueueCompleted()
  onCompleted(job: Job) {
    this.logger.log(`通知任务完成: ${job.id}`);
  }

  @OnQueueFailed()
  onFailed(job: Job, error: Error) {
    this.logger.error(`通知任务失败: ${job.id}, 错误: ${error.message}`);
  }
}
```

#### 8.4.3 站内信服务设计

```typescript
// notification/services/in-app-notification.service.ts
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In } from 'typeorm';

import { InAppNotification } from '../entities/in-app-notification.entity';
import { NotificationPayload } from './notification.service';

@Injectable()
export class InAppNotificationService {
  constructor(
    @InjectRepository(InAppNotification)
    private readonly notificationRepository: Repository<InAppNotification>,
  ) {}

  /**
   * 发送站内信
   */
  async send(payload: NotificationPayload): Promise<InAppNotification> {
    const notification = this.notificationRepository.create({
      id: this.generateUuid(),
      recipientId: payload.recipientId,
      type: payload.type,
      title: payload.title,
      content: payload.content,
      data: payload.data || {},
      isRead: false,
      createTime: new Date(),
    });

    return this.notificationRepository.save(notification);
  }

  /**
   * 获取用户通知列表
   */
  async getUserNotifications(
    userId: string,
    options: {
      isRead?: boolean;
      type?: string;
      page?: number;
      pageSize?: number;
    },
  ): Promise<[InAppNotification[], number]> {
    const queryBuilder = this.notificationRepository.createQueryBuilder('n');

    queryBuilder.where('n.recipient_id = :userId', { userId });

    if (options.isRead !== undefined) {
      queryBuilder.andWhere('n.is_read = :isRead', { isRead: options.isRead });
    }

    if (options.type) {
      queryBuilder.andWhere('n.type = :type', { type: options.type });
    }

    const page = options.page || 1;
    const pageSize = options.pageSize || 20;

    queryBuilder
      .skip((page - 1) * pageSize)
      .take(pageSize)
      .orderBy('n.create_time', 'DESC');

    return queryBuilder.getManyAndCount();
  }

  /**
   * 获取未读数量
   */
  async getUnreadCount(userId: string): Promise<number> {
    return this.notificationRepository.count({
      where: {
        recipientId: userId,
        isRead: false,
      },
    });
  }

  /**
   * 标记为已读
   */
  async markAsRead(notificationId: string, userId: string): Promise<void> {
    await this.notificationRepository.update(
      {
        id: notificationId,
        recipientId: userId,
      },
      {
        isRead: true,
        readTime: new Date(),
      },
    );
  }

  /**
   * 批量标记已读
   */
  async markBatchAsRead(notificationIds: string[], userId: string): Promise<void> {
    await this.notificationRepository.update(
      {
        id: In(notificationIds),
        recipientId: userId,
      },
      {
        isRead: true,
        readTime: new Date(),
      },
    );
  }

  /**
   * 全部标记已读
   */
  async markAllAsRead(userId: string): Promise<void> {
    await this.notificationRepository.update(
      {
        recipientId: userId,
        isRead: false,
      },
      {
        isRead: true,
        readTime: new Date(),
      },
    );
  }

  private generateUuid(): string {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
      const r = (Math.random() * 16) | 0;
      const v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}
```

#### 8.4.4 通知 API 设计

```typescript
// notification/controllers/notification.controller.ts
import { Controller, Get, Post, Body, Param, Query } from '@nestjs/common';
import { InAppNotificationService } from '../services/in-app-notification.service';

@Controller('api/v1/notifications')
export class NotificationController {
  constructor(
    private readonly inAppNotificationService: InAppNotificationService,
  ) {}

  /**
   * 获取通知列表
   * GET /api/v1/notifications
   */
  @Get()
  async getNotifications(
    @Query('userId') userId: string,
    @Query('isRead') isRead?: string,
    @Query('type') type?: string,
    @Query('page') page?: number,
    @Query('pageSize') pageSize?: number,
  ) {
    return this.inAppNotificationService.getUserNotifications(userId, {
      isRead: isRead === 'true' ? true : isRead === 'false' ? false : undefined,
      type,
      page: page ? parseInt(page as any) : 1,
      pageSize: pageSize ? parseInt(pageSize as any) : 20,
    });
  }

  /**
   * 获取未读数量
   * GET /api/v1/notifications/unread-count
   */
  @Get('unread-count')
  async getUnreadCount(@Query('userId') userId: string) {
    return {
      count: await this.inAppNotificationService.getUnreadCount(userId),
    };
  }

  /**
   * 标记已读
   * POST /api/v1/notifications/:id/read
   */
  @Post(':id/read')
  async markAsRead(
    @Param('id') notificationId: string,
    @Body('userId') userId: string,
  ) {
    await this.inAppNotificationService.markAsRead(notificationId, userId);
    return { success: true };
  }

  /**
   * 批量标记已读
   * POST /api/v1/notifications/batch-read
   */
  @Post('batch-read')
  async markBatchAsRead(
    @Body('notificationIds') notificationIds: string[],
    @Body('userId') userId: string,
  ) {
    await this.inAppNotificationService.markBatchAsRead(notificationIds, userId);
    return { success: true };
  }

  /**
   * 全部标记已读
   * POST /api/v1/notifications/read-all
   */
  @Post('read-all')
  async markAllAsRead(@Body('userId') userId: string) {
    await this.inAppNotificationService.markAllAsRead(userId);
    return { success: true };
  }
}
```

---

## 九、新增数据库表结构

### 9.1 站内信通知表

```sql
-- 站内信通知表
CREATE TABLE `in_app_notification` (
  `id` varchar(64) NOT NULL,
  `recipient_id` varchar(64) NOT NULL COMMENT '接收人ID',
  `type` varchar(50) NOT NULL COMMENT '通知类型',
  `title` varchar(255) NOT NULL COMMENT '标题',
  `content` text COMMENT '内容',
  `data` json DEFAULT NULL COMMENT '附加数据',
  `is_read` tinyint(1) DEFAULT '0' COMMENT '是否已读',
  `read_time` datetime DEFAULT NULL COMMENT '阅读时间',
  `create_time` datetime NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`),
  KEY `idx_recipient_id` (`recipient_id`),
  KEY `idx_is_read` (`is_read`),
  KEY `idx_create_time` (`create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='站内信通知表';
```

### 9.2 归档表结构

```sql
-- 归档历史流程实例表
CREATE TABLE `archive_historic_process_instance` (
  `id` varchar(64) NOT NULL,
  `process_definition_id` varchar(64) NOT NULL,
  `business_key` varchar(64) DEFAULT NULL,
  `start_time` datetime NOT NULL,
  `end_time` datetime DEFAULT NULL,
  `duration` bigint DEFAULT NULL,
  `start_user_id` varchar(64) DEFAULT NULL,
  `delete_reason` varchar(255) DEFAULT NULL,
  `status` varchar(20) NOT NULL,
  `archive_time` datetime NOT NULL COMMENT '归档时间',
  PRIMARY KEY (`id`),
  KEY `idx_end_time` (`end_time`),
  KEY `idx_archive_time` (`archive_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='归档历史流程实例表';

-- 归档历史任务表
CREATE TABLE `archive_historic_task` (
  `id` varchar(64) NOT NULL,
  `process_instance_id` varchar(64) NOT NULL,
  `task_def_key` varchar(64) NOT NULL,
  `name` varchar(128) DEFAULT NULL,
  `assignee` varchar(64) DEFAULT NULL,
  `start_time` datetime NOT NULL,
  `end_time` datetime DEFAULT NULL,
  `duration` bigint DEFAULT NULL,
  `status` varchar(20) NOT NULL,
  `archive_time` datetime NOT NULL COMMENT '归档时间',
  PRIMARY KEY (`id`),
  KEY `idx_process_instance_id` (`process_instance_id`),
  KEY `idx_archive_time` (`archive_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='归档历史任务表';

-- 归档驳回记录表
CREATE TABLE `archive_task_reject` (
  `id` varchar(64) NOT NULL,
  `task_id` varchar(64) NOT NULL,
  `process_instance_id` varchar(64) NOT NULL,
  `reject_from_activity_id` varchar(64) NOT NULL,
  `reject_to_activity_id` varchar(64) NOT NULL,
  `reject_type` varchar(20) NOT NULL,
  `reason` text,
  `operator_id` varchar(64) NOT NULL,
  `create_time` datetime NOT NULL,
  `archive_time` datetime NOT NULL COMMENT '归档时间',
  PRIMARY KEY (`id`),
  KEY `idx_archive_time` (`archive_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='归档驳回记录表';

-- 归档抄送记录表
CREATE TABLE `archive_cc_record` (
  `id` varchar(64) NOT NULL,
  `process_instance_id` varchar(64) NOT NULL,
  `cc_user_id` varchar(64) NOT NULL,
  `cc_type` varchar(20) NOT NULL,
  `cc_source` varchar(20) NOT NULL,
  `sender_id` varchar(64) NOT NULL,
  `message` text,
  `status` varchar(20) DEFAULT 'UNREAD',
  `create_time` datetime NOT NULL,
  `archive_time` datetime NOT NULL COMMENT '归档时间',
  PRIMARY KEY (`id`),
  KEY `idx_archive_time` (`archive_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='归档抄送记录表';
```

---

## 十、新增 API 接口汇总

### 10.1 重新提交接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| POST | /api/v1/tasks/:id/resubmit | 重新提交被驳回的任务 |

### 10.2 任务锁接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| POST | /api/v1/tasks/:id/lock | 获取任务锁 |
| DELETE | /api/v1/tasks/:id/lock | 释放任务锁 |
| GET | /api/v1/tasks/:id/lock | 获取锁状态 |
| PUT | /api/v1/tasks/:id/lock/renew | 续期锁 |

### 10.3 归档接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| POST | /api/v1/history/archive | 手动触发归档 |
| GET | /api/v1/history/archive/status | 获取归档状态 |

### 10.4 通知接口

| 方法 | 路径 | 描述 |
|-----|------|------|
| GET | /api/v1/notifications | 获取通知列表 |
| GET | /api/v1/notifications/unread-count | 获取未读数量 |
| POST | /api/v1/notifications/:id/read | 标记已读 |
| POST | /api/v1/notifications/batch-read | 批量标记已读 |
| POST | /api/v1/notifications/read-all | 全部标记已读 |

---

## 十一、新增事件定义

### 11.1 重新提交事件

| 事件名 | 描述 | 数据 |
|-------|------|------|
| task.resubmitted | 任务重新提交 | taskId, processInstanceId, userId, originalRejectType, variables |

### 11.2 通知事件

| 事件名 | 描述 | 数据 |
|-------|------|------|
| notification.task.assigned | 任务分配通知 | recipientId, taskId, taskName, processInstanceId |
| notification.task.rejected | 任务驳回通知 | recipientId, taskId, reason, rejectType |
| notification.cc.created | 抄送创建通知 | ccRecords, processInstanceId |
| notification.task.resubmitted | 任务重新提交通知 | recipientId, taskId, processInstanceId |

---

## 十二、总结

本文档补充设计了以下核心功能：

1. **驳回操作功能**：区分退回、驳回、拒绝三种操作类型，支持多种驳回策略配置
2. **抄送操作功能**：支持手动抄送和自动抄送，支持用户、组、角色三种抄送对象
3. **退回策略设计**：支持退回到上一节点、发起人、指定节点、任意历史节点等多种策略
4. **相同步骤多人的退回策略**：支持全部退回、仅当前退回、多数人退回、保留已完成、重置所有、等待完成、立即退回等七种策略

### 高级场景设计补充：

5. **驳回后重新提交流程**：支持被驳回任务的重新提交，包含验证、历史记录、事件发布等完整流程
6. **并发控制机制**：基于 Redis 的分布式锁 + 乐观锁双重保障，确保多人同时操作的数据一致性
7. **历史记录归档策略**：定时归档 + 手动归档，支持批量处理，包含流程、任务、变量、驳回、抄送等全量数据归档
8. **通知机制与消息队列集成**：基于 Bull 队列的异步通知系统，支持站内信、邮件、短信、微信、钉钉、Webhook 等多渠道通知

这些功能设计完善了流程引擎的任务操作能力，满足企业级工作流的各种复杂场景需求。
