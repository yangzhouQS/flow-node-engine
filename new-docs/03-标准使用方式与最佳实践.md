# Flowable Engine 标准使用方式与最佳实践

## 1. 项目初始化配置

### 1.1 基础配置

#### 1.1.1 Maven依赖配置

```xml
<dependencies>
    <!-- Flowable流程引擎核心 -->
    <dependency>
        <groupId>org.flowable</groupId>
        <artifactId>flowable-engine</artifactId>
        <version>7.0.0</version>
    </dependency>
    
    <!-- Flowable应用引擎 -->
    <dependency>
        <groupId>org.flowable</groupId>
        <artifactId>flowable-app-engine</artifactId>
        <version>7.0.0</version>
    </dependency>
    
    <!-- Flowable DMN引擎 -->
    <dependency>
        <groupId>org.flowable</groupId>
        <artifactId>flowable-dmn-engine</artifactId>
        <version>7.0.0</version>
    </dependency>
    
    <!-- Flowable CMMN引擎 -->
    <dependency>
        <groupId>org.flowable</groupId>
        <artifactId>flowable-cmmn-engine</artifactId>
        <version>7.0.0</version>
    </dependency>
    
    <!-- Flowable身份管理 -->
    <dependency>
        <groupId>org.flowable</groupId>
        <artifactId>flowable-idm-engine</artifactId>
        <version>7.0.0</version>
    </dependency>
    
    <!-- 数据库驱动（以MySQL为例） -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>8.0.33</version>
    </dependency>
</dependencies>
```

#### 1.1.2 Spring Boot集成配置

```xml
<dependencies>
    <!-- Flowable Spring Boot Starter -->
    <dependency>
        <groupId>org.flowable</groupId>
        <artifactId>flowable-spring-boot-starter</artifactId>
        <version>7.0.0</version>
    </dependency>
    
    <!-- Spring Boot Web -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
</dependencies>
```

### 1.2 配置文件

#### 1.2.1 flowable.cfg.xml配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="processEngineConfiguration" class="org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration">
        <!-- 数据库配置 -->
        <property name="jdbcUrl" value="jdbc:mysql://localhost:3306/flowable?useSSL=false&serverTimezone=UTC"/>
        <property name="jdbcDriver" value="com.mysql.cj.jdbc.Driver"/>
        <property name="jdbcUsername" value="flowable"/>
        <property name="jdbcPassword" value="flowable"/>
        
        <!-- 数据库表更新策略 -->
        <!-- true: 自动创建和更新表结构 -->
        <!-- false: 不自动更新，需要手动执行SQL脚本 -->
        <property name="databaseSchemaUpdate" value="true"/>
        
        <!-- 历史级别 -->
        <!-- none: 不记录历史 -->
        <!-- activity: 记录活动实例历史 -->
        <!-- audit: 记录审计历史 -->
        <!-- full: 记录完整历史 -->
        <property name="history" value="audit"/>
        
        <!-- 异步执行器激活 -->
        <property name="asyncExecutorActivate" value="true"/>
        
        <!-- 异步历史执行器激活 -->
        <property name="asyncHistoryExecutorActivate" value="true"/>
        
        <!-- 邮件服务器配置 -->
        <property name="mailServerHost" value="smtp.gmail.com"/>
        <property name="mailServerPort" value="587"/>
        <property name="mailServerUsername" value="your-email@gmail.com"/>
        <property name="mailServerPassword" value="your-password"/>
        <property name="mailServerUseSSL" value="false"/>
        <property name="mailServerUseTLS" value="true"/>
    </bean>

</beans>
```

#### 1.2.2 application.yml配置（Spring Boot）

```yaml
flowable:
  # 数据库配置
  datasource:
    url: jdbc:mysql://localhost:3306/flowable?useSSL=false&serverTimezone=UTC
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: flowable
    password: flowable
  
  # 数据库表更新策略
  database-schema-update: true
  
  # 历史级别
  history-level: audit
  
  # 异步执行器配置
  async-executor-activate: true
  async-history-executor-activate: true
  
  # 邮件服务器配置
  mail:
    server:
      host: smtp.gmail.com
      port: 587
      username: your-email@gmail.com
      password: your-password
      use-ssl: false
      use-tls: true
  
  # 流程定义缓存
  process-definition-cache-limit: 100
  
  # 作业执行器配置
  job-executor:
    activate: true
    max-async-jobs-due-per-acquisition: 100
    default-async-job-acquire-wait-time: 5000
    default-async-job-acquire-time: 10000
  
  # 流程图生成配置
  diagram:
    font-name: Arial
    activity-font-name: Arial
    label-font-name: Arial
    annotation-font-name: Arial
```

### 1.3 环境变量配置

#### 1.3.1 环境变量示例

```bash
# 数据库配置
export FLOWABLE_DATASOURCE_URL=jdbc:mysql://localhost:3306/flowable
export FLOWABLE_DATASOURCE_USERNAME=flowable
export FLOWABLE_DATASOURCE_PASSWORD=flowable

# 邮件服务器配置
export FLOWABLE_MAIL_SERVER_HOST=smtp.gmail.com
export FLOWABLE_MAIL_SERVER_PORT=587
export FLOWABLE_MAIL_SERVER_USERNAME=your-email@gmail.com
export FLOWABLE_MAIL_SERVER_PASSWORD=your-password

# 异步执行器配置
export FLOWABLE_ASYNC_EXECUTOR_ACTIVATE=true
export FLOWABLE_ASYNC_HISTORY_EXECUTOR_ACTIVATE=true
```

#### 1.3.2 在配置文件中使用环境变量

```yaml
flowable:
  datasource:
    url: ${FLOWABLE_DATASOURCE_URL:jdbc:mysql://localhost:3306/flowable}
    username: ${FLOWABLE_DATASOURCE_USERNAME:flowable}
    password: ${FLOWABLE_DATASOURCE_PASSWORD:flowable}
```

### 1.4 启动流程

#### 1.4.1 独立模式启动

```java
import org.flowable.engine.ProcessEngine;
import org.flowable.engine.ProcessEngineConfiguration;
import org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration;

public class FlowableStandalone {
    public static void main(String[] args) {
        // 创建流程引擎配置
        ProcessEngineConfiguration processEngineConfiguration = 
            StandaloneProcessEngineConfiguration
                .createStandaloneProcessEngineConfiguration()
                .setJdbcUrl("jdbc:mysql://localhost:3306/flowable")
                .setJdbcUsername("flowable")
                .setJdbcPassword("flowable")
                .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);
        
        // 构建流程引擎
        ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine();
        
        // 启动执行器
        processEngine.startExecutors();
        
        System.out.println("Flowable引擎启动成功！");
    }
}
```

#### 1.4.2 Spring Boot模式启动

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class FlowableApplication {
    public static void main(String[] args) {
        SpringApplication.run(FlowableApplication.class, args);
        System.out.println("Flowable Spring Boot应用启动成功！");
    }
}
```

#### 1.4.3 从配置文件启动

```java
import org.flowable.engine.ProcessEngine;
import org.flowable.engine.ProcessEngineConfiguration;

public class FlowableConfigFile {
    public static void main(String[] args) {
        // 从默认配置文件创建流程引擎
        ProcessEngineConfiguration processEngineConfiguration = 
            ProcessEngineConfiguration
                .createProcessEngineConfigurationFromResourceDefault();
        
        // 构建流程引擎
        ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine();
        
        // 启动执行器
        processEngine.startExecutors();
        
        System.out.println("Flowable引擎启动成功！");
    }
}
```

## 2. 核心功能代码示例

### 2.1 流程部署

#### 2.1.1 部署BPMN文件

```java
import org.flowable.engine.RepositoryService;
import org.flowable.engine.repository.Deployment;

public class ProcessDeploymentExample {
    
    public void deployProcess(RepositoryService repositoryService) {
        // 创建部署
        Deployment deployment = repositoryService.createDeployment()
            .name("请假流程")
            .category("人力资源")
            .addClasspathResource("processes/leave-request.bpmn20.xml")
            .deploy();
        
        System.out.println("流程部署成功，部署ID: " + deployment.getId());
    }
}
```

#### 2.1.2 部署ZIP文件

```java
import org.flowable.engine.RepositoryService;
import org.flowable.engine.repository.Deployment;
import java.io.FileInputStream;

public class ZipDeploymentExample {
    
    public void deployZip(RepositoryService repositoryService) throws Exception {
        // 部署ZIP文件
        Deployment deployment = repositoryService.createDeployment()
            .name("流程包")
            .addZipInputStream(new FileInputStream("processes.zip"))
            .deploy();
        
        System.out.println("流程包部署成功，部署ID: " + deployment.getId());
    }
}
```

#### 2.1.3 查询部署

```java
import org.flowable.engine.RepositoryService;
import org.flowable.engine.repository.Deployment;
import org.flowable.engine.repository.DeploymentQuery;
import java.util.List;

public class DeploymentQueryExample {
    
    public void queryDeployments(RepositoryService repositoryService) {
        // 查询所有部署
        List<Deployment> deployments = repositoryService.createDeploymentQuery()
            .list();
        
        System.out.println("总部署数: " + deployments.size());
        
        // 按分类查询
        List<Deployment> hrDeployments = repositoryService.createDeploymentQuery()
            .deploymentCategory("人力资源")
            .list();
        
        System.out.println("人力资源流程部署数: " + hrDeployments.size());
    }
}
```

### 2.2 流程启动

#### 2.2.1 通过流程定义键启动

```java
import org.flowable.engine.RuntimeService;
import org.flowable.engine.runtime.ProcessInstance;
import java.util.HashMap;
import java.util.Map;

public class StartProcessByKeyExample {
    
    public void startProcess(RuntimeService runtimeService) {
        // 准备流程变量
        Map<String, Object> variables = new HashMap<>();
        variables.put("applicant", "张三");
        variables.put("days", 3);
        variables.put("reason", "个人事务");
        
        // 启动流程实例
        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(
            "leaveRequest",  // 流程定义键
            "LR-2024-001",   // 业务键
            variables         // 流程变量
        );
        
        System.out.println("流程实例启动成功，实例ID: " + processInstance.getId());
        System.out.println("业务键: " + processInstance.getBusinessKey());
    }
}
```

#### 2.2.2 通过流程定义ID启动

```java
import org.flowable.engine.RuntimeService;
import org.flowable.engine.runtime.ProcessInstance;

public class StartProcessByIdExample {
    
    public void startProcess(RuntimeService runtimeService) {
        // 启动流程实例
        ProcessInstance processInstance = runtimeService.startProcessInstanceById(
            "leaveRequest:1:12345"  // 流程定义ID
        );
        
        System.out.println("流程实例启动成功，实例ID: " + processInstance.getId());
    }
}
```

#### 2.2.3 通过消息启动

```java
import org.flowable.engine.RuntimeService;
import org.flowable.engine.runtime.ProcessInstance;
import java.util.HashMap;
import java.util.Map;

public class StartProcessByMessageExample {
    
    public void startProcessByMessage(RuntimeService runtimeService) {
        // 准备消息变量
        Map<String, Object> variables = new HashMap<>();
        variables.put("customerId", "CUST-001");
        variables.put("orderAmount", 1000.0);
        
        // 通过消息启动流程实例
        ProcessInstance processInstance = runtimeService.startProcessInstanceByMessage(
            "orderReceived",  // 消息名称
            "ORD-2024-001",   // 业务键
            variables         // 消息变量
        );
        
        System.out.println("流程实例启动成功，实例ID: " + processInstance.getId());
    }
}
```

### 2.3 任务处理

#### 2.3.1 查询任务

```java
import org.flowable.engine.TaskService;
import org.flowable.task.api.Task;
import org.flowable.task.api.TaskQuery;
import java.util.List;

public class TaskQueryExample {
    
    public void queryTasks(TaskService taskService) {
        // 查询指定用户的任务
        List<Task> tasks = taskService.createTaskQuery()
            .taskAssignee("张三")
            .orderByTaskCreateTime()
            .desc()
            .list();
        
        System.out.println("张三的任务数: " + tasks.size());
        
        for (Task task : tasks) {
            System.out.println("任务ID: " + task.getId());
            System.out.println("任务名称: " + task.getName());
            System.out.println("创建时间: " + task.getCreateTime());
        }
    }
}
```

#### 2.3.2 认领任务

```java
import org.flowable.engine.TaskService;

public class TaskClaimExample {
    
    public void claimTask(TaskService taskService, String taskId, String userId) {
        // 认领任务
        taskService.claim(taskId, userId);
        System.out.println("任务认领成功");
    }
}
```

#### 2.3.3 完成任务

```java
import org.flowable.engine.TaskService;
import java.util.HashMap;
import java.util.Map;

public class TaskCompleteExample {
    
    public void completeTask(TaskService taskService, String taskId) {
        // 完成任务
        taskService.complete(taskId);
        System.out.println("任务完成成功");
    }
    
    public void completeTaskWithVariables(TaskService taskService, String taskId) {
        // 准备任务变量
        Map<String, Object> variables = new HashMap<>();
        variables.put("approved", true);
        variables.put("comment", "同意请假申请");
        
        // 完成任务并传递变量
        taskService.complete(taskId, variables);
        System.out.println("任务完成成功，已传递变量");
    }
}
```

#### 2.3.4 转派任务

```java
import org.flowable.engine.TaskService;

public class TaskDelegateExample {
    
    public void delegateTask(TaskService taskService, String taskId, String userId) {
        // 转派任务
        taskService.delegateTask(taskId, userId);
        System.out.println("任务转派成功");
    }
}
```

### 2.4 变量操作

#### 2.4.1 设置变量

```java
import org.flowable.engine.RuntimeService;
import java.util.HashMap;
import java.util.Map;

public class VariableSetExample {
    
    public void setVariables(RuntimeService runtimeService, String executionId) {
        // 设置单个变量
        runtimeService.setVariable(executionId, "applicant", "张三");
        
        // 批量设置变量
        Map<String, Object> variables = new HashMap<>();
        variables.put("days", 3);
        variables.put("reason", "个人事务");
        variables.put("approved", false);
        runtimeService.setVariables(executionId, variables);
        
        System.out.println("变量设置成功");
    }
}
```

#### 2.4.2 获取变量

```java
import org.flowable.engine.RuntimeService;
import java.util.Map;

public class VariableGetExample {
    
    public void getVariables(RuntimeService runtimeService, String executionId) {
        // 获取所有变量
        Map<String, Object> variables = runtimeService.getVariables(executionId);
        
        System.out.println("流程变量:");
        for (Map.Entry<String, Object> entry : variables.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
        
        // 获取单个变量
        String applicant = (String) runtimeService.getVariable(executionId, "applicant");
        Integer days = (Integer) runtimeService.getVariable(executionId, "days");
        
        System.out.println("申请人: " + applicant);
        System.out.println("请假天数: " + days);
    }
}
```

#### 2.4.3 删除变量

```java
import org.flowable.engine.RuntimeService;
import java.util.Arrays;
import java.util.List;

public class VariableRemoveExample {
    
    public void removeVariables(RuntimeService runtimeService, String executionId) {
        // 删除单个变量
        runtimeService.removeVariable(executionId, "temporaryData");
        
        // 批量删除变量
        List<String> variableNames = Arrays.asList("temp1", "temp2", "temp3");
        runtimeService.removeVariables(executionId, variableNames);
        
        System.out.println("变量删除成功");
    }
}
```

### 2.5 流程查询

#### 2.5.1 查询流程实例

```java
import org.flowable.engine.RuntimeService;
import org.flowable.engine.runtime.ProcessInstance;
import org.flowable.engine.runtime.ProcessInstanceQuery;
import java.util.List;

public class ProcessInstanceQueryExample {
    
    public void queryProcessInstances(RuntimeService runtimeService) {
        // 查询所有运行中的流程实例
        List<ProcessInstance> processInstances = runtimeService.createProcessInstanceQuery()
            .active()
            .list();
        
        System.out.println("运行中的流程实例数: " + processInstances.size());
        
        // 按业务键查询
        ProcessInstance processInstance = runtimeService.createProcessInstanceQuery()
            .processInstanceBusinessKey("LR-2024-001")
            .singleResult();
        
        if (processInstance != null) {
            System.out.println("流程实例ID: " + processInstance.getId());
            System.out.println("流程定义ID: " + processInstance.getProcessDefinitionId());
            System.out.println("开始时间: " + processInstance.getStartTime());
        }
    }
}
```

#### 2.5.2 按变量查询流程实例

```java
import org.flowable.engine.RuntimeService;
import org.flowable.engine.runtime.ProcessInstance;
import java.util.List;

public class ProcessInstanceVariableQueryExample {
    
    public void queryByVariable(RuntimeService runtimeService) {
        // 查询变量值等于指定值的流程实例
        List<ProcessInstance> processInstances = runtimeService.createProcessInstanceQuery()
            .variableValueEquals("applicant", "张三")
            .list();
        
        System.out.println("申请人张三的流程实例数: " + processInstances.size());
        
        // 查询变量值包含指定字符串的流程实例
        List<ProcessInstance> matchedInstances = runtimeService.createProcessInstanceQuery()
            .variableValueLike("reason", "%事%")
            .list();
        
        System.out.println("原因包含'事'的流程实例数: " + matchedInstances.size());
    }
}
```

### 2.6 历史查询

#### 2.6.1 查询历史流程实例

```java
import org.flowable.engine.HistoryService;
import org.flowable.engine.history.HistoricProcessInstance;
import org.flowable.engine.history.HistoricProcessInstanceQuery;
import java.util.List;

public class HistoryProcessInstanceExample {
    
    public void queryHistoryProcessInstances(HistoryService historyService) {
        // 查询所有历史流程实例
        List<HistoricProcessInstance> historicProcessInstances = 
            historyService.createHistoricProcessInstanceQuery()
                .orderByProcessInstanceStartTime()
                .desc()
                .list();
        
        System.out.println("历史流程实例数: " + historicProcessInstances.size());
        
        // 按业务键查询
        HistoricProcessInstance historicProcessInstance = 
            historyService.createHistoricProcessInstanceQuery()
                .processInstanceBusinessKey("LR-2024-001")
                .singleResult();
        
        if (historicProcessInstance != null) {
            System.out.println("流程实例ID: " + historicProcessInstance.getId());
            System.out.println("流程定义ID: " + historicProcessInstance.getProcessDefinitionId());
            System.out.println("开始时间: " + historicProcessInstance.getStartTime());
            System.out.println("结束时间: " + historicProcessInstance.getEndTime());
            System.out.println("持续时间: " + historicProcessInstance.getDurationInMillis() + "ms");
        }
    }
}
```

#### 2.6.2 查询历史任务

```java
import org.flowable.engine.HistoryService;
import org.flowable.task.api.history.HistoricTaskInstance;
import org.flowable.task.api.history.HistoricTaskInstanceQuery;
import java.util.List;

public class HistoryTaskExample {
    
    public void queryHistoryTasks(HistoryService historyService) {
        // 查询指定用户的历史任务
        List<HistoricTaskInstance> historicTasks = 
            historyService.createHistoricTaskInstanceQuery()
                .taskAssignee("张三")
                .orderByHistoricTaskInstanceEndTime()
                .desc()
                .list();
        
        System.out.println("张三的历史任务数: " + historicTasks.size());
        
        for (HistoricTaskInstance historicTask : historicTasks) {
            System.out.println("任务ID: " + historicTask.getId());
            System.out.println("任务名称: " + historicTask.getName());
            System.out.println("创建时间: " + historicTask.getCreateTime());
            System.out.println("完成时间: " + historicTask.getEndTime());
            System.out.println("持续时间: " + historicTask.getDurationInMillis() + "ms");
        }
    }
}
```

### 2.7 错误处理

#### 2.7.1 基础错误处理

```java
import org.flowable.common.engine.api.FlowableException;
import org.flowable.common.engine.api.FlowableObjectNotFoundException;

public class ErrorHandlingExample {
    
    public void completeTaskWithErrorHandling(TaskService taskService, String taskId) {
        try {
            // 完成任务
            taskService.complete(taskId);
            System.out.println("任务完成成功");
        } catch (FlowableObjectNotFoundException e) {
            // 任务不存在
            System.err.println("任务不存在: " + taskId);
            e.printStackTrace();
        } catch (FlowableException e) {
            // 其他Flowable异常
            System.err.println("任务完成失败: " + e.getMessage());
            e.printStackTrace();
        }
    }
}
```

#### 2.7.2 边界情况处理

```java
import org.flowable.engine.RuntimeService;
import org.flowable.engine.TaskService;
import org.flowable.common.engine.api.FlowableException;
import org.flowable.task.api.Task;
import java.util.List;

public class BoundaryCaseExample {
    
    public void handleBoundaryCases(TaskService taskService, RuntimeService runtimeService) {
        String taskId = "TASK-001";
        
        // 检查任务是否存在
        Task task = taskService.createTaskQuery().taskId(taskId).singleResult();
        if (task == null) {
            System.err.println("任务不存在: " + taskId);
            return;
        }
        
        // 检查任务是否已分配
        if (task.getAssignee() == null) {
            System.err.println("任务未分配: " + taskId);
            return;
        }
        
        // 检查任务是否已完成
        if (task.getEndTime() != null) {
            System.err.println("任务已完成: " + taskId);
            return;
        }
        
        // 完成任务
        try {
            taskService.complete(taskId);
            System.out.println("任务完成成功");
        } catch (FlowableException e) {
            System.err.println("任务完成失败: " + e.getMessage());
            
            // 回滚或补偿操作
            // ...
        }
    }
}
```

## 3. 最佳实践

### 3.1 性能优化技巧

#### 3.1.1 使用流程定义缓存

```java
import org.flowable.engine.RepositoryService;
import org.flowable.engine.repository.ProcessDefinition;

public class ProcessDefinitionCacheExample {
    
    public void useProcessDefinitionCache(RepositoryService repositoryService) {
        // 启用流程定义缓存
        // 在配置文件中设置：
        // <property name="enableProcessDefinitionInfoCache" value="true"/>
        
        // 查询流程定义时会自动使用缓存
        ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()
            .processDefinitionKey("leaveRequest")
            .singleResult();
        
        System.out.println("流程定义ID: " + processDefinition.getId());
    }
}
```

#### 3.1.2 批量操作优化

```java
import org.flowable.engine.RuntimeService;
import java.util.List;

public class BatchOperationExample {
    
    public void batchStartProcesses(RuntimeService runtimeService, List<String> businessKeys) {
        // 批量启动流程实例
        for (String businessKey : businessKeys) {
            try {
                runtimeService.startProcessInstanceByKey("leaveRequest", businessKey);
            } catch (Exception e) {
                System.err.println("启动流程实例失败: " + businessKey);
                // 继续处理下一个
            }
        }
    }
}
```

#### 3.1.3 异步执行优化

```java
import org.flowable.engine.RepositoryService;
import org.flowable.engine.repository.Deployment;

public class AsyncExecutionExample {
    
    public void deployWithAsync(RepositoryService repositoryService) {
        // 部署流程时启用异步执行
        // 在BPMN文件中设置：
        // <serviceTask id="serviceTask" flowable:async="true" ...>
        
        Deployment deployment = repositoryService.createDeployment()
            .name("异步流程")
            .addClasspathResource("processes/async-process.bpmn20.xml")
            .deploy();
        
        System.out.println("异步流程部署成功");
    }
}
```

### 3.2 安全注意事项

#### 3.2.1 SQL注入防护

```java
import org.flowable.engine.RepositoryService;
import org.flowable.engine.repository.ProcessDefinition;
import org.flowable.common.engine.api.FlowableIllegalArgumentException;

public class SqlInjectionProtectionExample {
    
    public void safeQuery(RepositoryService repositoryService, String processDefinitionKey) {
        try {
            // Flowable使用参数化查询，自动防护SQL注入
            ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()
                .processDefinitionKey(processDefinitionKey)
                .singleResult();
            
            if (processDefinition != null) {
                System.out.println("流程定义ID: " + processDefinition.getId());
            }
        } catch (FlowableIllegalArgumentException e) {
            System.err.println("查询参数无效: " + e.getMessage());
        }
    }
}
```

#### 3.2.2 权限控制

```java
import org.flowable.engine.TaskService;
import org.flowable.task.api.Task;
import org.flowable.idm.api.IdentityService;
import org.flowable.idm.api.User;

public class PermissionControlExample {
    
    public void completeTaskWithPermissionCheck(
            TaskService taskService, 
            IdentityService identityService,
            String taskId,
            String userId) {
        
        // 检查用户是否存在
        User user = identityService.createUserQuery().userId(userId).singleResult();
        if (user == null) {
            System.err.println("用户不存在: " + userId);
            return;
        }
        
        // 检查任务是否分配给该用户
        Task task = taskService.createTaskQuery().taskId(taskId).singleResult();
        if (task == null) {
            System.err.println("任务不存在: " + taskId);
            return;
        }
        
        if (!userId.equals(task.getAssignee())) {
            System.err.println("用户无权完成此任务");
            return;
        }
        
        // 完成任务
        taskService.complete(taskId);
        System.out.println("任务完成成功");
    }
}
```

#### 3.2.3 多租户数据隔离

```java
import org.flowable.engine.RuntimeService;
import org.flowable.engine.runtime.ProcessInstance;

public class MultiTenantExample {
    
    public void startProcessWithTenant(RuntimeService runtimeService, String tenantId) {
        // 启动流程实例时指定租户ID
        ProcessInstance processInstance = runtimeService.createProcessInstanceBuilder()
            .processDefinitionKey("leaveRequest")
            .tenantId(tenantId)
            .start();
        
        System.out.println("流程实例启动成功，租户ID: " + processInstance.getTenantId());
    }
    
    public void queryProcessInstancesByTenant(RuntimeService runtimeService, String tenantId) {
        // 按租户ID查询流程实例
        List<ProcessInstance> processInstances = runtimeService.createProcessInstanceQuery()
            .processInstanceTenantId(tenantId)
            .list();
        
        System.out.println("租户 " + tenantId + " 的流程实例数: " + processInstances.size());
    }
}
```

### 3.3 常见问题解决方案

#### 3.3.1 流程实例卡住问题

```java
import org.flowable.engine.RuntimeService;
import org.flowable.engine.runtime.Execution;
import java.util.List;

public class StuckProcessInstanceExample {
    
    public void diagnoseStuckProcess(RuntimeService runtimeService, String processInstanceId) {
        // 查询流程实例的所有执行
        List<Execution> executions = runtimeService.createExecutionQuery()
            .processInstanceId(processInstanceId)
            .list();
        
        System.out.println("执行数: " + executions.size());
        
        for (Execution execution : executions) {
            System.out.println("执行ID: " + execution.getId());
            System.out.println("活动ID: " + execution.getActivityId());
            System.out.println("是否挂起: " + execution.isSuspended());
            
            // 检查是否有等待事件
            // ...
        }
    }
}
```

#### 3.3.2 任务分配问题

```java
import org.flowable.engine.TaskService;
import org.flowable.task.api.Task;

public class TaskAssignmentExample {
    
    public void diagnoseTaskAssignment(TaskService taskService, String taskId) {
        // 查询任务详情
        Task task = taskService.createTaskQuery().taskId(taskId).singleResult();
        
        if (task == null) {
            System.err.println("任务不存在: " + taskId);
            return;
        }
        
        System.out.println("任务ID: " + task.getId());
        System.out.println("任务名称: " + task.getName());
        System.out.println("分配给: " + task.getAssignee());
        System.out.println("候选用户: " + task.getCandidateUsers());
        System.out.println("候选组: " + task.getCandidateGroups());
        
        // 检查任务是否可分配
        if (task.getAssignee() == null && 
            (task.getCandidateUsers() == null || task.getCandidateUsers().isEmpty()) &&
            (task.getCandidateGroups() == null || task.getCandidateGroups().isEmpty())) {
            System.err.println("任务未分配且无候选人，需要手动分配");
        }
    }
}
```

#### 3.3.3 数据库连接池问题

```java
import org.flowable.engine.ProcessEngineConfiguration;
import org.flowable.engine.impl.cfg.StandaloneProcessEngineConfiguration;

public class ConnectionPoolExample {
    
    public void configureConnectionPool() {
        // 配置数据库连接池
        ProcessEngineConfiguration processEngineConfiguration = 
            StandaloneProcessEngineConfiguration
                .createStandaloneProcessEngineConfiguration()
                .setJdbcUrl("jdbc:mysql://localhost:3306/flowable")
                .setJdbcUsername("flowable")
                .setJdbcPassword("flowable")
                .setJdbcMaxActiveConnections(20)      // 最大活动连接数
                .setJdbcMaxIdleConnections(10)       // 最大空闲连接数
                .setJdbcMaxWaitTime(10000)           // 最大等待时间（毫秒）
                .setJdbcPingEnabled(true)             // 启用连接检测
                .setJdbcPingQuery("SELECT 1")        // 检测查询
                .setJdbcPingConnectionNotUsedFor(3600000); // 1小时未使用的连接才检测
        
        System.out.println("数据库连接池配置完成");
    }
}
```

## 4. 典型业务场景实现

### 4.1 请假审批流程

#### 4.1.1 流程定义（BPMN）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
             xmlns:flowable="http://flowable.org/bpmn"
             targetNamespace="http://www.flowable.org/processdef">

    <process id="leaveRequest" name="请假流程" isExecutable="true">
        
        <!-- 开始事件 -->
        <startEvent id="startEvent" name="开始"/>
        
        <!-- 用户任务：提交请假申请 -->
        <userTask id="submitTask" name="提交请假申请" flowable:assignee="${applicant}"/>
        
        <!-- 用户任务：经理审批 -->
        <userTask id="managerApprovalTask" name="经理审批">
            <potentialOwner>
                <resourceAssignmentExpression>${manager}</resourceAssignmentExpression>
            </potentialOwner>
        </userTask>
        
        <!-- 排他网关：根据审批结果路由 -->
        <exclusiveGateway id="approvalGateway" name="审批结果"/>
        
        <!-- 用户任务：HR备案 -->
        <userTask id="hrRecordTask" name="HR备案">
            <potentialOwner>
                <resourceAssignmentExpression>hr</resourceAssignmentExpression>
            </potentialOwner>
        </userTask>
        
        <!-- 结束事件：同意 -->
        <endEvent id="approvedEndEvent" name="同意"/>
        
        <!-- 结束事件：拒绝 -->
        <endEvent id="rejectedEndEvent" name="拒绝"/>
        
        <!-- 顺序流 -->
        <sequenceFlow id="flow1" sourceRef="startEvent" targetRef="submitTask"/>
        <sequenceFlow id="flow2" sourceRef="submitTask" targetRef="managerApprovalTask"/>
        <sequenceFlow id="flow3" sourceRef="managerApprovalTask" targetRef="approvalGateway"/>
        <sequenceFlow id="flow4" name="同意" sourceRef="approvalGateway" targetRef="hrRecordTask">
            <conditionExpression xsi:type="tFormalExpression">${approved == true}</conditionExpression>
        </sequenceFlow>
        <sequenceFlow id="flow5" name="拒绝" sourceRef="approvalGateway" targetRef="rejectedEndEvent">
            <conditionExpression xsi:type="tFormalExpression">${approved == false}</conditionExpression>
        </sequenceFlow>
        <sequenceFlow id="flow6" sourceRef="hrRecordTask" targetRef="approvedEndEvent"/>
        
    </process>
    
</definitions>
```

#### 4.1.2 流程启动

```java
import org.flowable.engine.RuntimeService;
import org.flowable.engine.runtime.ProcessInstance;
import java.util.HashMap;
import java.util.Map;

public class LeaveRequestProcessExample {
    
    public void startLeaveRequestProcess(RuntimeService runtimeService) {
        // 准备流程变量
        Map<String, Object> variables = new HashMap<>();
        variables.put("applicant", "张三");
        variables.put("manager", "李四");
        variables.put("days", 3);
        variables.put("reason", "个人事务");
        
        // 启动流程实例
        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(
            "leaveRequest",
            "LR-2024-001",
            variables
        );
        
        System.out.println("请假流程启动成功，实例ID: " + processInstance.getId());
    }
}
```

#### 4.1.3 经理审批

```java
import org.flowable.engine.TaskService;
import org.flowable.task.api.Task;
import java.util.HashMap;
import java.util.Map;

public class ManagerApprovalExample {
    
    public void approveLeaveRequest(TaskService taskService, String taskId, boolean approved) {
        // 查询任务
        Task task = taskService.createTaskQuery().taskId(taskId).singleResult();
        
        if (task == null) {
            System.err.println("任务不存在: " + taskId);
            return;
        }
        
        // 准备审批变量
        Map<String, Object> variables = new HashMap<>();
        variables.put("approved", approved);
        variables.put("comment", approved ? "同意请假申请" : "拒绝请假申请");
        
        // 完成任务
        taskService.complete(taskId, variables);
        System.out.println("审批完成，结果: " + (approved ? "同意" : "拒绝"));
    }
}
```

### 4.2 订单处理流程

#### 4.2.1 流程定义（BPMN）

```xml
<?xml version="1.0" encoding="UTF-8"?>
<definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL"
             xmlns:flowable="http://flowable.org/bpmn"
             targetNamespace="http://www.flowable.org/processdef">

    <process id="orderProcess" name="订单处理流程" isExecutable="true">
        
        <!-- 消息开始事件 -->
        <messageEventDefinition id="orderReceivedMessage" messageRef="orderReceived"/>
        <startEvent id="messageStartEvent" name="订单接收" isInterrupting="true">
            <messageEventDefinition messageRef="orderReceivedMessage"/>
        </startEvent>
        
        <!-- 服务任务：验证订单 -->
        <serviceTask id="validateOrderTask" name="验证订单" flowable:class="com.example.ValidateOrderDelegate"/>
        
        <!-- 用户任务：财务审核 -->
        <userTask id="financeApprovalTask" name="财务审核">
            <potentialOwner>
                <resourceAssignmentExpression>finance</resourceAssignmentExpression>
            </potentialOwner>
        </userTask>
        
        <!-- 服务任务：处理支付 -->
        <serviceTask id="processPaymentTask" name="处理支付" flowable:async="true" flowable:class="com.example.ProcessPaymentDelegate"/>
        
        <!-- 用户任务：发货 -->
        <userTask id="shippingTask" name="发货">
            <potentialOwner>
                <resourceAssignmentExpression>shipping</resourceAssignmentExpression>
            </potentialOwner>
        </userTask>
        
        <!-- 结束事件 -->
        <endEvent id="orderCompletedEvent" name="订单完成"/>
        
        <!-- 顺序流 -->
        <sequenceFlow id="flow1" sourceRef="messageStartEvent" targetRef="validateOrderTask"/>
        <sequenceFlow id="flow2" sourceRef="validateOrderTask" targetRef="financeApprovalTask"/>
        <sequenceFlow id="flow3" sourceRef="financeApprovalTask" targetRef="processPaymentTask"/>
        <sequenceFlow id="flow4" sourceRef="processPaymentTask" targetRef="shippingTask"/>
        <sequenceFlow id="flow5" sourceRef="shippingTask" targetRef="orderCompletedEvent"/>
        
    </process>
    
    <!-- 消息定义 -->
    <message id="orderReceived" name="orderReceived"/>
    
</definitions>
```

#### 4.2.2 订单验证委托

```java
import org.flowable.engine.delegate.DelegateExecution;
import org.flowable.engine.delegate.JavaDelegate;

public class ValidateOrderDelegate implements JavaDelegate {
    
    @Override
    public void execute(DelegateExecution execution) {
        // 获取订单信息
        String orderId = (String) execution.getVariable("orderId");
        Double amount = (Double) execution.getVariable("amount");
        
        // 验证订单
        boolean valid = validateOrder(orderId, amount);
        
        // 设置验证结果
        execution.setVariable("orderValid", valid);
        
        System.out.println("订单验证完成，订单ID: " + orderId + ", 验证结果: " + valid);
    }
    
    private boolean validateOrder(String orderId, Double amount) {
        // 实际验证逻辑
        return amount != null && amount > 0;
    }
}
```

#### 4.2.3 支付处理委托

```java
import org.flowable.engine.delegate.DelegateExecution;
import org.flowable.engine.delegate.JavaDelegate;

public class ProcessPaymentDelegate implements JavaDelegate {
    
    @Override
    public void execute(DelegateExecution execution) {
        // 获取订单信息
        String orderId = (String) execution.getVariable("orderId");
        Double amount = (Double) execution.getVariable("amount");
        
        try {
            // 处理支付
            boolean paymentSuccess = processPayment(orderId, amount);
            
            // 设置支付结果
            execution.setVariable("paymentSuccess", paymentSuccess);
            
            System.out.println("支付处理完成，订单ID: " + orderId + ", 支付结果: " + paymentSuccess);
        } catch (Exception e) {
            // 支付失败，设置重试
            execution.setVariable("paymentSuccess", false);
            execution.setVariable("paymentError", e.getMessage());
            throw e;
        }
    }
    
    private boolean processPayment(String orderId, Double amount) {
        // 实际支付处理逻辑
        // 这里可以调用第三方支付API
        return true;
    }
}
```

## 5. 测试规范

### 5.1 单元测试

#### 5.1.1 基础单元测试

```java
import org.flowable.engine.*;
import org.flowable.engine.repository.Deployment;
import org.flowable.engine.runtime.ProcessInstance;
import org.flowable.task.api.Task;
import org.junit.jupiter.api.*;

import static org.junit.jupiter.api.Assertions.*;

public class ProcessEngineTest {
    
    private ProcessEngine processEngine;
    private RuntimeService runtimeService;
    private TaskService taskService;
    private RepositoryService repositoryService;
    
    @BeforeEach
    public void setUp() {
        // 创建流程引擎
        processEngine = ProcessEngineConfiguration
            .createStandaloneInMemProcessEngineConfiguration()
            .buildProcessEngine();
        
        // 获取服务
        runtimeService = processEngine.getRuntimeService();
        taskService = processEngine.getTaskService();
        repositoryService = processEngine.getRepositoryService();
    }
    
    @Test
    public void testDeployProcess() {
        // 部署流程
        Deployment deployment = repositoryService.createDeployment()
            .addClasspathResource("processes/test-process.bpmn20.xml")
            .deploy();
        
        assertNotNull(deployment);
        assertNotNull(deployment.getId());
    }
    
    @Test
    public void testStartProcessInstance() {
        // 部署流程
        repositoryService.createDeployment()
            .addClasspathResource("processes/test-process.bpmn20.xml")
            .deploy();
        
        // 启动流程实例
        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("testProcess");
        
        assertNotNull(processInstance);
        assertNotNull(processInstance.getId());
        assertEquals("testProcess", processInstance.getProcessDefinitionKey());
    }
    
    @Test
    public void testCompleteTask() {
        // 部署流程
        repositoryService.createDeployment()
            .addClasspathResource("processes/test-process.bpmn20.xml")
            .deploy();
        
        // 启动流程实例
        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("testProcess");
        
        // 查询任务
        Task task = taskService.createTaskQuery()
            .processInstanceId(processInstance.getId())
            .singleResult();
        
        assertNotNull(task);
        
        // 完成任务
        taskService.complete(task.getId());
        
        // 验证任务已完成
        long taskCount = taskService.createTaskQuery()
            .processInstanceId(processInstance.getId())
            .count();
        
        assertEquals(0, taskCount);
    }
    
    @AfterEach
    public void tearDown() {
        // 关闭流程引擎
        processEngine.close();
    }
}
```

#### 5.1.2 集成测试

```java
import org.flowable.engine.*;
import org.flowable.engine.repository.Deployment;
import org.flowable.engine.runtime.ProcessInstance;
import org.flowable.task.api.Task;
import org.junit.jupiter.api.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import static org.junit.jupiter.api.Assertions.*;

@SpringBootTest
public class ProcessIntegrationTest {
    
    @Autowired
    private ProcessEngine processEngine;
    
    @Autowired
    private RuntimeService runtimeService;
    
    @Autowired
    private TaskService taskService;
    
    @Autowired
    private RepositoryService repositoryService;
    
    @Test
    public void testFullProcess() {
        // 部署流程
        Deployment deployment = repositoryService.createDeployment()
            .addClasspathResource("processes/leave-request.bpmn20.xml")
            .deploy();
        
        assertNotNull(deployment);
        
        // 启动流程实例
        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(
            "leaveRequest",
            "LR-TEST-001"
        );
        
        assertNotNull(processInstance);
        
        // 查询并完成任务
        Task task = taskService.createTaskQuery()
            .processInstanceId(processInstance.getId())
            .singleResult();
        
        assertNotNull(task);
        taskService.complete(task.getId());
        
        // 验证流程完成
        long taskCount = taskService.createTaskQuery()
            .processInstanceId(processInstance.getId())
            .count();
        
        assertEquals(0, taskCount);
    }
}
```

### 5.2 测试最佳实践

#### 5.2.1 使用内存数据库

```java
import org.flowable.engine.ProcessEngineConfiguration;
import org.flowable.engine.impl.cfg.StandaloneInMemProcessEngineConfiguration;

public class TestDatabaseConfig {
    
    public static ProcessEngineConfiguration createTestConfiguration() {
        return StandaloneInMemProcessEngineConfiguration
            .createStandaloneInMemProcessEngineConfiguration()
            .setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE)
            .setAsyncExecutorActivate(false)  // 测试时不激活异步执行器
            .setAsyncHistoryExecutorActivate(false);
    }
}
```

#### 5.2.2 测试数据清理

```java
import org.flowable.engine.*;
import org.junit.jupiter.api.*;

public class TestDataCleanup {
    
    private ProcessEngine processEngine;
    
    @BeforeEach
    public void setUp() {
        processEngine = ProcessEngineConfiguration
            .createStandaloneInMemProcessEngineConfiguration()
            .buildProcessEngine();
    }
    
    @AfterEach
    public void cleanUp() {
        // 清理所有部署
        processEngine.getRepositoryService().createDeploymentQuery()
            .list()
            .forEach(deployment -> {
                processEngine.getRepositoryService().deleteDeployment(
                    deployment.getId(), 
                    true
                );
            });
        
        // 关闭引擎
        processEngine.close();
    }
}
```

## 6. 总结

本文档详细介绍了Flowable Engine的标准使用方式和最佳实践，涵盖了从项目初始化到核心功能使用的各个方面。

### 6.1 关键要点

1. **配置管理**：灵活的配置方式，支持XML、YAML和环境变量
2. **流程部署**：支持多种部署方式，包括BPMN文件和ZIP包
3. **流程启动**：多种启动方式，包括键、ID和消息
4. **任务处理**：完整的任务生命周期管理
5. **变量操作**：灵活的变量管理机制
6. **性能优化**：缓存、批量和异步执行等优化技巧
7. **安全防护**：SQL注入防护、权限控制和多租户隔离
8. **测试规范**：完善的单元测试和集成测试框架

### 6.2 最佳实践建议

1. **使用流程定义缓存**：提高查询性能
2. **批量操作**：减少数据库访问次数
3. **异步执行**：提高系统吞吐量
4. **错误处理**：完善的异常处理机制
5. **边界检查**：验证输入和状态
6. **权限控制**：确保操作安全
7. **多租户隔离**：保护数据安全
8. **测试覆盖**：确保代码质量

通过遵循这些最佳实践，可以充分发挥Flowable Engine的优势，构建高效、稳定、安全的业务流程管理系统。
